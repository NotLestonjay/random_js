<!DOCTYPE html>
<html lang="en">
    <head>
        <title>YESNT</title>
        <link rel="icon" type="image/x-icon" href="./favicon.ico">
        <meta charset="UTF-8">
        <meta name="description" content="Your school is pushing their psuedoscientific agenda on you; you must escape before things get worse."/>
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link href="https://fonts.googleapis.com/css?family=Karla:400,700|Share+Tech+Mono&display=swap" rel="stylesheet">
        
       <style>
        body {
  margin: 0;
  font-size: 0;
  background-color: black;
  font-family: 'Karla', sans-serif;
  font-weight: 400;
}
h1, h2 {
  font-weight: 700;
  text-transform: uppercase;
  margin-bottom: 0;
  line-height: 1;
}
canvas {
  width: 100%;
  height: 100%;
}
:disabled {
  opacity: 0.5;
  pointer-events: none;
}

#subtitles, #key-hint, #hint {
  text-align: center;
  position: fixed;
  bottom: 0;
  z-index: 1;
}
#subtitles {
  text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.5);
  font-size: 16px;
  left: 0;
  right: 0;
  color: white;
  margin: 0 auto;
  margin-bottom: 35px;
  max-width: 500px;
}
#key-hint {
  background-color: rgba(0, 0, 0, 0.3);
  font-size: 12px;
  padding: 5px 10px;
  color: white;
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 8px;
  border-radius: 5px;
}
#hint {
  text-shadow: 1px 1px 10px white, 1px 1px 5px white;
  font-size: 18px;
  height: 1em;
  top: 0;
  left: 0;
  right: 0;
  margin: auto;
  max-width: 500px;
}

.death-note {
  position: fixed;
  left: 50%;
  transform: translate(-50%, 0);
  bottom: 100px;
  background-color: #b53232;
  padding: 10px;
  border-radius: 50px;
  z-index: 1;
  font-size: 16px;
  color: rgba(255, 255, 255, 0.5);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
  box-sizing: border-box;
  transition: all .5s;
  animation: fade-away .5s 6s forwards;
  overflow: hidden;
  white-space: nowrap;
}
.death-note.hide-death-note {
  opacity: 0;
  transform: translate(-50%, 20px);
  max-width: 44px;
  transition: none;
  animation: none;
}
.death-note img {
  height: 24px;
  opacity: 0.8;
  vertical-align: middle;
  margin-right: 10px;
}
#death-reason {
  color: white;
}
@keyframes fade-away {
  from {
    opacity: 1;
    transform: translate(-50%, 0);
  }
  to {
    opacity: 0;
    transform: translate(-50%, 20px);
  }
}

.note {
  position: fixed;
  display: flex;
  z-index: 1;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  justify-content: center;
  align-items: center;
  color: white;
  text-align: center;
  flex-direction: column;
}
.note-content {
  max-width: 500px;
  padding: 5px;
  background-color: rgba(0, 0, 0, 0.5);
  border-radius: 5px;
  border: 1px solid rgba(0, 0, 0, 0.5);
}
.note p {
  font-size: 12px;
}
.hide-note .note {
  display: none;
}

#progress-bar {
  background-color: rgba(255, 255, 255, 0.5);
  height: 5px;
  position: fixed;
  z-index: 1;
  bottom: 0;
  left: 0;
  width: 0;
  transition: width .2s;
}
#progress-bar.hide-bar {
  opacity: 0;
  transition: opacity .5s;
  pointer-events: none;
}

#lung-indicator {
  position: fixed;
  z-index: 1;
  bottom: 0;
  right: 0;
  margin: 40px;
  --size: 50px;
  --icon-size: 20px;
  --blood: red;
}
#lung-indicator::before, #lung-indicator::after {
  content: '';
  display: block;
  position: absolute;
  transform: translate(-50%, -50%);
}
#lung-indicator::before {
  width: var(--size);
  height: var(--size);
  border: 2px solid white;
  border-radius: 50%;
  background-color: var(--blood);
}
#lung-indicator::after {
  width: 50px;
  height: 50px;
  background-image: url('./lungs.svg');
  background-repeat: no-repeat;
  background-position: center;
  background-size: var(--icon-size);
}
.hide-lungs #lung-indicator {
  display: none;
}
.reminder-to-breathe {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  pointer-events: none;
  font-size: 5vh;
  color: white;
  z-index: 1;
}
.reminder-to-breathe span {
  animation: flash-in forwards 1s cubic-bezier(0, 0.5, 1, 0), fade-out forwards 1s cubic-bezier(1, 0, 1, 1);
}
@keyframes flash-in {
  from {
    transform: scale(0);
  }
  to {
    transform: scale(2);
  }
}
@keyframes fade-out {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

.pose-indicator {
  position: fixed;
  z-index: 1;
  bottom: 80px;
  right: 15px;
  background-color: rgba(0, 0, 0, 0.3);
  padding: 5px;
  border-radius: 10px;
}
.pose-indicator::before {
  content: 'REST';
  font-size: 10px;
  display: block;
  text-align: center;
  color: white;
}
.pose-indicator::after {
  content: '';
  display: block;
  width: 40px;
  height: 45px;
  background-image: url('./images/poses.svg');
  background-size: auto 100%;
  background-position-x: 0;
}
.indicate-phone .pose-indicator::before { content: 'PHONE'; }
.indicate-phone .pose-indicator::after { background-position-x: 25%; }
.indicate-power .pose-indicator::before { content: 'POWER'; }
.indicate-power.indicate-power-up .pose-indicator::after { background-position-x: 50%; }
.indicate-power.indicate-power-down .pose-indicator::after { background-position-x: 75%; }
.indicate-expansion .pose-indicator::before { content: 'EXPAND'; }
.indicate-expansion .pose-indicator::after { background-position-x: 100%; }
.hide-pose .pose-indicator, .expansion-indicator {
  display: none;
}
.indicate-expansion .expansion-indicator {
  display: block;
  position: absolute;
  bottom: 5px;
  left: 5px;
  right: 5px;
  height: 45px;
}
.expansion-indicator::before, .expansion-indicator::after {
  content: '';
  position: absolute;
  width: 15px;
  height: 2.5px;
  border-radius: 5px;
  background-color: white;
  top: 0;
  bottom: 0;
  margin: auto;
  left: 0;
  transform-origin: right;
  transform: rotate(var(--expansion));
}
.expansion-indicator::after {
  left: auto;
  right: 0;
  transform-origin: left;
  transform: scaleY(-1) rotate(var(--expansion));
}

.cant-jump {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 40px;
  z-index: 4;
  background-color: black;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  font-size: 14px;
  color: white;
}
.hide-cant-jump .cant-jump {
  display: none;
}

.end {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 4;
  display: flex;
  justify-content: center;
  align-items: center;
  padding-left: 250px;
}
.hide-options .end {
  padding-left: 0;
}
.wrapper {
  overflow: auto;
  max-height: 100%;
}
.end .wrapper {
  max-width: 500px;
  font-size: 18px;
}
.hide-end .end {
  display: none;
}
.escaped .end {
  background-color: white;
  color: rgba(0, 0, 0, 0.8);
}
.completed .end {
  background-color: rgba(0, 0, 0, 0.6);
  color: white;
}
.escaped .end .wrapper,
.completed .end {
  animation: fade-out .5s reverse;
}
.end-reason {
  display: none;
}
.escaped .escape,
.completed .complete {
  display: block;
}
.stat-table {
  border: 1px solid rgba(0, 0, 0, 0.2);
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 5px;
  margin: 20px 0;
}
.stat-row {
  display: flex;
  border-bottom: 1px solid rgba(0, 0, 0, 0.2);
  align-items: stretch;
}
.stat-row:last-child {
  border-bottom: none;
}
.stat-row div {
  padding: 10px;
}
.stat-row .stat-value {
  text-align: right;
  flex: auto;
  white-space: nowrap;
}
.input {
  -webkit-appearance: none;
  background: none;
  border: none;
  padding: 5px 10px;
  border-radius: 5px;
  background-color: rgba(0, 0, 0, 0.5);
  font: inherit;
  color: inherit;
}
.input::-webkit-input-placeholder {
  color: inherit;
  opacity: 0.2;
}
.input:focus {
  outline: none;
  background-color: rgba(0, 0, 0, 0.8);
}
.escaped .input {
  background-color: rgba(0, 0, 0, 0.05);
}
.escaped .input:focus {
  background-color: rgba(0, 0, 0, 0.1);
}
#username {
  text-transform: uppercase;
  width: 3ch;
  font-family: 'Share Tech Mono', monospace;
}
.url-wrapper {
  display: flex;
  align-items: center;
  white-space: pre-wrap;
}
#url {
  flex: auto;
}
.completed .end .button {
  color: white;
}
.completed .end .button:hover {
  background-color: white;
  color: black;
}
.problem {
  color: red;
  white-space: pre-wrap;
}
.hidden {
  display: none;
}
.full {
  width: 100%;
}
.leaderboard {
  display: flex;
  justify-content: center;
  font-family: 'Share Tech Mono', monospace;
  position: relative;
}
.column {
  display: inline-block;
}
.leaderboard-entry {
  display: block;
  opacity: 0.7;
  padding: 0 5px;
}
.heading {
  opacity: 1;
}
.entry-data {
  text-align: right;
}
.mine {
  background-color: rgba(0, 0, 0, 0.1);
  opacity: 0.9;
}
.completed .mine {
  background-color: rgba(255, 255, 255, 0.2);
}
.entry-name:link, .entry-name:visited {
  color: inherit;
  opacity: 1;
  text-decoration: none;
}
.entry-name:link:hover {
  text-decoration: underline;
}
.ellipsis {
  height: 0.5em;
  opacity: 0.2;
}
.column:first-child .ellipsis::before {
  content: '\B7\B7\B7';
  position: absolute;
  left: 0;
  right: 0;
  text-align: center;
}

.error {
  background-color: red;
  font-size: 16px;
  padding: 20px;
  position: fixed;
  color: white;
  animation: error 1s forwards;
}
@keyframes error {
  0% {
    top: 100%;
  }
  100% {
    top: 0;
  }
}

.options {
  font-size: 14px;
  padding: 20px;
  position: fixed;
  z-index: 4;
  background-color: rgba(175, 175, 175, 0.8);
  color: rgba(0, 0, 0, 0.9);
  top: 0;
  left: 0;
  bottom: 0;
  width: 250px;
  box-sizing: border-box;
  overflow: auto;
  line-height: 1.5;
  transition: left .2s;
}
.hide-options .options {
  left: -250px;
  pointer-events: none;
}

.options p {
  margin: 0.5em 0;
}
.options label {
  display: block;
  margin: 0.5em 0;
}

.slider-wrapper {
  display: flex;
}
.slider-wrapper span {
  flex: none;
  width: 5ch;
  text-align: right;
}
input[type=range] {
  -webkit-appearance: none;
  margin: 0 0;
  background: none;
  flex: auto;
}
input[type=range]:focus {
  outline: none;
}
input[type=range]::-webkit-slider-runnable-track {
  width: 100%;
  height: 1em;
  cursor: pointer;
  background-color: rgba(0, 0, 0, 0.5);
  border-radius: 2px;
}
input[type=range]::-webkit-slider-thumb {
  height: 1em;
  width: 0.5em;
  border-radius: 2px;
  background-color: rgba(255, 255, 255, 0.5);
  cursor: pointer;
  -webkit-appearance: none;
}

.key-input {
  display: inline-block;
  background-color: rgba(255, 255, 255, 0.5);
  width: 60px;
  height: 1em;
  border-radius: 5px;
  cursor: pointer;
  position: relative;
  vertical-align: middle;
  margin-right: 10px;
  font-size: 0.8em;
  line-height: 1;
  text-align: center;
  transition: background-color .2s;
}
.key-input:focus {
  outline: none;
  background-color: rgba(255, 255, 255, 0.8);
}
.key-input::before {
  content: 'Recording...';
  position: absolute;
  bottom: 80%;
  opacity: 0;
  color: rgba(255, 255, 255, 0.5);
  font-size: 10px;
  left: 0;
  pointer-events: none;
  transition: all .2s;
}
.key-input:focus::before {
  opacity: 1;
  bottom: 100%;
}
.key-input.duplicate-key {
  background-color: rgba(255, 78, 81, 0.8);
}
.key-input.duplicate-key::before {
  color: rgba(255, 78, 81, 0.5);
}

.button {
  -webkit-appearance: none;
  cursor: pointer;
  padding: 5px 10px;
  border: 1px solid currentColor;
  background: none;
  border-radius: 5px;
  white-space: pre;
  display: inline-block;
  box-sizing: border-box;
  font: inherit;
  color: black;
  margin: 5px 0;
  text-align: center;
  transition: background-color .2s, color .2s;
}
a.button {
  text-decoration: none;
  color: inherit;
}
.button:hover {
  background-color: black;
  color: white;
}
.button:focus {
  outline: none;
}

.controls-keyboard {
  position: absolute;
  transform: translate(-50%, -50%);
  max-width: 90vw;
  max-height: 90vh;
}

.dev-note {
  position: fixed;
  top: 0;
  right: 0;
  max-width: 300px;
  width: 80%;
  margin: 10px;
  border-color: rgba(255, 0, 0, 0.7);
  box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
  color: white;
  opacity: 0.5;
  pointer-events: none;
  font-size: 10px;
}
.hide-dev .dev-note {
  display: none;
}
#touch-ui {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  z-index: 2;
}
.using-touch #touch-ui {
  display: block;
}
.using-touch #key-hint {
  display: none;
}

#touch-circle {
  position: absolute;
  bottom: 0;
  left: 0;
  margin: 40px;
  border-radius: 50%;
  width: 80px;
  height: 80px;
  background-color: rgba(0, 0, 0, 0.2);
  border: 3px solid rgba(255, 255, 255, 0.1);
  opacity: 0.5;
  pointer-events: none;
}
.can-move #touch-circle {
  opacity: 1;
  pointer-events: all;
  box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
}
.moving::after {
  content: '';
  position: absolute;
  width: 40px;
  height: 40px;
  margin: 20px;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.2);
  border: 3px solid rgba(0, 0, 0, 0.1);
  left: var(--x);
  top: var(--y);
}

.button-wrapper {
  padding: 10px;
  overflow: auto;
  width: 100%;
  white-space: nowrap;
}
.touch-button {
  display: none;
  border: 3px solid rgba(0, 162, 198, 0.3);
  color: white;
  background-color: rgba(0, 162, 198, 0.3);
  border-radius: 5px;
  padding: 10px;
  margin: 10px;
  font: inherit;
  font-size: 16px;
  cursor: pointer;
  transition: all .2s;
}
.available {
  display: inline-block;
}
.pressed {
  background-color: rgba(0, 162, 198, 0.6);
  transform: scale(1.2);
}
.touch-icon {
  display: inline-block;
  width: 32px;
  height: 36px;
  font-size: 0;
  background-repeat: no-repeat;
  background-size: auto 100%;
  vertical-align: middle;
  margin: -5px;
  pointer-events: none;
}
.pose-icon {
  background-image: url('./images/poses.svg');
}
.sim-phone { background-position-x: 25%; }
.sim-power-up { background-position-x: 50%; }
.sim-power-down { background-position-x: 75%; }
.sim-reset { background-position-x: 0; }
.sim-exp-up { background-image: url('./images/exp-up.svg'); }
.sim-exp-down { background-image: url('./images/exp-down.svg'); }
.options-btn {
  border-color: rgba(127, 127, 127, 0.3);
  background-color: rgba(127, 127, 127, 0.3);
}
.options-btn.pressed {
  background-color: rgba(127, 127, 127, 0.6);
}
.options-icon {
  width: 36px;
  background-image: url('./images/settings-icon.svg');
}

.using-touch #lung-indicator {
  margin: 80px;
  transform: scale(1.5);
}
.using-touch .pose-indicator {
  bottom: 160px;
  right: 55px;
}
#breathe-interaction {
  display: flex;
  position: fixed;
  bottom: 0;
  right: 0;
  width: 160px;
  height: 160px;
  flex-direction: column;
}
.hide-lungs #breathe-interaction {
  display: none;
}
.breath-direction {
  display: flex;
  flex: auto;
  pointer-events: none;
  margin: 10px;
}
.inhale-label {
  border-top-left-radius: 25px;
  border-top-right-radius: 25px;
  margin-bottom: 0;
  padding-bottom: 10px;
  flex-direction: column;
}
.exhale-label {
  border-bottom-left-radius: 25px;
  border-bottom-right-radius: 25px;
  margin-top: 0;
  padding-top: 10px;
  flex-direction: column-reverse;
}
.inhaling .inhale-label,
.exhaling .exhale-label {
  background-color: rgba(255, 255, 255, 0.2);
}
.breath-dir-icon {
  flex: auto;
  opacity: 0.5;
  background-image: url('./images/breathe-dir.svg');
  background-size: 24px;
  background-position: center 30%;
  background-repeat: no-repeat;
  transition: all .2s;
}
.exhale-label .breath-dir-icon {
  transform: scaleY(-1);
}
.inhaling .inhale-label .breath-dir-icon,
.exhaling .exhale-label .breath-dir-icon {
  opacity: 1;
  background-position-y: 0;
}
.breath-label {
  font-size: 14px;
  text-align: center;
  color: white;
  text-transform: uppercase;
  text-shadow: 0 0 5px black;
  transition: opacity .5s;
}
.breathing .breath-label {
  opacity: 0;
}

       </style>
    </head>
    <body class="hide-lungs hide-cant-jump hide-end hide-options hide-pose hide-dev">
        <p id="subtitles"></p>
        <p id="key-hint" class="hidden"></p>
        <p id="hint"></p>
        <div class="death-note hide-death-note">
            <img src="./images/death-icon.svg" alt=":(">
            You failed to <span id="death-reason">breathe</span>
            .
        </div>
        <div class="note">
            <div class="note-content">
                <p>This is a work of fiction. Names, characters, businesses, places, events and incidents are either the products of the author's imagination or used in a fictitious manner. Any resemblance to actual persons, living or dead, or actual events is purely coincidental.</p>
                <p>Click/tap the screen iff you believe this.</p>
            </div>
        </div>
        <div id="touch-ui">
            <div id="touch-circle" class="touch-target"></div>
            <div class="button-wrapper">
                <button class="touch-target touch-button options-btn available">
                    <span class="touch-icon options-icon">options</span>
                </button>
                <button class="touch-target touch-button" data-sim-key="skip-intro">skip intro</button>
                <button class="touch-target touch-button" data-sim-key="get-up">get up</button>
                <button class="touch-target touch-button" data-sim-key="phone">
                    <span class="touch-icon pose-icon sim-phone">phone out/away</span>
                </button>
                <button class="touch-target touch-button" data-sim-key="exp-up">
                    <span class="touch-icon sim-exp-up">expansion up</span>
                </button>
                <button class="touch-target touch-button" data-sim-key="exp-down">
                    <span class="touch-icon sim-exp-down">expansion down</span>
                </button>
                <button class="touch-target touch-button" data-sim-key="power-up">
                    <span class="touch-icon pose-icon sim-power-up">power up</span>
                </button>
                <button class="touch-target touch-button" data-sim-key="power-down">
                    <span class="touch-icon pose-icon sim-power-down">power down</span>
                </button>
                <button class="touch-target touch-button" data-sim-key="reset">reset pose</button>
                <button class="touch-target touch-button" data-sim-key="pick-up">pick up light</button>
            </div>
            <div class="touch-target" id="breathe-interaction">
                <div class="breath-direction inhale-label">
                    <span class="breath-dir-icon"></span>
                    <span class="breath-label">Inhale</span>
                </div>
                <div class="breath-direction exhale-label">
                    <span class="breath-dir-icon"></span>
                    <span class="breath-label">Exhale</span>
                </div>
            </div>
        </div>
        <div id="progress-bar"></div>
        <div id="lung-indicator"></div>
        <div class="pose-indicator">
            <span class="expansion-indicator"></span>
        </div>
        <div class="cant-jump">
            <span>Jumping upwards is easy. Landing softly is the hard part.</span>
        </div>
        <div class="end clickable">
            <div class="wrapper">
                <div class="end-reason escape">
                    <h1>You've escaped</h1>
                </div>
                <div class="end-reason complete">
                    <h1>Reeducation complete</h1>
                </div>
                <div id="stattable" class="stat-table"></div>
                <!-- TEMP -->
                <p>LEADERBOARD WILL BE CLEARED BECAUSE THIS GAME WIP</p>
                <p>Submit your score to the leaderboard:</p>
                <p>
                    <label>
                        Three-letter/number name: <input type="text" class="input" maxlength="3" id="username" placeholder="YES">
                    </label>
                </p>
                <p>
                    <label class="url-wrapper">
                        URL (optional): <input type="url" class="input" id="url" placeholder="https://gunn.app/">
                    </label>
                </p>
                <p class="problem hidden" id="problem"></p>
                <p>
                    <button type="button" class="button" id="submit-score">Submit</button>
                </p>
                <div class="leaderboard hidden" id="leaderboard"></div>
                <p>
                    <button type="button" class="button full" id="play-again">Play again</button>
                </p>
                <p>
                    <a class="button full" href="./leaderboard.html">Full leaderboard</a>
                </p>
            </div>
        </div>
        <div class="options clickable">
            <p>Click outside of this panel to close.</p>
            <p>
                <button class="button" id="restart">Restart</button>
            </p>
            <p>
                <a class="button" href="./settings.html">Gameplay settings</a>
            </p>
            <h1>Controls</h1>
            <p>
                <button class="button" id="reset-settings">Reset settings</button>
            </p>
            <label>
                FOV 
                <div class="slider-wrapper">
                    <input type="range" id="fov" min="30" max="120">
                    <span id="fov-val"></span>
                </div>
            </label>
            <label>
                Mouse sensitivity 
                <div class="slider-wrapper">
                    <input type="range" id="sensitivity" min="2.2" max="4" step="any">
                </div>
            </label>
            <label>
                Touch sensitivity 
                <div class="slider-wrapper">
                    <input type="range" id="touch-sensitivity" min="1" max="3" step="any">
                </div>
            </label>
            <h2>Key mappings</h2>
            <p>The number keys are used for entering in the code and cannot be reassigned.</p>
            <p>
                <span class="key-input" tabindex="0" data-fn="inhale"></span>
                Inhale
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="exhale"></span>
                Exhale
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="skip-intro"></span>
                Skip intro
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="reset"></span>
                Reset pose
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="exp-up"></span>
                Expansion breath: arms up
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="exp-down"></span>
                Expansion breath: arms down
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="power-up"></span>
                Power breath: arms up
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="power-down"></span>
                Power breath: arms down
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="om"></span>
                Say omm
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="get-up"></span>
                Get up
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="phone"></span>
                Take out/put away phone
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="forth"></span>
                Run forwards
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="back"></span>
                Run backwards
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="left"></span>
                Sidestep left
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="right"></span>
                Sidestep right
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="trip"></span>
                Jump
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="pick-up"></span>
                Pick up light
            </p>
            <p>
                <span class="key-input" tabindex="0" data-fn="del-code-digit"></span>
                Delete last code digit
            </p>
            <h2>Total stats</h2>
            <p>
                <a class="button" href="./leaderboard.html">Global leaderboard</a>
            </p>
            <div id="total-stattable" class="stat-table"></div>
            <h1>About</h1>
            <p>A mysterious YESNT (YESNT Eradication of Students' Nerve Tension) Program has come to your school, and you immediately suspect something going on. You deduce that they are trialing an experimental breathing exercise to brainwash students. As an indepedent citizen, you do not desire to be dictated by a foreign power, so you must egress from the situation promptly!</p>
            <p>Your plan: Do the YESNT breathing arms while the instructor is watching, and when she's not, take out your phone and spy on the administration's secret broadcast for the passcode to a door. Get up, which will inevitably attract the attention of the instructor, try the code on every single door, and escape when it works.</p>
            <p>Anything is worth having a free mind.</p>
        </div>
        <div class="note-content dev-note">You have test parameters meant for development enabled, so the game will not save your progress. To undo this, remove the part of the URL after the question mark (?).</div>
        <script>
            function create(type1, parent, html) {
  var elem = document.createElement(type1);
  parent.appendChild(elem);
  elem.outerHTML = html;
}

create('title', document.head, '<title>YESNT</title>');
create('meta', document.head, '<meta charset="UTF-8">');
create('meta', document.head, `
 <meta name="description" content="Your school is pushing their psuedoscientific agenda on you; you must escape before things get worse."/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link href="https://fonts.googleapis.com/css?family=Karla:400,700|Share+Tech+Mono&display=swap" rel="stylesheet">
        
`)



//JS
var t, e;
t = this,
e = function(t) {
    function e() {}
    function i(t, e) {
        this.x = t || 0,
        this.y = e || 0
    }
    function n(t, e, i, n) {
        this._x = t || 0,
        this._y = e || 0,
        this._z = i || 0,
        this._w = void 0 !== n ? n : 1
    }
    function r(t, e, i) {
        this.x = t || 0,
        this.y = e || 0,
        this.z = i || 0
    }
    function a() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length
    }
    function o(t, e, n, r, s, c, h, l, u, p) {
        Object.defineProperty(this, "id", {
            value: Wr++
        }),
        this.uuid = Vr.generateUUID(),
        this.name = "",
        this.image = void 0 !== t ? t : o.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = void 0 !== e ? e : o.DEFAULT_MAPPING,
        this.wrapS = void 0 !== n ? n : 1001,
        this.wrapT = void 0 !== r ? r : 1001,
        this.magFilter = void 0 !== s ? s : 1006,
        this.minFilter = void 0 !== c ? c : 1008,
        this.anisotropy = void 0 !== u ? u : 1,
        this.format = void 0 !== h ? h : 1023,
        this.type = void 0 !== l ? l : 1009,
        this.offset = new i(0,0),
        this.repeat = new i(1,1),
        this.center = new i(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new a,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = void 0 !== p ? p : 3e3,
        this.version = 0,
        this.onUpdate = null
    }
    function s(t, e, i, n) {
        this.x = t || 0,
        this.y = e || 0,
        this.z = i || 0,
        this.w = void 0 !== n ? n : 1
    }
    function c(t, e, i) {
        this.width = t,
        this.height = e,
        this.scissor = new s(0,0,t,e),
        this.scissorTest = !1,
        this.viewport = new s(0,0,t,e),
        i = i || {},
        this.texture = new o(void 0,void 0,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),
        this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps,
        this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006,
        this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer,
        this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer,
        this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }
    function h(t, e, i) {
        c.call(this, t, e, i),
        this.samples = 4
    }
    function l(t, e, i) {
        c.call(this, t, e, i)
    }
    function u(t, e, i, n, r, a, s, c, h, l, u, p) {
        o.call(this, null, a, s, c, h, l, n, r, u, p),
        this.image = {
            data: t,
            width: e,
            height: i
        },
        this.magFilter = void 0 !== h ? h : 1003,
        this.minFilter = void 0 !== l ? l : 1003,
        this.flipY = this.generateMipmaps = !1,
        this.unpackAlignment = 1
    }
    function p(t, e) {
        this.min = void 0 !== t ? t : new r(1 / 0,1 / 0,1 / 0),
        this.max = void 0 !== e ? e : new r(-1 / 0,-1 / 0,-1 / 0)
    }
    function d(t, e) {
        this.center = void 0 !== t ? t : new r,
        this.radius = void 0 !== e ? e : 0
    }
    function f(t, e) {
        this.normal = void 0 !== t ? t : new r(1,0,0),
        this.constant = void 0 !== e ? e : 0
    }
    function m(t, e, i, n, r, a) {
        this.planes = [void 0 !== t ? t : new f, void 0 !== e ? e : new f, void 0 !== i ? i : new f, void 0 !== n ? n : new f, void 0 !== r ? r : new f, void 0 !== a ? a : new f]
    }
    function g() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length
    }
    function v(t) {
        var e, i = {};
        for (e in t)
            for (var n in i[e] = {},
            t[e]) {
                var r = t[e][n];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? i[e][n] = r.clone() : Array.isArray(r) ? i[e][n] = r.slice() : i[e][n] = r
            }
        return i
    }
    function y(t) {
        for (var e = {}, i = 0; i < t.length; i++) {
            var n, r = v(t[i]);
            for (n in r)
                e[n] = r[n]
        }
        return e
    }
    function x(t, e, i) {
        return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
    }
    function b() {
        function t(r, a) {
            !1 !== i && (n(r, a),
            e.requestAnimationFrame(t))
        }
        var e = null
          , i = !1
          , n = null;
        return {
            start: function() {
                !0 !== i && null !== n && (e.requestAnimationFrame(t),
                i = !0)
            },
            stop: function() {
                i = !1
            },
            setAnimationLoop: function(t) {
                n = t
            },
            setContext: function(t) {
                e = t
            }
        }
    }
    function w(t) {
        var e = new WeakMap;
        return {
            get: function(t) {
                return t.isInterleavedBufferAttribute && (t = t.data),
                e.get(t)
            },
            remove: function(i) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var n = e.get(i);
                n && (t.deleteBuffer(n.buffer),
                e.delete(i))
            },
            update: function(i, n) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var r = e.get(i);
                if (void 0 === r)
                    e.set(i, function(e, i) {
                        var n = e.array
                          , r = e.dynamic ? 35048 : 35044
                          , a = t.createBuffer();
                        return t.bindBuffer(i, a),
                        t.bufferData(i, n, r),
                        e.onUploadCallback(),
                        i = 5126,
                        n instanceof Float32Array ? i = 5126 : n instanceof Float64Array || (n instanceof Uint16Array ? i = 5123 : n instanceof Int16Array ? i = 5122 : n instanceof Uint32Array ? i = 5125 : n instanceof Int32Array ? i = 5124 : n instanceof Int8Array ? i = 5120 : n instanceof Uint8Array && (i = 5121)),
                        {
                            buffer: a,
                            type: i,
                            bytesPerElement: n.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(i, n));
                else if (r.version < i.version) {
                    var a = i
                      , o = a.array
                      , s = a.updateRange;
                    t.bindBuffer(n, r.buffer),
                    !1 === a.dynamic ? t.bufferData(n, o, 35044) : -1 === s.count ? t.bufferSubData(n, 0, o) : 0 === s.count || (t.bufferSubData(n, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)),
                    s.count = -1),
                    r.version = i.version
                }
            }
        }
    }
    function M(t, e, i, n, a, o) {
        this.a = t,
        this.b = e,
        this.c = i,
        this.normal = n && n.isVector3 ? n : new r,
        this.vertexNormals = Array.isArray(n) ? n : [],
        this.color = a && a.isColor ? a : new x,
        this.vertexColors = Array.isArray(a) ? a : [],
        this.materialIndex = void 0 !== o ? o : 0
    }
    function _(t, e, i, n) {
        this._x = t || 0,
        this._y = e || 0,
        this._z = i || 0,
        this._order = n || _.DefaultOrder
    }
    function S() {
        this.mask = 1
    }
    function T() {
        Object.defineProperty(this, "id", {
            value: Qr++
        }),
        this.uuid = Vr.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = T.DefaultUp.clone();
        var t = new r
          , e = new _
          , i = new n
          , o = new r(1,1,1);
        e.onChange(function() {
            i.setFromEuler(e, !1)
        }),
        i.onChange(function() {
            e.setFromQuaternion(i, void 0, !1)
        }),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: o
            },
            modelViewMatrix: {
                value: new g
            },
            normalMatrix: {
                value: new a
            }
        }),
        this.matrix = new g,
        this.matrixWorld = new g,
        this.matrixAutoUpdate = T.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new S,
        this.visible = !0,
        this.receiveShadow = this.castShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.userData = {}
    }
    function E() {
        Object.defineProperty(this, "id", {
            value: Kr += 2
        }),
        this.uuid = Vr.generateUUID(),
        this.name = "",
        this.type = "Geometry",
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingSphere = this.boundingBox = null,
        this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
    }
    function A(t, e, i) {
        if (Array.isArray(t))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = t,
        this.itemSize = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.normalized = !0 === i,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function L(t, e, i) {
        A.call(this, new Int8Array(t), e, i)
    }
    function P(t, e, i) {
        A.call(this, new Uint8Array(t), e, i)
    }
    function C(t, e, i) {
        A.call(this, new Uint8ClampedArray(t), e, i)
    }
    function I(t, e, i) {
        A.call(this, new Int16Array(t), e, i)
    }
    function R(t, e, i) {
        A.call(this, new Uint16Array(t), e, i)
    }
    function O(t, e, i) {
        A.call(this, new Int32Array(t), e, i)
    }
    function D(t, e, i) {
        A.call(this, new Uint32Array(t), e, i)
    }
    function z(t, e, i) {
        A.call(this, new Float32Array(t), e, i)
    }
    function B(t, e, i) {
        A.call(this, new Float64Array(t), e, i)
    }
    function N() {
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingSphere = this.boundingBox = null,
        this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }
    function k(t) {
        if (0 === t.length)
            return -1 / 0;
        for (var e = t[0], i = 1, n = t.length; i < n; ++i)
            t[i] > e && (e = t[i]);
        return e
    }
    function U() {
        Object.defineProperty(this, "id", {
            value: $r += 2
        }),
        this.uuid = Vr.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingSphere = this.boundingBox = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    function F(t, e, i, n, r, a) {
        E.call(this),
        this.type = "BoxGeometry",
        this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: a
        },
        this.fromBufferGeometry(new G(t,e,i,n,r,a)),
        this.mergeVertices()
    }
    function G(t, e, i, n, a, o) {
        function s(t, e, i, n, a, o, s, m, g, v, y) {
            var x = o / g
              , b = s / v
              , w = o / 2
              , M = s / 2
              , _ = m / 2;
            s = g + 1;
            var S, T, E = v + 1, A = o = 0, L = new r;
            for (T = 0; T < E; T++) {
                var P = T * b - M;
                for (S = 0; S < s; S++)
                    L[t] = (S * x - w) * n,
                    L[e] = P * a,
                    L[i] = _,
                    l.push(L.x, L.y, L.z),
                    L[t] = 0,
                    L[e] = 0,
                    L[i] = 0 < m ? 1 : -1,
                    u.push(L.x, L.y, L.z),
                    p.push(S / g),
                    p.push(1 - T / v),
                    o += 1
            }
            for (T = 0; T < v; T++)
                for (S = 0; S < g; S++)
                    t = d + S + s * (T + 1),
                    e = d + (S + 1) + s * (T + 1),
                    i = d + (S + 1) + s * T,
                    h.push(d + S + s * T, t, i),
                    h.push(t, e, i),
                    A += 6;
            c.addGroup(f, A, y),
            f += A,
            d += o
        }
        U.call(this),
        this.type = "BoxBufferGeometry",
        this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: n,
            heightSegments: a,
            depthSegments: o
        };
        var c = this;
        t = t || 1,
        e = e || 1,
        i = i || 1,
        n = Math.floor(n) || 1,
        a = Math.floor(a) || 1;
        var h = []
          , l = []
          , u = []
          , p = []
          , d = 0
          , f = 0;
        s("z", "y", "x", -1, -1, i, e, t, o = Math.floor(o) || 1, a, 0),
        s("z", "y", "x", 1, -1, i, e, -t, o, a, 1),
        s("x", "z", "y", 1, 1, t, i, e, n, o, 2),
        s("x", "z", "y", 1, -1, t, i, -e, n, o, 3),
        s("x", "y", "z", 1, -1, t, e, i, n, a, 4),
        s("x", "y", "z", -1, -1, t, e, -i, n, a, 5),
        this.setIndex(h),
        this.addAttribute("position", new z(l,3)),
        this.addAttribute("normal", new z(u,3)),
        this.addAttribute("uv", new z(p,2))
    }
    function V(t, e, i, n) {
        E.call(this),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: n
        },
        this.fromBufferGeometry(new j(t,e,i,n)),
        this.mergeVertices()
    }
    function j(t, e, i, n) {
        U.call(this),
        this.type = "PlaneBufferGeometry",
        this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: n
        };
        var r = (t = t || 1) / 2
          , a = (e = e || 1) / 2
          , o = (i = Math.floor(i) || 1) + 1
          , s = (n = Math.floor(n) || 1) + 1
          , c = t / i
          , h = e / n
          , l = []
          , u = []
          , p = []
          , d = [];
        for (t = 0; t < s; t++) {
            var f = t * h - a;
            for (e = 0; e < o; e++)
                u.push(e * c - r, -f, 0),
                p.push(0, 0, 1),
                d.push(e / i),
                d.push(1 - t / n)
        }
        for (t = 0; t < n; t++)
            for (e = 0; e < i; e++)
                r = e + o * (t + 1),
                a = e + 1 + o * (t + 1),
                s = e + 1 + o * t,
                l.push(e + o * t, r, s),
                l.push(r, a, s);
        this.setIndex(l),
        this.addAttribute("position", new z(u,3)),
        this.addAttribute("normal", new z(p,3)),
        this.addAttribute("uv", new z(d,2))
    }
    function H() {
        Object.defineProperty(this, "id", {
            value: ta++
        }),
        this.uuid = Vr.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.lights = this.fog = !0,
        this.blending = 1,
        this.side = 0,
        this.vertexTangents = this.flatShading = !1,
        this.vertexColors = 0,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = 204,
        this.blendDst = 205,
        this.blendEquation = 100,
        this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null,
        this.depthFunc = 3,
        this.depthWrite = this.depthTest = !0,
        this.clippingPlanes = null,
        this.clipShadows = this.clipIntersection = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetUnits = this.polygonOffsetFactor = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.userData = {},
        this.needsUpdate = !0
    }
    function W(t) {
        H.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        void 0 !== t && (t.attributes,
        this.setValues(t))
    }
    function X(t, e) {
        this.origin = void 0 !== t ? t : new r,
        this.direction = void 0 !== e ? e : new r
    }
    function q(t, e, i) {
        this.a = void 0 !== t ? t : new r,
        this.b = void 0 !== e ? e : new r,
        this.c = void 0 !== i ? i : new r
    }
    function Y(t) {
        H.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new x(16777215),
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.envMap = this.alphaMap = this.specularMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.lights = this.morphTargets = this.skinning = !1,
        this.setValues(t)
    }
    function J(t, e) {
        T.call(this),
        this.type = "Mesh",
        this.geometry = void 0 !== t ? t : new U,
        this.material = void 0 !== e ? e : new Y({
            color: 16777215 * Math.random()
        }),
        this.drawMode = 0,
        this.updateMorphTargets()
    }
    function Z(t, e, i, n) {
        function r(t, i) {
            e.buffers.color.setClear(t.r, t.g, t.b, i, n)
        }
        var a, o, s = new x(0), c = 0, h = null, l = 0;
        return {
            getClearColor: function() {
                return s
            },
            setClearColor: function(t, e) {
                s.set(t),
                r(s, c = void 0 !== e ? e : 1)
            },
            getClearAlpha: function() {
                return c
            },
            setClearAlpha: function(t) {
                r(s, c = t)
            },
            render: function(e, n, u, p) {
                n = n.background,
                (u = (u = t.vr).getSession && u.getSession()) && "additive" === u.environmentBlendMode && (n = null),
                null === n ? (r(s, c),
                h = null,
                l = 0) : n && n.isColor && (r(n, 1),
                p = !0,
                h = null,
                l = 0),
                (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                n && (n.isCubeTexture || n.isWebGLRenderTargetCube) ? (void 0 === o && ((o = new J(new G(1,1,1),new W({
                    type: "BackgroundCubeMaterial",
                    uniforms: v(Zr.cube.uniforms),
                    vertexShader: Zr.cube.vertexShader,
                    fragmentShader: Zr.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"),
                o.geometry.removeAttribute("uv"),
                o.onBeforeRender = function(t, e, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld)
                }
                ,
                Object.defineProperty(o.material, "map", {
                    get: function() {
                        return this.uniforms.tCube.value
                    }
                }),
                i.update(o)),
                p = n.isWebGLRenderTargetCube ? n.texture : n,
                o.material.uniforms.tCube.value = p,
                o.material.uniforms.tFlip.value = n.isWebGLRenderTargetCube ? 1 : -1,
                h === n && l === p.version || (o.material.needsUpdate = !0,
                h = n,
                l = p.version),
                e.unshift(o, o.geometry, o.material, 0, 0, null)) : n && n.isTexture && (void 0 === a && ((a = new J(new j(2,2),new W({
                    type: "BackgroundMaterial",
                    uniforms: v(Zr.background.uniforms),
                    vertexShader: Zr.background.vertexShader,
                    fragmentShader: Zr.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"),
                Object.defineProperty(a.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }),
                i.update(a)),
                a.material.uniforms.t2D.value = n,
                !0 === n.matrixAutoUpdate && n.updateMatrix(),
                a.material.uniforms.uvTransform.value.copy(n.matrix),
                h === n && l === n.version || (a.material.needsUpdate = !0,
                h = n,
                l = n.version),
                e.unshift(a, a.geometry, a.material, 0, 0, null))
            }
        }
    }
    function Q() {
        function t() {
            l.value !== n && (l.value = n,
            l.needsUpdate = 0 < r),
            i.numPlanes = r,
            i.numIntersection = 0
        }
        function e(t, e, n, r) {
            var a = null !== t ? t.length : 0
              , o = null;
            if (0 !== a) {
                if (o = l.value,
                !0 !== r || null === o)
                    for (r = n + 4 * a,
                    e = e.matrixWorldInverse,
                    h.getNormalMatrix(e),
                    (null === o || o.length < r) && (o = new Float32Array(r)),
                    r = 0; r !== a; ++r,
                    n += 4)
                        c.copy(t[r]).applyMatrix4(e, h),
                        c.normal.toArray(o, n),
                        o[n + 3] = c.constant;
                l.value = o,
                l.needsUpdate = !0
            }
            return i.numPlanes = a,
            o
        }
        var i = this
          , n = null
          , r = 0
          , o = !1
          , s = !1
          , c = new f
          , h = new a
          , l = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = l,
        this.numIntersection = this.numPlanes = 0,
        this.init = function(t, i, a) {
            var s = 0 !== t.length || i || 0 !== r || o;
            return o = i,
            n = e(t, a, 0),
            r = t.length,
            s
        }
        ,
        this.beginShadows = function() {
            s = !0,
            e(null)
        }
        ,
        this.endShadows = function() {
            s = !1,
            t()
        }
        ,
        this.setState = function(i, a, c, h, u, p) {
            if (!o || null === i || 0 === i.length || s && !c)
                s ? e(null) : t();
            else {
                var d = 4 * (c = s ? 0 : r)
                  , f = u.clippingState || null;
                for (l.value = f,
                f = e(i, h, d, p),
                i = 0; i !== d; ++i)
                    f[i] = n[i];
                u.clippingState = f,
                this.numIntersection = a ? this.numPlanes : 0,
                this.numPlanes += c
            }
        }
    }
    function K(t, e, i) {
        function n(t) {
            var o = t.target;
            for (var s in null !== (t = r[o.id]).index && e.remove(t.index),
            t.attributes)
                e.remove(t.attributes[s]);
            o.removeEventListener("dispose", n),
            delete r[o.id],
            (s = a[t.id]) && (e.remove(s),
            delete a[t.id]),
            i.memory.geometries--
        }
        var r = {}
          , a = {};
        return {
            get: function(t, e) {
                var a = r[e.id];
                return a || (e.addEventListener("dispose", n),
                e.isBufferGeometry ? a = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new U).setFromObject(t)),
                a = e._bufferGeometry),
                r[e.id] = a,
                i.memory.geometries++,
                a)
            },
            update: function(t) {
                var i = t.index
                  , n = t.attributes;
                for (var r in null !== i && e.update(i, 34963),
                n)
                    e.update(n[r], 34962);
                for (r in t = t.morphAttributes) {
                    n = 0;
                    for (var a = (i = t[r]).length; n < a; n++)
                        e.update(i[n], 34962)
                }
            },
            getWireframeAttribute: function(t) {
                var i = a[t.id];
                if (i)
                    return i;
                i = [];
                var n = t.index
                  , r = t.attributes;
                if (null !== n) {
                    r = 0;
                    for (var o = (n = n.array).length; r < o; r += 3) {
                        var s = n[r + 0]
                          , c = n[r + 1]
                          , h = n[r + 2];
                        i.push(s, c, c, h, h, s)
                    }
                } else
                    for (n = r.position.array,
                    r = 0,
                    o = n.length / 3 - 1; r < o; r += 3)
                        s = r + 0,
                        c = r + 1,
                        h = r + 2,
                        i.push(s, c, c, h, h, s);
                return i = new (65535 < k(i) ? D : R)(i,1),
                e.update(i, 34963),
                a[t.id] = i
            }
        }
    }
    function $(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }
    function tt(t, e, i, n, r, a, s, c, h, l) {
        t = void 0 !== t ? t : [],
        o.call(this, t, void 0 !== e ? e : 301, i, n, r, a, void 0 !== s ? s : 1022, c, h, l),
        this.flipY = !1
    }
    function et(t, e, i, n) {
        o.call(this, null),
        this.image = {
            data: t,
            width: e,
            height: i,
            depth: n
        },
        this.minFilter = this.magFilter = 1003,
        this.wrapR = 1001,
        this.flipY = this.generateMipmaps = !1
    }
    function it(t, e, i, n) {
        o.call(this, null),
        this.image = {
            data: t,
            width: e,
            height: i,
            depth: n
        },
        this.minFilter = this.magFilter = 1003,
        this.wrapR = 1001,
        this.flipY = this.generateMipmaps = !1
    }
    function nt(t, e, i) {
        var n = t[0];
        if (0 >= n || 0 < n)
            return t;
        var r = e * i
          , a = aa[r];
        if (void 0 === a && (a = new Float32Array(r),
        aa[r] = a),
        0 !== e)
            for (n.toArray(a, 0),
            n = 1,
            r = 0; n !== e; ++n)
                r += i,
                t[n].toArray(a, r);
        return a
    }
    function rt(t, e) {
        if (t.length !== e.length)
            return !1;
        for (var i = 0, n = t.length; i < n; i++)
            if (t[i] !== e[i])
                return !1;
        return !0
    }
    function at(t, e) {
        for (var i = 0, n = e.length; i < n; i++)
            t[i] = e[i]
    }
    function ot(t, e) {
        var i = oa[e];
        void 0 === i && (i = new Int32Array(e),
        oa[e] = i);
        for (var n = 0; n !== e; ++n)
            i[n] = t.allocateTextureUnit();
        return i
    }
    function st(t, e) {
        var i = this.cache;
        i[0] !== e && (t.uniform1f(this.addr, e),
        i[0] = e)
    }
    function ct(t, e) {
        var i = this.cache;
        i[0] !== e && (t.uniform1i(this.addr, e),
        i[0] = e)
    }
    function ht(t, e) {
        var i = this.cache;
        void 0 !== e.x ? i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
        i[0] = e.x,
        i[1] = e.y) : rt(i, e) || (t.uniform2fv(this.addr, e),
        at(i, e))
    }
    function lt(t, e) {
        var i = this.cache;
        void 0 !== e.x ? i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
        i[0] = e.x,
        i[1] = e.y,
        i[2] = e.z) : void 0 !== e.r ? i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
        i[0] = e.r,
        i[1] = e.g,
        i[2] = e.b) : rt(i, e) || (t.uniform3fv(this.addr, e),
        at(i, e))
    }
    function ut(t, e) {
        var i = this.cache;
        void 0 !== e.x ? i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        i[0] = e.x,
        i[1] = e.y,
        i[2] = e.z,
        i[3] = e.w) : rt(i, e) || (t.uniform4fv(this.addr, e),
        at(i, e))
    }
    function pt(t, e) {
        var i = this.cache
          , n = e.elements;
        void 0 === n ? rt(i, e) || (t.uniformMatrix2fv(this.addr, !1, e),
        at(i, e)) : rt(i, n) || (ha.set(n),
        t.uniformMatrix2fv(this.addr, !1, ha),
        at(i, n))
    }
    function dt(t, e) {
        var i = this.cache
          , n = e.elements;
        void 0 === n ? rt(i, e) || (t.uniformMatrix3fv(this.addr, !1, e),
        at(i, e)) : rt(i, n) || (ca.set(n),
        t.uniformMatrix3fv(this.addr, !1, ca),
        at(i, n))
    }
    function ft(t, e) {
        var i = this.cache
          , n = e.elements;
        void 0 === n ? rt(i, e) || (t.uniformMatrix4fv(this.addr, !1, e),
        at(i, e)) : rt(i, n) || (sa.set(n),
        t.uniformMatrix4fv(this.addr, !1, sa),
        at(i, n))
    }
    function mt(t, e, i) {
        var n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r),
        n[0] = r),
        i.safeSetTexture2D(e || ea, r)
    }
    function gt(t, e, i) {
        var n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r),
        n[0] = r),
        i.setTexture2DArray(e || ia, r)
    }
    function vt(t, e, i) {
        var n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r),
        n[0] = r),
        i.setTexture3D(e || na, r)
    }
    function yt(t, e, i) {
        var n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r),
        n[0] = r),
        i.safeSetTextureCube(e || ra, r)
    }
    function xt(t, e) {
        var i = this.cache;
        rt(i, e) || (t.uniform2iv(this.addr, e),
        at(i, e))
    }
    function bt(t, e) {
        var i = this.cache;
        rt(i, e) || (t.uniform3iv(this.addr, e),
        at(i, e))
    }
    function wt(t, e) {
        var i = this.cache;
        rt(i, e) || (t.uniform4iv(this.addr, e),
        at(i, e))
    }
    function Mt(t, e) {
        var i = this.cache;
        rt(i, e) || (t.uniform1fv(this.addr, e),
        at(i, e))
    }
    function _t(t, e) {
        var i = this.cache;
        rt(i, e) || (t.uniform1iv(this.addr, e),
        at(i, e))
    }
    function St(t, e) {
        rt(this.cache, e = nt(e, this.size, 2)) || (t.uniform2fv(this.addr, e),
        this.updateCache(e))
    }
    function Tt(t, e) {
        rt(this.cache, e = nt(e, this.size, 3)) || (t.uniform3fv(this.addr, e),
        this.updateCache(e))
    }
    function Et(t, e) {
        rt(this.cache, e = nt(e, this.size, 4)) || (t.uniform4fv(this.addr, e),
        this.updateCache(e))
    }
    function At(t, e) {
        rt(this.cache, e = nt(e, this.size, 4)) || (t.uniformMatrix2fv(this.addr, !1, e),
        this.updateCache(e))
    }
    function Lt(t, e) {
        rt(this.cache, e = nt(e, this.size, 9)) || (t.uniformMatrix3fv(this.addr, !1, e),
        this.updateCache(e))
    }
    function Pt(t, e) {
        rt(this.cache, e = nt(e, this.size, 16)) || (t.uniformMatrix4fv(this.addr, !1, e),
        this.updateCache(e))
    }
    function Ct(t, e, i) {
        var n = this.cache
          , r = e.length
          , a = ot(i, r);
        for (!1 === rt(n, a) && (t.uniform1iv(this.addr, a),
        at(n, a)),
        t = 0; t !== r; ++t)
            i.safeSetTexture2D(e[t] || ea, a[t])
    }
    function It(t, e, i) {
        var n = this.cache
          , r = e.length
          , a = ot(i, r);
        for (!1 === rt(n, a) && (t.uniform1iv(this.addr, a),
        at(n, a)),
        t = 0; t !== r; ++t)
            i.safeSetTextureCube(e[t] || ra, a[t])
    }
    function Rt(t, e, i) {
        this.id = t,
        this.addr = i,
        this.cache = [],
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return st;
            case 35664:
                return ht;
            case 35665:
                return lt;
            case 35666:
                return ut;
            case 35674:
                return pt;
            case 35675:
                return dt;
            case 35676:
                return ft;
            case 35678:
            case 36198:
                return mt;
            case 35679:
                return vt;
            case 35680:
                return yt;
            case 36289:
                return gt;
            case 5124:
            case 35670:
                return ct;
            case 35667:
            case 35671:
                return xt;
            case 35668:
            case 35672:
                return bt;
            case 35669:
            case 35673:
                return wt
            }
        }(e.type)
    }
    function Ot(t, e, i) {
        this.id = t,
        this.addr = i,
        this.cache = [],
        this.size = e.size,
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return Mt;
            case 35664:
                return St;
            case 35665:
                return Tt;
            case 35666:
                return Et;
            case 35674:
                return At;
            case 35675:
                return Lt;
            case 35676:
                return Pt;
            case 35678:
                return Ct;
            case 35680:
                return It;
            case 5124:
            case 35670:
                return _t;
            case 35667:
            case 35671:
                return xt;
            case 35668:
            case 35672:
                return bt;
            case 35669:
            case 35673:
                return wt
            }
        }(e.type)
    }
    function Dt(t) {
        this.id = t,
        this.seq = [],
        this.map = {}
    }
    function zt(t, e) {
        this.seq = [],
        this.map = {};
        for (var i = t.getProgramParameter(e, 35718), n = 0; n < i; ++n) {
            var r = t.getActiveUniform(e, n)
              , a = t.getUniformLocation(e, r.name)
              , o = this
              , s = r.name
              , c = s.length;
            for (la.lastIndex = 0; ; ) {
                var h = la.exec(s)
                  , l = la.lastIndex
                  , u = h[1]
                  , p = h[3];
                if ("]" === h[2] && (u |= 0),
                void 0 === p || "[" === p && l + 2 === c) {
                    s = o,
                    r = void 0 === p ? new Rt(u,r,a) : new Ot(u,r,a),
                    s.seq.push(r),
                    s.map[r.id] = r;
                    break
                }
                void 0 === (p = o.map[u]) && (p = new Dt(u),
                u = o,
                o = p,
                u.seq.push(o),
                u.map[o.id] = o),
                o = p
            }
        }
    }
    function Bt(t, e, i) {
        var n = t.createShader(e);
        return t.shaderSource(n, i),
        t.compileShader(n),
        t.getShaderParameter(n, 35713),
        t.getShaderInfoLog(n),
        n
    }
    function Nt(t) {
        switch (t) {
        case 3e3:
            return ["Linear", "( value )"];
        case 3001:
            return ["sRGB", "( value )"];
        case 3002:
            return ["RGBE", "( value )"];
        case 3004:
            return ["RGBM", "( value, 7.0 )"];
        case 3005:
            return ["RGBM", "( value, 16.0 )"];
        case 3006:
            return ["RGBD", "( value, 256.0 )"];
        case 3007:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw Error("unsupported encoding: " + t)
        }
    }
    function kt(t, e) {
        return "vec4 " + t + "( vec4 value ) { return " + (e = Nt(e))[0] + "ToLinear" + e[1] + "; }"
    }
    function Ut(t) {
        return "" !== t
    }
    function Ft(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    }
    function Gt(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    function Vt(t) {
        return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(t, e) {
            if (void 0 === (t = Xr[e]))
                throw Error("Can not resolve #include <" + e + ">");
            return Vt(t)
        })
    }
    function jt(t) {
        return t.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, i, n) {
            for (t = "",
            e = parseInt(e); e < parseInt(i); e++)
                t += n.replace(/\[ i \]/g, "[ " + e + " ]");
            return t
        })
    }
    function Ht(t, e, i, n, r, a, o, s) {
        var c = t.context
          , h = n.defines
          , l = r.vertexShader
          , u = r.fragmentShader
          , p = "SHADOWMAP_TYPE_BASIC";
        1 === a.shadowMapType ? p = "SHADOWMAP_TYPE_PCF" : 2 === a.shadowMapType && (p = "SHADOWMAP_TYPE_PCF_SOFT");
        var d = "ENVMAP_TYPE_CUBE"
          , f = "ENVMAP_MODE_REFLECTION"
          , m = "ENVMAP_BLENDING_MULTIPLY";
        if (a.envMap) {
            switch (n.envMap.mapping) {
            case 301:
            case 302:
                d = "ENVMAP_TYPE_CUBE";
                break;
            case 306:
            case 307:
                d = "ENVMAP_TYPE_CUBE_UV";
                break;
            case 303:
            case 304:
                d = "ENVMAP_TYPE_EQUIREC";
                break;
            case 305:
                d = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
            case 302:
            case 304:
                f = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
            case 0:
                m = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case 1:
                m = "ENVMAP_BLENDING_MIX";
                break;
            case 2:
                m = "ENVMAP_BLENDING_ADD"
            }
        }
        t = 0 < t.gammaFactor ? t.gammaFactor : 1;
        var g, v, y = o.isWebGL2 ? "" : function(t, e, i) {
            return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ut).join("\n")
        }(n.extensions, a, e), x = function(t) {
            var e, i = [];
            for (e in t) {
                var n = t[e];
                !1 !== n && i.push("#define " + e + " " + n)
            }
            return i.join("\n")
        }(h), b = c.createProgram();
        return n.isRawShaderMaterial ? (0 < (h = [x].filter(Ut).join("\n")).length && (h += "\n"),
        0 < (e = [y, x].filter(Ut).join("\n")).length && (e += "\n")) : (h = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, x, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + t, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + p : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ut).join("\n"),
        e = [y, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, x, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + t, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + f : "", a.envMap ? "#define " + m : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + p : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== a.toneMapping ? "#define TONE_MAPPING" : "", 0 !== a.toneMapping ? Xr.tonemapping_pars_fragment : "", 0 !== a.toneMapping ? function(t, e) {
            switch (e) {
            case 1:
                e = "Linear";
                break;
            case 2:
                e = "Reinhard";
                break;
            case 3:
                e = "Uncharted2";
                break;
            case 4:
                e = "OptimizedCineon";
                break;
            case 5:
                e = "ACESFilmic";
                break;
            default:
                throw Error("unsupported toneMapping: " + e)
            }
            return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
        }("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? Xr.encodings_pars_fragment : "", a.mapEncoding ? kt("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? kt("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? kt("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? kt("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? function(t, e) {
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + (e = Nt(e))[0] + e[1] + "; }"
        }("linearToOutputTexel", a.outputEncoding) : "", a.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Ut).join("\n")),
        l = Gt(l = Ft(l = Vt(l), a), a),
        u = Gt(u = Ft(u = Vt(u), a), a),
        l = jt(l),
        u = jt(u),
        o.isWebGL2 && !n.isRawShaderMaterial && (o = !1,
        p = /^\s*#version\s+300\s+es\s*\n/,
        n.isShaderMaterial && null !== l.match(p) && null !== u.match(p) && (o = !0,
        l = l.replace(p, ""),
        u = u.replace(p, "")),
        h = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + h,
        e = ["#version 300 es\n\n#define varying in", o ? "" : "out highp vec4 pc_fragColor;", o ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + e),
        u = e + u,
        l = Bt(c, 35633, h + l),
        u = Bt(c, 35632, u),
        c.attachShader(b, l),
        c.attachShader(b, u),
        void 0 !== n.index0AttributeName ? c.bindAttribLocation(b, 0, n.index0AttributeName) : !0 === a.morphTargets && c.bindAttribLocation(b, 0, "position"),
        c.linkProgram(b),
        a = c.getProgramInfoLog(b).trim(),
        o = c.getShaderInfoLog(l).trim(),
        p = c.getShaderInfoLog(u).trim(),
        f = d = !0,
        !1 === c.getProgramParameter(b, 35714) ? d = !1 : "" !== a || "" !== o && "" !== p || (f = !1),
        f && (this.diagnostics = {
            runnable: d,
            material: n,
            programLog: a,
            vertexShader: {
                log: o,
                prefix: h
            },
            fragmentShader: {
                log: p,
                prefix: e
            }
        }),
        c.deleteShader(l),
        c.deleteShader(u),
        this.getUniforms = function() {
            return void 0 === g && (g = new zt(c,b,s)),
            g
        }
        ,
        this.getAttributes = function() {
            if (void 0 === v) {
                for (var t = {}, e = c.getProgramParameter(b, 35721), i = 0; i < e; i++) {
                    var n = c.getActiveAttrib(b, i).name;
                    t[n] = c.getAttribLocation(b, n)
                }
                v = t
            }
            return v
        }
        ,
        this.destroy = function() {
            c.deleteProgram(b),
            this.program = void 0
        }
        ,
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return this.getAttributes()
                }
            }
        }),
        this.name = r.name,
        this.id = ua++,
        this.code = i,
        this.usedTimes = 1,
        this.program = b,
        this.vertexShader = l,
        this.fragmentShader = u,
        this
    }
    function Wt(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }
    function Xt(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }
    function qt() {
        function t(t, n, r, o, s, c) {
            var h = e[i];
            return void 0 === h ? (h = {
                id: t.id,
                object: t,
                geometry: n,
                material: r,
                program: r.program || a,
                groupOrder: o,
                renderOrder: t.renderOrder,
                z: s,
                group: c
            },
            e[i] = h) : (h.id = t.id,
            h.object = t,
            h.geometry = n,
            h.material = r,
            h.program = r.program || a,
            h.groupOrder = o,
            h.renderOrder = t.renderOrder,
            h.z = s,
            h.group = c),
            i++,
            h
        }
        var e = []
          , i = 0
          , n = []
          , r = []
          , a = {
            id: -1
        };
        return {
            opaque: n,
            transparent: r,
            init: function() {
                i = 0,
                n.length = 0,
                r.length = 0
            },
            push: function(e, i, a, o, s, c) {
                e = t(e, i, a, o, s, c),
                (!0 === a.transparent ? r : n).push(e)
            },
            unshift: function(e, i, a, o, s, c) {
                e = t(e, i, a, o, s, c),
                (!0 === a.transparent ? r : n).unshift(e)
            },
            sort: function() {
                1 < n.length && n.sort(Wt),
                1 < r.length && r.sort(Xt)
            }
        }
    }
    function Yt() {
        var t = new function() {
            var t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    switch (e.type) {
                    case "DirectionalLight":
                        var n = {
                            direction: new r,
                            color: new x,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new r,
                            direction: new r,
                            color: new x,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new r,
                            color: new x,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new r,
                            skyColor: new x,
                            groundColor: new x
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new x,
                            position: new r,
                            halfWidth: new r,
                            halfHeight: new r
                        }
                    }
                    return t[e.id] = n
                }
            }
        }
          , e = {
            id: pa++,
            hash: {
                stateID: -1,
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                shadowsLength: -1
            },
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }
          , n = new r
          , a = new g
          , o = new g;
        return {
            setup: function(i, r, s) {
                var c = 0
                  , h = 0
                  , l = 0
                  , u = 0
                  , p = 0
                  , d = 0
                  , f = 0
                  , m = 0;
                s = s.matrixWorldInverse;
                for (var g = 0, v = i.length; g < v; g++) {
                    var y = i[g]
                      , x = y.color
                      , b = y.intensity
                      , w = y.distance
                      , M = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                    if (y.isAmbientLight)
                        c += x.r * b,
                        h += x.g * b,
                        l += x.b * b;
                    else if (y.isDirectionalLight) {
                        var _ = t.get(y);
                        _.color.copy(y.color).multiplyScalar(y.intensity),
                        _.direction.setFromMatrixPosition(y.matrixWorld),
                        n.setFromMatrixPosition(y.target.matrixWorld),
                        _.direction.sub(n),
                        _.direction.transformDirection(s),
                        (_.shadow = y.castShadow) && (x = y.shadow,
                        _.shadowBias = x.bias,
                        _.shadowRadius = x.radius,
                        _.shadowMapSize = x.mapSize),
                        e.directionalShadowMap[u] = M,
                        e.directionalShadowMatrix[u] = y.shadow.matrix,
                        e.directional[u] = _,
                        u++
                    } else
                        y.isSpotLight ? ((_ = t.get(y)).position.setFromMatrixPosition(y.matrixWorld),
                        _.position.applyMatrix4(s),
                        _.color.copy(x).multiplyScalar(b),
                        _.distance = w,
                        _.direction.setFromMatrixPosition(y.matrixWorld),
                        n.setFromMatrixPosition(y.target.matrixWorld),
                        _.direction.sub(n),
                        _.direction.transformDirection(s),
                        _.coneCos = Math.cos(y.angle),
                        _.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)),
                        _.decay = y.decay,
                        (_.shadow = y.castShadow) && (x = y.shadow,
                        _.shadowBias = x.bias,
                        _.shadowRadius = x.radius,
                        _.shadowMapSize = x.mapSize),
                        e.spotShadowMap[d] = M,
                        e.spotShadowMatrix[d] = y.shadow.matrix,
                        e.spot[d] = _,
                        d++) : y.isRectAreaLight ? ((_ = t.get(y)).color.copy(x).multiplyScalar(b),
                        _.position.setFromMatrixPosition(y.matrixWorld),
                        _.position.applyMatrix4(s),
                        o.identity(),
                        a.copy(y.matrixWorld),
                        a.premultiply(s),
                        o.extractRotation(a),
                        _.halfWidth.set(.5 * y.width, 0, 0),
                        _.halfHeight.set(0, .5 * y.height, 0),
                        _.halfWidth.applyMatrix4(o),
                        _.halfHeight.applyMatrix4(o),
                        e.rectArea[f] = _,
                        f++) : y.isPointLight ? ((_ = t.get(y)).position.setFromMatrixPosition(y.matrixWorld),
                        _.position.applyMatrix4(s),
                        _.color.copy(y.color).multiplyScalar(y.intensity),
                        _.distance = y.distance,
                        _.decay = y.decay,
                        (_.shadow = y.castShadow) && (x = y.shadow,
                        _.shadowBias = x.bias,
                        _.shadowRadius = x.radius,
                        _.shadowMapSize = x.mapSize,
                        _.shadowCameraNear = x.camera.near,
                        _.shadowCameraFar = x.camera.far),
                        e.pointShadowMap[p] = M,
                        e.pointShadowMatrix[p] = y.shadow.matrix,
                        e.point[p] = _,
                        p++) : y.isHemisphereLight && ((_ = t.get(y)).direction.setFromMatrixPosition(y.matrixWorld),
                        _.direction.transformDirection(s),
                        _.direction.normalize(),
                        _.skyColor.copy(y.color).multiplyScalar(b),
                        _.groundColor.copy(y.groundColor).multiplyScalar(b),
                        e.hemi[m] = _,
                        m++)
                }
                e.ambient[0] = c,
                e.ambient[1] = h,
                e.ambient[2] = l,
                e.directional.length = u,
                e.spot.length = d,
                e.rectArea.length = f,
                e.point.length = p,
                e.hemi.length = m,
                e.hash.stateID = e.id,
                e.hash.directionalLength = u,
                e.hash.pointLength = p,
                e.hash.spotLength = d,
                e.hash.rectAreaLength = f,
                e.hash.hemiLength = m,
                e.hash.shadowsLength = r.length
            },
            state: e
        }
    }
    function Jt() {
        var t = new Yt
          , e = []
          , i = [];
        return {
            init: function() {
                e.length = 0,
                i.length = 0
            },
            state: {
                lightsArray: e,
                shadowsArray: i,
                lights: t
            },
            setupLights: function(n) {
                t.setup(e, i, n)
            },
            pushLight: function(t) {
                e.push(t)
            },
            pushShadow: function(t) {
                i.push(t)
            }
        }
    }
    function Zt(t) {
        H.call(this),
        this.type = "MeshDepthMaterial",
        this.depthPacking = 3200,
        this.morphTargets = this.skinning = !1,
        this.displacementMap = this.alphaMap = this.map = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.lights = this.fog = !1,
        this.setValues(t)
    }
    function Qt(t) {
        H.call(this),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new r,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.morphTargets = this.skinning = !1,
        this.displacementMap = this.alphaMap = this.map = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.lights = this.fog = !1,
        this.setValues(t)
    }
    function Kt(t, e, n) {
        function a(e, i, n, r, a, o) {
            var s = e.geometry
              , c = v
              , h = e.customDepthMaterial;
            return n && (c = y,
            h = e.customDistanceMaterial),
            h ? c = h : (h = !1,
            i.morphTargets && (s && s.isBufferGeometry ? h = s.morphAttributes && s.morphAttributes.position && 0 < s.morphAttributes.position.length : s && s.isGeometry && (h = s.morphTargets && 0 < s.morphTargets.length)),
            e.isSkinnedMesh && i.skinning,
            e = e.isSkinnedMesh && i.skinning,
            s = 0,
            h && (s |= 1),
            e && (s |= 2),
            c = c[s]),
            t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (s = c.uuid,
            h = i.uuid,
            void 0 === (e = x[s]) && (e = {},
            x[s] = e),
            void 0 === (s = e[h]) && (s = c.clone(),
            e[h] = s),
            c = s),
            c.visible = i.visible,
            c.wireframe = i.wireframe,
            c.side = null != i.shadowSide ? i.shadowSide : b[i.side],
            c.clipShadows = i.clipShadows,
            c.clippingPlanes = i.clippingPlanes,
            c.clipIntersection = i.clipIntersection,
            c.wireframeLinewidth = i.wireframeLinewidth,
            c.linewidth = i.linewidth,
            n && c.isMeshDistanceMaterial && (c.referencePosition.copy(r),
            c.nearDistance = a,
            c.farDistance = o),
            c
        }
        function o(i, n, r, s) {
            if (!1 !== i.visible) {
                if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || h.intersectsObject(i))) {
                    i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
                    var c = e.update(i)
                      , l = i.material;
                    if (Array.isArray(l))
                        for (var u = c.groups, p = 0, d = u.length; p < d; p++) {
                            var m = u[p]
                              , g = l[m.materialIndex];
                            g && g.visible && (g = a(i, g, s, f, r.near, r.far),
                            t.renderBufferDirect(r, null, c, g, i, m))
                        }
                    else
                        l.visible && (g = a(i, l, s, f, r.near, r.far),
                        t.renderBufferDirect(r, null, c, g, i, null))
                }
                for (c = 0,
                l = (i = i.children).length; c < l; c++)
                    o(i[c], n, r, s)
            }
        }
        var h = new m
          , l = new g
          , u = new i
          , p = new i(n,n)
          , d = new r
          , f = new r
          , v = Array(4)
          , y = Array(4)
          , x = {}
          , b = {
            0: 1,
            1: 0,
            2: 2
        }
          , w = [new r(1,0,0), new r(-1,0,0), new r(0,0,1), new r(0,0,-1), new r(0,1,0), new r(0,-1,0)]
          , M = [new r(0,1,0), new r(0,1,0), new r(0,1,0), new r(0,1,0), new r(0,0,1), new r(0,0,-1)]
          , _ = [new s, new s, new s, new s, new s, new s];
        for (n = 0; 4 !== n; ++n) {
            var S = 0 != (1 & n)
              , T = 0 != (2 & n)
              , E = new Zt({
                depthPacking: 3201,
                morphTargets: S,
                skinning: T
            });
            v[n] = E,
            S = new Qt({
                morphTargets: S,
                skinning: T
            }),
            y[n] = S
        }
        var A = this;
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = 1,
        this.render = function(e, i, n) {
            if (!1 !== A.enabled && (!1 !== A.autoUpdate || !1 !== A.needsUpdate) && 0 !== e.length) {
                var r = t.getRenderTarget()
                  , a = t.state;
                a.setBlending(0),
                a.buffers.color.setClear(1, 1, 1, 1),
                a.buffers.depth.setTest(!0),
                a.setScissorTest(!1);
                for (var s, m = 0, g = e.length; m < g; m++) {
                    var v = e[m];
                    s = v.shadow;
                    var y = v && v.isPointLight;
                    if (void 0 === s)
                        ;
                    else {
                        var x = s.camera;
                        if (u.copy(s.mapSize),
                        u.min(p),
                        y) {
                            var b = u.x
                              , S = u.y;
                            _[0].set(2 * b, S, b, S),
                            _[1].set(0, S, b, S),
                            _[2].set(3 * b, S, b, S),
                            _[3].set(b, S, b, S),
                            _[4].set(3 * b, 0, b, S),
                            _[5].set(b, 0, b, S),
                            u.x *= 4,
                            u.y *= 2
                        }
                        for (null === s.map && (s.map = new c(u.x,u.y,{
                            minFilter: 1003,
                            magFilter: 1003,
                            format: 1023
                        }),
                        s.map.texture.name = v.name + ".shadowMap",
                        x.updateProjectionMatrix()),
                        s.isSpotLightShadow && s.update(v),
                        b = s.map,
                        S = s.matrix,
                        f.setFromMatrixPosition(v.matrixWorld),
                        x.position.copy(f),
                        y ? (s = 6,
                        S.makeTranslation(-f.x, -f.y, -f.z)) : (s = 1,
                        d.setFromMatrixPosition(v.target.matrixWorld),
                        x.lookAt(d),
                        x.updateMatrixWorld(),
                        S.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        S.multiply(x.projectionMatrix),
                        S.multiply(x.matrixWorldInverse)),
                        t.setRenderTarget(b),
                        t.clear(),
                        v = 0; v < s; v++)
                            y && (d.copy(x.position),
                            d.add(w[v]),
                            x.up.copy(M[v]),
                            x.lookAt(d),
                            x.updateMatrixWorld(),
                            a.viewport(_[v])),
                            l.multiplyMatrices(x.projectionMatrix, x.matrixWorldInverse),
                            h.setFromMatrix(l),
                            o(i, n, x, y)
                    }
                }
                A.needsUpdate = !1,
                t.setRenderTarget(r)
            }
        }
    }
    function $t(t, e, i) {
        return {
            convert: function(t) {
                if (1e3 === t)
                    return 10497;
                if (1001 === t)
                    return 33071;
                if (1002 === t)
                    return 33648;
                if (1003 === t)
                    return 9728;
                if (1004 === t)
                    return 9984;
                if (1005 === t)
                    return 9986;
                if (1006 === t)
                    return 9729;
                if (1007 === t)
                    return 9985;
                if (1008 === t)
                    return 9987;
                if (1009 === t)
                    return 5121;
                if (1017 === t)
                    return 32819;
                if (1018 === t)
                    return 32820;
                if (1019 === t)
                    return 33635;
                if (1010 === t)
                    return 5120;
                if (1011 === t)
                    return 5122;
                if (1012 === t)
                    return 5123;
                if (1013 === t)
                    return 5124;
                if (1014 === t)
                    return 5125;
                if (1015 === t)
                    return 5126;
                if (1016 === t) {
                    if (i.isWebGL2)
                        return 5131;
                    var n = e.get("OES_texture_half_float");
                    if (null !== n)
                        return n.HALF_FLOAT_OES
                }
                if (1021 === t)
                    return 6406;
                if (1022 === t)
                    return 6407;
                if (1023 === t)
                    return 6408;
                if (1024 === t)
                    return 6409;
                if (1025 === t)
                    return 6410;
                if (1026 === t)
                    return 6402;
                if (1027 === t)
                    return 34041;
                if (1028 === t)
                    return 6403;
                if (100 === t)
                    return 32774;
                if (101 === t)
                    return 32778;
                if (102 === t)
                    return 32779;
                if (200 === t)
                    return 0;
                if (201 === t)
                    return 1;
                if (202 === t)
                    return 768;
                if (203 === t)
                    return 769;
                if (204 === t)
                    return 770;
                if (205 === t)
                    return 771;
                if (206 === t)
                    return 772;
                if (207 === t)
                    return 773;
                if (208 === t)
                    return 774;
                if (209 === t)
                    return 775;
                if (210 === t)
                    return 776;
                if ((33776 === t || 33777 === t || 33778 === t || 33779 === t) && null !== (n = e.get("WEBGL_compressed_texture_s3tc"))) {
                    if (33776 === t)
                        return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === t)
                        return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === t)
                        return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === t)
                        return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((35840 === t || 35841 === t || 35842 === t || 35843 === t) && null !== (n = e.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (35840 === t)
                        return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === t)
                        return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === t)
                        return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === t)
                        return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === t && null !== (n = e.get("WEBGL_compressed_texture_etc1")))
                    return n.COMPRESSED_RGB_ETC1_WEBGL;
                if ((37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) && null !== (n = e.get("WEBGL_compressed_texture_astc")))
                    return t;
                if (103 === t || 104 === t) {
                    if (i.isWebGL2) {
                        if (103 === t)
                            return 32775;
                        if (104 === t)
                            return 32776
                    }
                    if (null !== (n = e.get("EXT_blend_minmax"))) {
                        if (103 === t)
                            return n.MIN_EXT;
                        if (104 === t)
                            return n.MAX_EXT
                    }
                }
                if (1020 === t) {
                    if (i.isWebGL2)
                        return 34042;
                    if (null !== (n = e.get("WEBGL_depth_texture")))
                        return n.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }
    function te() {
        T.call(this),
        this.type = "Group"
    }
    function ee() {
        T.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new g,
        this.projectionMatrix = new g,
        this.projectionMatrixInverse = new g
    }
    function ie(t, e, i, n) {
        ee.call(this),
        this.type = "PerspectiveCamera",
        this.fov = void 0 !== t ? t : 50,
        this.zoom = 1,
        this.near = void 0 !== i ? i : .1,
        this.far = void 0 !== n ? n : 2e3,
        this.focus = 10,
        this.aspect = void 0 !== e ? e : 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    function ne(t) {
        ie.call(this),
        this.cameras = t || []
    }
    function re(t, e, i) {
        fa.setFromMatrixPosition(e.matrixWorld),
        ma.setFromMatrixPosition(i.matrixWorld);
        var n = fa.distanceTo(ma)
          , r = e.projectionMatrix.elements
          , a = i.projectionMatrix.elements
          , o = r[14] / (r[10] - 1);
        i = r[14] / (r[10] + 1);
        var s = (r[9] + 1) / r[5]
          , c = (r[9] - 1) / r[5]
          , h = (r[8] - 1) / r[0]
          , l = (a[8] + 1) / a[0];
        r = o * h,
        a = o * l,
        h = (l = n / (-h + l)) * -h,
        e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
        t.translateX(h),
        t.translateZ(l),
        t.matrixWorld.compose(t.position, t.quaternion, t.scale),
        t.matrixWorldInverse.getInverse(t.matrixWorld),
        e = o + l,
        o = i + l,
        t.projectionMatrix.makePerspective(r - h, a + (n - h), s * i / o * e, c * i / o * e, e, o)
    }
    function ae(t) {
        function e() {
            return null !== c && !0 === c.isPresenting
        }
        function a() {
            if (e()) {
                var i = c.getEyeParameters("left")
                  , n = i.renderWidth * f;
                i = i.renderHeight * f,
                S = t.getPixelRatio(),
                t.getSize(T),
                t.setDrawingBufferSize(2 * n, i, 1),
                A.start()
            } else
                o.enabled && t.setDrawingBufferSize(T.width, T.height, S),
                A.stop()
        }
        var o = this
          , c = null
          , h = null
          , l = null
          , u = []
          , p = new g
          , d = new g
          , f = 1
          , m = "stage";
        "undefined" != typeof window && "VRFrameData"in window && (h = new window.VRFrameData,
        window.addEventListener("vrdisplaypresentchange", a, !1));
        var v = new g
          , y = new n
          , x = new r
          , w = new ie;
        w.bounds = new s(0,0,.5,1),
        w.layers.enable(1);
        var M = new ie;
        M.bounds = new s(.5,0,.5,1),
        M.layers.enable(2);
        var _ = new ne([w, M]);
        _.layers.enable(1),
        _.layers.enable(2);
        var S, T = new i, E = [];
        this.enabled = !1,
        this.getController = function(t) {
            var e = u[t];
            return void 0 === e && ((e = new te).matrixAutoUpdate = !1,
            e.visible = !1,
            u[t] = e),
            e
        }
        ,
        this.getDevice = function() {
            return c
        }
        ,
        this.setDevice = function(t) {
            void 0 !== t && (c = t),
            A.setContext(t)
        }
        ,
        this.setFramebufferScaleFactor = function(t) {
            f = t
        }
        ,
        this.setFrameOfReferenceType = function(t) {
            m = t
        }
        ,
        this.setPoseTarget = function(t) {
            void 0 !== t && (l = t)
        }
        ,
        this.getCamera = function(t) {
            var i = "stage" === m ? 1.6 : 0;
            if (!1 === e())
                return t.position.set(0, i, 0),
                t.rotation.set(0, 0, 0),
                t;
            if (c.depthNear = t.near,
            c.depthFar = t.far,
            c.getFrameData(h),
            "stage" === m) {
                var n = c.stageParameters;
                n ? p.fromArray(n.sittingToStandingTransform) : p.makeTranslation(0, i, 0)
            }
            i = h.pose,
            (n = null !== l ? l : t).matrix.copy(p),
            n.matrix.decompose(n.position, n.quaternion, n.scale),
            null !== i.orientation && (y.fromArray(i.orientation),
            n.quaternion.multiply(y)),
            null !== i.position && (y.setFromRotationMatrix(p),
            x.fromArray(i.position),
            x.applyQuaternion(y),
            n.position.add(x)),
            n.updateMatrixWorld(),
            w.near = t.near,
            M.near = t.near,
            w.far = t.far,
            M.far = t.far,
            w.matrixWorldInverse.fromArray(h.leftViewMatrix),
            M.matrixWorldInverse.fromArray(h.rightViewMatrix),
            d.getInverse(p),
            "stage" === m && (w.matrixWorldInverse.multiply(d),
            M.matrixWorldInverse.multiply(d)),
            null !== (t = n.parent) && (v.getInverse(t.matrixWorld),
            w.matrixWorldInverse.multiply(v),
            M.matrixWorldInverse.multiply(v)),
            w.matrixWorld.getInverse(w.matrixWorldInverse),
            M.matrixWorld.getInverse(M.matrixWorldInverse),
            w.projectionMatrix.fromArray(h.leftProjectionMatrix),
            M.projectionMatrix.fromArray(h.rightProjectionMatrix),
            re(_, w, M),
            (t = c.getLayers()).length && (null !== (t = t[0]).leftBounds && 4 === t.leftBounds.length && w.bounds.fromArray(t.leftBounds),
            null !== t.rightBounds && 4 === t.rightBounds.length && M.bounds.fromArray(t.rightBounds));
            t: for (t = 0; t < u.length; t++) {
                i = u[t];
                e: {
                    n = t;
                    for (var r = navigator.getGamepads && navigator.getGamepads(), a = 0, o = 0, s = r.length; a < s; a++) {
                        var f = r[a];
                        if (f && ("Daydream Controller" === f.id || "Gear VR Controller" === f.id || "Oculus Go Controller" === f.id || "OpenVR Gamepad" === f.id || f.id.startsWith("Oculus Touch") || f.id.startsWith("Spatial Controller"))) {
                            if (o === n) {
                                n = f;
                                break e
                            }
                            o++
                        }
                    }
                    n = void 0
                }
                if (void 0 !== n && void 0 !== n.pose) {
                    if (null === n.pose)
                        break t;
                    !1 === (r = n.pose).hasPosition && i.position.set(.2, -.6, -.05),
                    null !== r.position && i.position.fromArray(r.position),
                    null !== r.orientation && i.quaternion.fromArray(r.orientation),
                    i.matrix.compose(i.position, i.quaternion, i.scale),
                    i.matrix.premultiply(p),
                    i.matrix.decompose(i.position, i.quaternion, i.scale),
                    i.matrixWorldNeedsUpdate = !0,
                    i.visible = !0,
                    r = "Daydream Controller" === n.id ? 0 : 1,
                    E[t] !== n.buttons[r].pressed && (E[t] = n.buttons[r].pressed,
                    !0 === E[t] ? i.dispatchEvent({
                        type: "selectstart"
                    }) : (i.dispatchEvent({
                        type: "selectend"
                    }),
                    i.dispatchEvent({
                        type: "select"
                    })))
                } else
                    i.visible = !1
            }
            return _
        }
        ,
        this.getStandingMatrix = function() {
            return p
        }
        ,
        this.isPresenting = e;
        var A = new b;
        this.setAnimationLoop = function(t) {
            A.setAnimationLoop(t),
            e() && A.start()
        }
        ,
        this.submitFrame = function() {
            e() && c.submitFrame()
        }
        ,
        this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", a)
        }
    }
    function oe(t) {
        function e() {
            return null !== c && null !== l
        }
        function i(t) {
            var e = d[f.indexOf(t.inputSource)];
            e && e.dispatchEvent({
                type: t.type
            })
        }
        function n() {
            t.setFramebuffer(null),
            t.setRenderTarget(t.getRenderTarget()),
            w.stop()
        }
        function r(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
            t.matrixWorldInverse.getInverse(t.matrixWorld)
        }
        var a = t.context
          , o = null
          , c = null
          , h = 1
          , l = null
          , u = "stage"
          , p = null
          , d = []
          , f = []
          , m = new ie;
        m.layers.enable(1),
        m.viewport = new s;
        var v = new ie;
        v.layers.enable(2),
        v.viewport = new s;
        var y = new ne([m, v]);
        y.layers.enable(1),
        y.layers.enable(2),
        this.enabled = !1,
        this.getController = function(t) {
            var e = d[t];
            return void 0 === e && ((e = new te).matrixAutoUpdate = !1,
            e.visible = !1,
            d[t] = e),
            e
        }
        ,
        this.getDevice = function() {
            return o
        }
        ,
        this.setDevice = function(t) {
            void 0 !== t && (o = t),
            t instanceof XRDevice && a.setCompatibleXRDevice(t)
        }
        ,
        this.setFramebufferScaleFactor = function(t) {
            h = t
        }
        ,
        this.setFrameOfReferenceType = function(t) {
            u = t
        }
        ,
        this.setSession = function(e) {
            null !== (c = e) && (c.addEventListener("select", i),
            c.addEventListener("selectstart", i),
            c.addEventListener("selectend", i),
            c.addEventListener("end", n),
            c.baseLayer = new XRWebGLLayer(c,a,{
                framebufferScaleFactor: h
            }),
            c.requestFrameOfReference(u).then(function(e) {
                l = e,
                t.setFramebuffer(c.baseLayer.framebuffer),
                w.setContext(c),
                w.start()
            }),
            f = c.getInputSources(),
            c.addEventListener("inputsourceschange", function() {
                f = c.getInputSources();
                for (var t = 0; t < d.length; t++)
                    d[t].userData.inputSource = f[t]
            }))
        }
        ,
        this.getCamera = function(t) {
            if (e()) {
                var i = t.parent
                  , n = y.cameras;
                r(y, i);
                for (var a = 0; a < n.length; a++)
                    r(n[a], i);
                for (t.matrixWorld.copy(y.matrixWorld),
                a = 0,
                i = (t = t.children).length; a < i; a++)
                    t[a].updateMatrixWorld(!0);
                return re(y, m, v),
                y
            }
            return t
        }
        ,
        this.isPresenting = e;
        var x = null
          , w = new b;
        w.setAnimationLoop(function(t, e) {
            if (null !== (p = e.getDevicePose(l)))
                for (var i = c.baseLayer, n = e.views, r = 0; r < n.length; r++) {
                    var a = n[r]
                      , o = i.getViewport(a)
                      , s = p.getViewMatrix(a)
                      , h = y.cameras[r];
                    h.matrix.fromArray(s).getInverse(h.matrix),
                    h.projectionMatrix.fromArray(a.projectionMatrix),
                    h.viewport.set(o.x, o.y, o.width, o.height),
                    0 === r && y.matrix.copy(h.matrix)
                }
            for (r = 0; r < d.length; r++)
                i = d[r],
                (n = f[r]) && null !== (n = e.getInputPose(n, l)) ? ("targetRay"in n ? i.matrix.elements = n.targetRay.transformMatrix : "pointerMatrix"in n && (i.matrix.elements = n.pointerMatrix),
                i.matrix.decompose(i.position, i.rotation, i.scale),
                i.visible = !0) : i.visible = !1;
            x && x(t)
        }),
        this.setAnimationLoop = function(t) {
            x = t
        }
        ,
        this.dispose = function() {}
        ,
        this.getStandingMatrix = function() {
            return new g
        }
        ,
        this.submitFrame = function() {}
    }
    function se(t) {
        var e;
        function n() {
            D = new function(t) {
                var e = {};
                return {
                    get: function(i) {
                        if (void 0 !== e[i])
                            return e[i];
                        switch (i) {
                        case "WEBGL_depth_texture":
                            var n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            n = t.getExtension(i)
                        }
                        return e[i] = n
                    }
                }
            }
            (Et),
            (z = new function(t, e, i) {
                function n(e) {
                    if ("highp" === e) {
                        if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision)
                            return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
                }
                var r, a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext, o = void 0 !== i.precision ? i.precision : "highp", s = n(o);
                s !== o && (o = s),
                i = !0 === i.logarithmicDepthBuffer,
                s = t.getParameter(34930);
                var c = t.getParameter(35660)
                  , h = t.getParameter(3379)
                  , l = t.getParameter(34076)
                  , u = t.getParameter(34921)
                  , p = t.getParameter(36347)
                  , d = t.getParameter(36348)
                  , f = t.getParameter(36349)
                  , m = 0 < c
                  , g = a || !!e.get("OES_texture_float");
                return {
                    isWebGL2: a,
                    getMaxAnisotropy: function() {
                        if (void 0 !== r)
                            return r;
                        var i = e.get("EXT_texture_filter_anisotropic");
                        return r = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: n,
                    precision: o,
                    logarithmicDepthBuffer: i,
                    maxTextures: s,
                    maxVertexTextures: c,
                    maxTextureSize: h,
                    maxCubemapSize: l,
                    maxAttributes: u,
                    maxVertexUniforms: p,
                    maxVaryings: d,
                    maxFragmentUniforms: f,
                    vertexTextures: m,
                    floatFragmentTextures: g,
                    floatVertexTextures: m && g,
                    maxSamples: a ? t.getParameter(36183) : 0
                }
            }
            (Et,D,t)).isWebGL2 || (D.get("WEBGL_depth_texture"),
            D.get("OES_texture_float"),
            D.get("OES_texture_half_float"),
            D.get("OES_texture_half_float_linear"),
            D.get("OES_standard_derivatives"),
            D.get("OES_element_index_uint"),
            D.get("ANGLE_instanced_arrays")),
            D.get("OES_texture_float_linear"),
            tt = new $t(Et,D,z),
            (B = new function(t, e, i, n) {
                function r(e, i, n) {
                    var r = new Uint8Array(4)
                      , a = t.createTexture();
                    for (t.bindTexture(e, a),
                    t.texParameteri(e, 10241, 9728),
                    t.texParameteri(e, 10240, 9728),
                    e = 0; e < n; e++)
                        t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return a
                }
                function a(i, r) {
                    y[i] = 1,
                    0 === x[i] && (t.enableVertexAttribArray(i),
                    x[i] = 1),
                    b[i] !== r && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r),
                    b[i] = r)
                }
                function o(e) {
                    !0 !== w[e] && (t.enable(e),
                    w[e] = !0)
                }
                function c(e) {
                    !1 !== w[e] && (t.disable(e),
                    w[e] = !1)
                }
                function h(e, n, r, a, s, h, l, u) {
                    if (0 === e)
                        S && (c(3042),
                        S = !1);
                    else if (S || (o(3042),
                    S = !0),
                    5 !== e) {
                        if (e !== T || u !== R) {
                            if (100 === E && 100 === P || (t.blendEquation(32774),
                            P = E = 100),
                            u)
                                switch (e) {
                                case 1:
                                    t.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case 2:
                                    t.blendFunc(1, 1);
                                    break;
                                case 3:
                                    t.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case 4:
                                    t.blendFuncSeparate(0, 768, 0, 770)
                                }
                            else
                                switch (e) {
                                case 1:
                                    t.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case 2:
                                    t.blendFunc(770, 1);
                                    break;
                                case 3:
                                    t.blendFunc(0, 769);
                                    break;
                                case 4:
                                    t.blendFunc(0, 768)
                                }
                            I = C = L = A = null,
                            T = e,
                            R = u
                        }
                    } else
                        s = s || n,
                        h = h || r,
                        l = l || a,
                        n === E && s === P || (t.blendEquationSeparate(i.convert(n), i.convert(s)),
                        E = n,
                        P = s),
                        r === A && a === L && h === C && l === I || (t.blendFuncSeparate(i.convert(r), i.convert(a), i.convert(h), i.convert(l)),
                        A = r,
                        L = a,
                        C = h,
                        I = l),
                        T = e,
                        R = null
                }
                function l(e) {
                    O !== e && (e ? t.frontFace(2304) : t.frontFace(2305),
                    O = e)
                }
                function u(e) {
                    0 !== e ? (o(2884),
                    e !== D && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : c(2884),
                    D = e
                }
                function p(e, i, n) {
                    e ? (o(32823),
                    (B !== i || N !== n) && (t.polygonOffset(i, n),
                    B = i,
                    N = n)) : c(32823)
                }
                function d(e) {
                    void 0 === e && (e = 33984 + k - 1),
                    F !== e && (t.activeTexture(e),
                    F = e)
                }
                var f = new function() {
                    var e = !1
                      , i = new s
                      , n = null
                      , r = new s(0,0,0,0);
                    return {
                        setMask: function(i) {
                            n === i || e || (t.colorMask(i, i, i, i),
                            n = i)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, n, a, o, s) {
                            !0 === s && (e *= o,
                            n *= o,
                            a *= o),
                            i.set(e, n, a, o),
                            !1 === r.equals(i) && (t.clearColor(e, n, a, o),
                            r.copy(i))
                        },
                        reset: function() {
                            e = !1,
                            n = null,
                            r.set(-1, 0, 0, 0)
                        }
                    }
                }
                  , m = new function() {
                    var e = !1
                      , i = null
                      , n = null
                      , r = null;
                    return {
                        setTest: function(t) {
                            t ? o(2929) : c(2929)
                        },
                        setMask: function(n) {
                            i === n || e || (t.depthMask(n),
                            i = n)
                        },
                        setFunc: function(e) {
                            if (n !== e) {
                                if (e)
                                    switch (e) {
                                    case 0:
                                        t.depthFunc(512);
                                        break;
                                    case 1:
                                        t.depthFunc(519);
                                        break;
                                    case 2:
                                        t.depthFunc(513);
                                        break;
                                    case 3:
                                        t.depthFunc(515);
                                        break;
                                    case 4:
                                        t.depthFunc(514);
                                        break;
                                    case 5:
                                        t.depthFunc(518);
                                        break;
                                    case 6:
                                        t.depthFunc(516);
                                        break;
                                    case 7:
                                        t.depthFunc(517);
                                        break;
                                    default:
                                        t.depthFunc(515)
                                    }
                                else
                                    t.depthFunc(515);
                                n = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            r !== e && (t.clearDepth(e),
                            r = e)
                        },
                        reset: function() {
                            e = !1,
                            r = n = i = null
                        }
                    }
                }
                  , g = new function() {
                    var e = !1
                      , i = null
                      , n = null
                      , r = null
                      , a = null
                      , s = null
                      , h = null
                      , l = null
                      , u = null;
                    return {
                        setTest: function(t) {
                            t ? o(2960) : c(2960)
                        },
                        setMask: function(n) {
                            i === n || e || (t.stencilMask(n),
                            i = n)
                        },
                        setFunc: function(e, i, o) {
                            n === e && r === i && a === o || (t.stencilFunc(e, i, o),
                            n = e,
                            r = i,
                            a = o)
                        },
                        setOp: function(e, i, n) {
                            s === e && h === i && l === n || (t.stencilOp(e, i, n),
                            s = e,
                            h = i,
                            l = n)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            u !== e && (t.clearStencil(e),
                            u = e)
                        },
                        reset: function() {
                            e = !1,
                            u = l = h = s = a = r = n = i = null
                        }
                    }
                }
                  , v = t.getParameter(34921)
                  , y = new Uint8Array(v)
                  , x = new Uint8Array(v)
                  , b = new Uint8Array(v)
                  , w = {}
                  , M = null
                  , _ = null
                  , S = null
                  , T = null
                  , E = null
                  , A = null
                  , L = null
                  , P = null
                  , C = null
                  , I = null
                  , R = !1
                  , O = null
                  , D = null
                  , z = null
                  , B = null
                  , N = null
                  , k = t.getParameter(35661)
                  , U = !1;
                v = 0,
                -1 !== (v = t.getParameter(7938)).indexOf("WebGL") ? (v = parseFloat(/^WebGL ([0-9])/.exec(v)[1]),
                U = 1 <= v) : -1 !== v.indexOf("OpenGL ES") && (v = parseFloat(/^OpenGL ES ([0-9])/.exec(v)[1]),
                U = 2 <= v);
                var F = null
                  , G = {}
                  , V = new s
                  , j = new s
                  , H = {};
                return H[3553] = r(3553, 3553, 1),
                H[34067] = r(34067, 34069, 6),
                f.setClear(0, 0, 0, 1),
                m.setClear(1),
                g.setClear(0),
                o(2929),
                m.setFunc(3),
                l(!1),
                u(1),
                o(2884),
                h(0),
                {
                    buffers: {
                        color: f,
                        depth: m,
                        stencil: g
                    },
                    initAttributes: function() {
                        for (var t = 0, e = y.length; t < e; t++)
                            y[t] = 0
                    },
                    enableAttribute: function(t) {
                        a(t, 0)
                    },
                    enableAttributeAndDivisor: a,
                    disableUnusedAttributes: function() {
                        for (var e = 0, i = x.length; e !== i; ++e)
                            x[e] !== y[e] && (t.disableVertexAttribArray(e),
                            x[e] = 0)
                    },
                    enable: o,
                    disable: c,
                    getCompressedTextureFormats: function() {
                        if (null === M && (M = [],
                        e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                            for (var i = t.getParameter(34467), n = 0; n < i.length; n++)
                                M.push(i[n]);
                        return M
                    },
                    useProgram: function(e) {
                        return _ !== e && (t.useProgram(e),
                        _ = e,
                        !0)
                    },
                    setBlending: h,
                    setMaterial: function(t, e) {
                        2 === t.side ? c(2884) : o(2884);
                        var i = 1 === t.side;
                        e && (i = !i),
                        l(i),
                        1 === t.blending && !1 === t.transparent ? h(0) : h(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha),
                        m.setFunc(t.depthFunc),
                        m.setTest(t.depthTest),
                        m.setMask(t.depthWrite),
                        f.setMask(t.colorWrite),
                        p(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                    },
                    setFlipSided: l,
                    setCullFace: u,
                    setLineWidth: function(e) {
                        e !== z && (U && t.lineWidth(e),
                        z = e)
                    },
                    setPolygonOffset: p,
                    setScissorTest: function(t) {
                        t ? o(3089) : c(3089)
                    },
                    activeTexture: d,
                    bindTexture: function(e, i) {
                        null === F && d();
                        var n = G[F];
                        void 0 === n && (n = {
                            type: void 0,
                            texture: void 0
                        },
                        G[F] = n),
                        n.type === e && n.texture === i || (t.bindTexture(e, i || H[e]),
                        n.type = e,
                        n.texture = i)
                    },
                    compressedTexImage2D: function() {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (t) {}
                    },
                    texImage2D: function() {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (t) {}
                    },
                    texImage3D: function() {
                        try {
                            t.texImage3D.apply(t, arguments)
                        } catch (t) {}
                    },
                    scissor: function(e) {
                        !1 === V.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                        V.copy(e))
                    },
                    viewport: function(e) {
                        !1 === j.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                        j.copy(e))
                    },
                    reset: function() {
                        for (var e = 0; e < x.length; e++)
                            1 === x[e] && (t.disableVertexAttribArray(e),
                            x[e] = 0);
                        w = {},
                        F = M = null,
                        G = {},
                        D = O = T = _ = null,
                        f.reset(),
                        m.reset(),
                        g.reset()
                    }
                }
            }
            (Et,D,tt,z)).scissor(pt.copy(yt).multiplyScalar(gt)),
            B.viewport(ut.copy(vt).multiplyScalar(gt)),
            N = new function() {
                var t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.frame++,
                        t.calls = 0,
                        t.triangles = 0,
                        t.points = 0,
                        t.lines = 0
                    },
                    update: function(e, i, n) {
                        switch (n = n || 1,
                        t.calls++,
                        i) {
                        case 4:
                            t.triangles += e / 3 * n;
                            break;
                        case 5:
                        case 6:
                            t.triangles += n * (e - 2);
                            break;
                        case 1:
                            t.lines += e / 2 * n;
                            break;
                        case 3:
                            t.lines += n * (e - 1);
                            break;
                        case 2:
                            t.lines += n * e;
                            break;
                        case 0:
                            t.points += n * e
                        }
                    }
                }
            }
            (Et),
            k = new function() {
                var t = new WeakMap;
                return {
                    get: function(e) {
                        var i = t.get(e);
                        return void 0 === i && (i = {},
                        t.set(e, i)),
                        i
                    },
                    remove: function(e) {
                        t.delete(e)
                    },
                    update: function(e, i, n) {
                        t.get(e)[i] = n
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            ,
            U = new function(t, e, i, n, r, a, o) {
                function s(t, e) {
                    return A ? new OffscreenCanvas(t,e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }
                function c(t, e, i, n) {
                    var r = 1;
                    return (t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)),
                    (1 > r || !0 === e) && ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) ? (e = (n = e ? Vr.floorPowerOfTwo : Math.floor)(r * t.width),
                    r = n(r * t.height),
                    void 0 === T && (T = s(e, r)),
                    (i = i ? s(e, r) : T).width = e,
                    i.height = r,
                    i.getContext("2d").drawImage(t, 0, 0, e, r),
                    i) : t
                }
                function h(t) {
                    return Vr.isPowerOfTwo(t.width) && Vr.isPowerOfTwo(t.height)
                }
                function l(t, e) {
                    return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
                }
                function u(e, i, r, a) {
                    t.generateMipmap(e),
                    n.get(i).__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E
                }
                function p(t, i) {
                    if (!r.isWebGL2)
                        return t;
                    var n = t;
                    return 6403 === t && (5126 === i && (n = 33326),
                    5131 === i && (n = 33325),
                    5121 === i && (n = 33321)),
                    6407 === t && (5126 === i && (n = 34837),
                    5131 === i && (n = 34843),
                    5121 === i && (n = 32849)),
                    6408 === t && (5126 === i && (n = 34836),
                    5131 === i && (n = 34842),
                    5121 === i && (n = 32856)),
                    (33325 === n || 33326 === n || 34842 === n || 34836 === n) && e.get("EXT_color_buffer_float"),
                    n
                }
                function d(t) {
                    return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729
                }
                function f(e) {
                    (e = e.target).removeEventListener("dispose", f);
                    var i = n.get(e);
                    void 0 !== i.__webglInit && (t.deleteTexture(i.__webglTexture),
                    n.remove(e)),
                    e.isVideoTexture && delete E[e.id],
                    o.memory.textures--
                }
                function m(e) {
                    (e = e.target).removeEventListener("dispose", m);
                    var i = n.get(e)
                      , r = n.get(e.texture);
                    if (e) {
                        if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture),
                        e.depthTexture && e.depthTexture.dispose(),
                        e.isWebGLRenderTargetCube)
                            for (r = 0; 6 > r; r++)
                                t.deleteFramebuffer(i.__webglFramebuffer[r]),
                                i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[r]);
                        else
                            t.deleteFramebuffer(i.__webglFramebuffer),
                            i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                        n.remove(e.texture),
                        n.remove(e)
                    }
                    o.memory.textures--
                }
                function g(t, e) {
                    var r = n.get(t);
                    if (t.isVideoTexture) {
                        var a = t.id
                          , s = o.render.frame;
                        E[a] !== s && (E[a] = s,
                        t.update())
                    }
                    if (0 < t.version && r.__version !== t.version)
                        if (void 0 === (a = t.image))
                            ;
                        else if (!1 !== a.complete)
                            return void w(r, t, e);
                    i.activeTexture(33984 + e),
                    i.bindTexture(3553, r.__webglTexture)
                }
                function v(e, o) {
                    var s = n.get(e);
                    if (6 === e.image.length)
                        if (0 < e.version && s.__version !== e.version) {
                            b(s, e),
                            i.activeTexture(33984 + o),
                            i.bindTexture(34067, s.__webglTexture),
                            t.pixelStorei(37440, e.flipY),
                            o = e && e.isCompressedTexture;
                            for (var d = e.image[0] && e.image[0].isDataTexture, f = [], m = 0; 6 > m; m++)
                                f[m] = o || d ? d ? e.image[m].image : e.image[m] : c(e.image[m], !1, !0, r.maxCubemapSize);
                            var g = f[0]
                              , v = h(g) || r.isWebGL2
                              , y = a.convert(e.format)
                              , w = a.convert(e.type)
                              , M = p(y, w);
                            for (x(34067, e, v),
                            m = 0; 6 > m; m++)
                                if (o)
                                    for (var _, S = f[m].mipmaps, T = 0, E = S.length; T < E; T++)
                                        _ = S[T],
                                        1023 !== e.format && 1022 !== e.format ? -1 < i.getCompressedTextureFormats().indexOf(y) && i.compressedTexImage2D(34069 + m, T, M, _.width, _.height, 0, _.data) : i.texImage2D(34069 + m, T, M, _.width, _.height, 0, y, w, _.data);
                                else
                                    d ? i.texImage2D(34069 + m, 0, M, f[m].width, f[m].height, 0, y, w, f[m].data) : i.texImage2D(34069 + m, 0, M, y, w, f[m]);
                            s.__maxMipLevel = o ? S.length - 1 : 0,
                            l(e, v) && u(34067, e, g.width, g.height),
                            s.__version = e.version,
                            e.onUpdate && e.onUpdate(e)
                        } else
                            i.activeTexture(33984 + o),
                            i.bindTexture(34067, s.__webglTexture)
                }
                function y(t, e) {
                    i.activeTexture(33984 + e),
                    i.bindTexture(34067, n.get(t).__webglTexture)
                }
                function x(i, o, s) {
                    s ? (t.texParameteri(i, 10242, a.convert(o.wrapS)),
                    t.texParameteri(i, 10243, a.convert(o.wrapT)),
                    32879 !== i && 35866 !== i || t.texParameteri(i, 32882, a.convert(o.wrapR)),
                    t.texParameteri(i, 10240, a.convert(o.magFilter)),
                    t.texParameteri(i, 10241, a.convert(o.minFilter))) : (t.texParameteri(i, 10242, 33071),
                    t.texParameteri(i, 10243, 33071),
                    32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071),
                    1001 === o.wrapS && o.wrapT,
                    t.texParameteri(i, 10240, d(o.magFilter)),
                    t.texParameteri(i, 10241, d(o.minFilter)),
                    1003 !== o.minFilter && o.minFilter),
                    !(s = e.get("EXT_texture_filter_anisotropic")) || 1015 === o.type && null === e.get("OES_texture_float_linear") || 1016 === o.type && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear")) || !(1 < o.anisotropy || n.get(o).__currentAnisotropy) || (t.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())),
                    n.get(o).__currentAnisotropy = o.anisotropy)
                }
                function b(e, i) {
                    void 0 === e.__webglInit && (e.__webglInit = !0,
                    i.addEventListener("dispose", f),
                    e.__webglTexture = t.createTexture(),
                    o.memory.textures++)
                }
                function w(e, n, o) {
                    var s = 3553;
                    n.isDataTexture2DArray && (s = 35866),
                    n.isDataTexture3D && (s = 32879),
                    b(e, n),
                    i.activeTexture(33984 + o),
                    i.bindTexture(s, e.__webglTexture),
                    t.pixelStorei(37440, n.flipY),
                    t.pixelStorei(37441, n.premultiplyAlpha),
                    t.pixelStorei(3317, n.unpackAlignment),
                    o = (o = !r.isWebGL2 && (1001 !== n.wrapS || 1001 !== n.wrapT || 1003 !== n.minFilter && 1006 !== n.minFilter)) && !1 === h(n.image);
                    var d = h(o = c(n.image, o, !1, r.maxTextureSize)) || r.isWebGL2
                      , f = a.convert(n.format)
                      , m = a.convert(n.type)
                      , g = p(f, m);
                    x(s, n, d);
                    var v = n.mipmaps;
                    if (n.isDepthTexture) {
                        if (g = 6402,
                        1015 === n.type) {
                            if (!r.isWebGL2)
                                throw Error("Float Depth Texture only supported in WebGL2.0");
                            g = 36012
                        } else
                            r.isWebGL2 && (g = 33189);
                        1026 === n.format && 6402 === g && 1012 !== n.type && 1014 !== n.type && (n.type = 1012,
                        m = a.convert(n.type)),
                        1027 === n.format && (g = 34041,
                        1020 !== n.type && (n.type = 1020,
                        m = a.convert(n.type))),
                        i.texImage2D(3553, 0, g, o.width, o.height, 0, f, m, null)
                    } else if (n.isDataTexture)
                        if (0 < v.length && d) {
                            for (var y = 0, w = v.length; y < w; y++)
                                s = v[y],
                                i.texImage2D(3553, y, g, s.width, s.height, 0, f, m, s.data);
                            n.generateMipmaps = !1,
                            e.__maxMipLevel = v.length - 1
                        } else
                            i.texImage2D(3553, 0, g, o.width, o.height, 0, f, m, o.data),
                            e.__maxMipLevel = 0;
                    else if (n.isCompressedTexture) {
                        for (y = 0,
                        w = v.length; y < w; y++)
                            s = v[y],
                            1023 !== n.format && 1022 !== n.format ? -1 < i.getCompressedTextureFormats().indexOf(f) && i.compressedTexImage2D(3553, y, g, s.width, s.height, 0, s.data) : i.texImage2D(3553, y, g, s.width, s.height, 0, f, m, s.data);
                        e.__maxMipLevel = v.length - 1
                    } else if (n.isDataTexture2DArray)
                        i.texImage3D(35866, 0, g, o.width, o.height, o.depth, 0, f, m, o.data),
                        e.__maxMipLevel = 0;
                    else if (n.isDataTexture3D)
                        i.texImage3D(32879, 0, g, o.width, o.height, o.depth, 0, f, m, o.data),
                        e.__maxMipLevel = 0;
                    else if (0 < v.length && d) {
                        for (y = 0,
                        w = v.length; y < w; y++)
                            s = v[y],
                            i.texImage2D(3553, y, g, f, m, s);
                        n.generateMipmaps = !1,
                        e.__maxMipLevel = v.length - 1
                    } else
                        i.texImage2D(3553, 0, g, f, m, o),
                        e.__maxMipLevel = 0;
                    l(n, d) && u(3553, n, o.width, o.height),
                    e.__version = n.version,
                    n.onUpdate && n.onUpdate(n)
                }
                function M(e, r, o, s) {
                    var c = a.convert(r.texture.format)
                      , h = a.convert(r.texture.type)
                      , l = p(c, h);
                    i.texImage2D(s, 0, l, r.width, r.height, 0, c, h, null),
                    t.bindFramebuffer(36160, e),
                    t.framebufferTexture2D(36160, o, s, n.get(r.texture).__webglTexture, 0),
                    t.bindFramebuffer(36160, null)
                }
                function _(e, i, n) {
                    t.bindRenderbuffer(36161, e),
                    i.depthBuffer && !i.stencilBuffer ? (n ? (n = S(i),
                    t.renderbufferStorageMultisample(36161, n, 33189, i.width, i.height)) : t.renderbufferStorage(36161, 33189, i.width, i.height),
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)) : i.depthBuffer && i.stencilBuffer ? (n ? (n = S(i),
                    t.renderbufferStorageMultisample(36161, n, 34041, i.width, i.height)) : t.renderbufferStorage(36161, 34041, i.width, i.height),
                    t.framebufferRenderbuffer(36160, 33306, 36161, e)) : (e = p(e = a.convert(i.texture.format), a.convert(i.texture.type)),
                    n ? (n = S(i),
                    t.renderbufferStorageMultisample(36161, n, e, i.width, i.height)) : t.renderbufferStorage(36161, e, i.width, i.height)),
                    t.bindRenderbuffer(36161, null)
                }
                function S(t) {
                    return r.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, t.samples) : 0
                }
                var T, E = {}, A = "undefined" != typeof OffscreenCanvas, L = 0, P = !1, C = !1;
                this.allocateTextureUnit = function() {
                    var t = L;
                    return r.maxTextures,
                    L += 1,
                    t
                }
                ,
                this.resetTextureUnits = function() {
                    L = 0
                }
                ,
                this.setTexture2D = g,
                this.setTexture2DArray = function(t, e) {
                    var r = n.get(t);
                    0 < t.version && r.__version !== t.version ? w(r, t, e) : (i.activeTexture(33984 + e),
                    i.bindTexture(35866, r.__webglTexture))
                }
                ,
                this.setTexture3D = function(t, e) {
                    var r = n.get(t);
                    0 < t.version && r.__version !== t.version ? w(r, t, e) : (i.activeTexture(33984 + e),
                    i.bindTexture(32879, r.__webglTexture))
                }
                ,
                this.setTextureCube = v,
                this.setTextureCubeDynamic = y,
                this.setupRenderTarget = function(e) {
                    var s = n.get(e)
                      , c = n.get(e.texture);
                    e.addEventListener("dispose", m),
                    c.__webglTexture = t.createTexture(),
                    o.memory.textures++;
                    var d = !0 === e.isWebGLRenderTargetCube
                      , f = !0 === e.isWebGLMultisampleRenderTarget
                      , v = h(e) || r.isWebGL2;
                    if (d)
                        for (s.__webglFramebuffer = [],
                        f = 0; 6 > f; f++)
                            s.__webglFramebuffer[f] = t.createFramebuffer();
                    else if (s.__webglFramebuffer = t.createFramebuffer(),
                    f && r.isWebGL2) {
                        s.__webglMultisampledFramebuffer = t.createFramebuffer(),
                        s.__webglColorRenderbuffer = t.createRenderbuffer(),
                        t.bindRenderbuffer(36161, s.__webglColorRenderbuffer),
                        f = a.convert(e.texture.format);
                        var y = a.convert(e.texture.type);
                        f = p(f, y),
                        y = S(e),
                        t.renderbufferStorageMultisample(36161, y, f, e.width, e.height),
                        t.bindFramebuffer(36160, s.__webglMultisampledFramebuffer),
                        t.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer),
                        t.bindRenderbuffer(36161, null),
                        e.depthBuffer && (s.__webglDepthRenderbuffer = t.createRenderbuffer(),
                        _(s.__webglDepthRenderbuffer, e, !0)),
                        t.bindFramebuffer(36160, null)
                    }
                    if (d) {
                        for (i.bindTexture(34067, c.__webglTexture),
                        x(34067, e.texture, v),
                        f = 0; 6 > f; f++)
                            M(s.__webglFramebuffer[f], e, 36064, 34069 + f);
                        l(e.texture, v) && u(34067, e.texture, e.width, e.height),
                        i.bindTexture(34067, null)
                    } else
                        i.bindTexture(3553, c.__webglTexture),
                        x(3553, e.texture, v),
                        M(s.__webglFramebuffer, e, 36064, 3553),
                        l(e.texture, v) && u(3553, e.texture, e.width, e.height),
                        i.bindTexture(3553, null);
                    if (e.depthBuffer) {
                        if (s = n.get(e),
                        c = !0 === e.isWebGLRenderTargetCube,
                        e.depthTexture) {
                            if (c)
                                throw Error("target.depthTexture not supported in Cube render targets");
                            if (e && e.isWebGLRenderTargetCube)
                                throw Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(36160, s.__webglFramebuffer),
                            !e.depthTexture || !e.depthTexture.isDepthTexture)
                                throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            if (n.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width,
                            e.depthTexture.image.height = e.height,
                            e.depthTexture.needsUpdate = !0),
                            g(e.depthTexture, 0),
                            s = n.get(e.depthTexture).__webglTexture,
                            1026 === e.depthTexture.format)
                                t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                            else {
                                if (1027 !== e.depthTexture.format)
                                    throw Error("Unknown depthTexture format");
                                t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                            }
                        } else if (c)
                            for (s.__webglDepthbuffer = [],
                            c = 0; 6 > c; c++)
                                t.bindFramebuffer(36160, s.__webglFramebuffer[c]),
                                s.__webglDepthbuffer[c] = t.createRenderbuffer(),
                                _(s.__webglDepthbuffer[c], e);
                        else
                            t.bindFramebuffer(36160, s.__webglFramebuffer),
                            s.__webglDepthbuffer = t.createRenderbuffer(),
                            _(s.__webglDepthbuffer, e);
                        t.bindFramebuffer(36160, null)
                    }
                }
                ,
                this.updateRenderTargetMipmap = function(t) {
                    var e = t.texture
                      , a = h(t) || r.isWebGL2;
                    if (l(e, a)) {
                        a = t.isWebGLRenderTargetCube ? 34067 : 3553;
                        var o = n.get(e).__webglTexture;
                        i.bindTexture(a, o),
                        u(a, e, t.width, t.height),
                        i.bindTexture(a, null)
                    }
                }
                ,
                this.updateMultisampleRenderTarget = function(e) {
                    if (e.isWebGLMultisampleRenderTarget && r.isWebGL2) {
                        var i = n.get(e);
                        t.bindFramebuffer(36008, i.__webglMultisampledFramebuffer),
                        t.bindFramebuffer(36009, i.__webglFramebuffer),
                        i = e.width;
                        var a = e.height
                          , o = 16384;
                        e.depthBuffer && (o |= 256),
                        e.stencilBuffer && (o |= 1024),
                        t.blitFramebuffer(0, 0, i, a, 0, 0, i, a, o, 9728)
                    }
                }
                ,
                this.safeSetTexture2D = function(t, e) {
                    t && t.isWebGLRenderTarget && (!1 === P && (P = !0),
                    t = t.texture),
                    g(t, e)
                }
                ,
                this.safeSetTextureCube = function(t, e) {
                    t && t.isWebGLRenderTargetCube && (!1 === C && (C = !0),
                    t = t.texture),
                    t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? v(t, e) : y(t, e)
                }
            }
            (Et,D,B,k,z,tt,N),
            F = new w(Et),
            G = new K(Et,F,N),
            V = new function(t, e) {
                var i = {};
                return {
                    update: function(n) {
                        var r = e.render.frame
                          , a = n.geometry
                          , o = t.get(n, a);
                        return i[o.id] !== r && (a.isGeometry && o.updateFromObject(n),
                        t.update(o),
                        i[o.id] = r),
                        o
                    },
                    dispose: function() {
                        i = {}
                    }
                }
            }
            (G,N),
            q = new function(t) {
                var e = {}
                  , i = new Float32Array(8);
                return {
                    update: function(n, r, a, o) {
                        var s = n.morphTargetInfluences
                          , c = s.length;
                        if (void 0 === (n = e[r.id])) {
                            n = [];
                            for (var h = 0; h < c; h++)
                                n[h] = [h, 0];
                            e[r.id] = n
                        }
                        var l = a.morphTargets && r.morphAttributes.position;
                        for (a = a.morphNormals && r.morphAttributes.normal,
                        h = 0; h < c; h++) {
                            var u = n[h];
                            0 !== u[1] && (l && r.removeAttribute("morphTarget" + h),
                            a && r.removeAttribute("morphNormal" + h))
                        }
                        for (h = 0; h < c; h++)
                            (u = n[h])[0] = h,
                            u[1] = s[h];
                        for (n.sort($),
                        h = 0; 8 > h; h++)
                            (u = n[h]) && (s = u[0],
                            c = u[1]) ? (l && r.addAttribute("morphTarget" + h, l[s]),
                            a && r.addAttribute("morphNormal" + h, a[s]),
                            i[h] = c) : i[h] = 0;
                        o.getUniforms().setValue(t, "morphTargetInfluences", i)
                    }
                }
            }
            (Et),
            j = new function(t, e, i, n) {
                function r(t, e) {
                    if (t)
                        t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (i = t.texture.encoding);
                    else
                        var i = 3e3;
                    return 3e3 === i && e && (i = 3007),
                    i
                }
                var a = []
                  , o = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                }
                  , s = "precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
                this.getParameters = function(e, n, a, s, c, h, l) {
                    var u = o[e.type];
                    if (l.isSkinnedMesh) {
                        var p = l.skeleton.bones;
                        if (i.floatVertexTextures)
                            p = 1024;
                        else {
                            var d = Math.min(Math.floor((i.maxVertexUniforms - 20) / 4), p.length);
                            p = d < p.length ? 0 : d
                        }
                    } else
                        p = 0;
                    d = i.precision,
                    null !== e.precision && (d = i.getMaxPrecision(e.precision),
                    e.precision);
                    var f = t.getRenderTarget();
                    return {
                        shaderID: u,
                        precision: d,
                        supportsVertexTextures: i.vertexTextures,
                        outputEncoding: r(f ? f.texture : null, t.gammaOutput),
                        map: !!e.map,
                        mapEncoding: r(e.map, t.gammaInput),
                        matcap: !!e.matcap,
                        matcapEncoding: r(e.matcap, t.gammaInput),
                        envMap: !!e.envMap,
                        envMapMode: e.envMap && e.envMap.mapping,
                        envMapEncoding: r(e.envMap, t.gammaInput),
                        envMapCubeUV: !!e.envMap && (306 === e.envMap.mapping || 307 === e.envMap.mapping),
                        lightMap: !!e.lightMap,
                        aoMap: !!e.aoMap,
                        emissiveMap: !!e.emissiveMap,
                        emissiveMapEncoding: r(e.emissiveMap, t.gammaInput),
                        bumpMap: !!e.bumpMap,
                        normalMap: !!e.normalMap,
                        objectSpaceNormalMap: 1 === e.normalMapType,
                        displacementMap: !!e.displacementMap,
                        roughnessMap: !!e.roughnessMap,
                        metalnessMap: !!e.metalnessMap,
                        specularMap: !!e.specularMap,
                        alphaMap: !!e.alphaMap,
                        gradientMap: !!e.gradientMap,
                        combine: e.combine,
                        vertexTangents: e.normalMap && e.vertexTangents,
                        vertexColors: e.vertexColors,
                        fog: !!s,
                        useFog: e.fog,
                        fogExp: s && s.isFogExp2,
                        flatShading: e.flatShading,
                        sizeAttenuation: e.sizeAttenuation,
                        logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                        skinning: e.skinning && 0 < p,
                        maxBones: p,
                        useVertexTexture: i.floatVertexTextures,
                        morphTargets: e.morphTargets,
                        morphNormals: e.morphNormals,
                        maxMorphTargets: t.maxMorphTargets,
                        maxMorphNormals: t.maxMorphNormals,
                        numDirLights: n.directional.length,
                        numPointLights: n.point.length,
                        numSpotLights: n.spot.length,
                        numRectAreaLights: n.rectArea.length,
                        numHemiLights: n.hemi.length,
                        numClippingPlanes: c,
                        numClipIntersection: h,
                        dithering: e.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && l.receiveShadow && 0 < a.length,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: t.toneMapping,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: e.premultipliedAlpha,
                        alphaTest: e.alphaTest,
                        doubleSided: 2 === e.side,
                        flipSided: 1 === e.side,
                        depthPacking: void 0 !== e.depthPacking && e.depthPacking
                    }
                }
                ,
                this.getProgramCode = function(e, i) {
                    var n = [];
                    if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader),
                    n.push(e.vertexShader)),
                    void 0 !== e.defines)
                        for (var r in e.defines)
                            n.push(r),
                            n.push(e.defines[r]);
                    for (r = 0; r < s.length; r++)
                        n.push(i[s[r]]);
                    return n.push(e.onBeforeCompile.toString()),
                    n.push(t.gammaOutput),
                    n.push(t.gammaFactor),
                    n.join()
                }
                ,
                this.acquireProgram = function(r, o, s, c) {
                    for (var h, l = 0, u = a.length; l < u; l++) {
                        var p = a[l];
                        if (p.code === c) {
                            ++(h = p).usedTimes;
                            break
                        }
                    }
                    return void 0 === h && (h = new Ht(t,e,c,r,o,s,i,n),
                    a.push(h)),
                    h
                }
                ,
                this.releaseProgram = function(t) {
                    if (0 == --t.usedTimes) {
                        var e = a.indexOf(t);
                        a[e] = a[a.length - 1],
                        a.pop(),
                        t.destroy()
                    }
                }
                ,
                this.programs = a
            }
            (et,D,z,U),
            H = new function() {
                function t(i) {
                    (i = i.target).removeEventListener("dispose", t),
                    delete e[i.id]
                }
                var e = {};
                return {
                    get: function(i, n) {
                        var r = e[i.id];
                        if (void 0 === r) {
                            var a = new qt;
                            e[i.id] = {},
                            e[i.id][n.id] = a,
                            i.addEventListener("dispose", t)
                        } else
                            void 0 === (a = r[n.id]) && (a = new qt,
                            r[n.id] = a);
                        return a
                    },
                    dispose: function() {
                        e = {}
                    }
                }
            }
            ,
            W = new function() {
                function t(i) {
                    (i = i.target).removeEventListener("dispose", t),
                    delete e[i.id]
                }
                var e = {};
                return {
                    get: function(i, n) {
                        if (void 0 === e[i.id]) {
                            var r = new Jt;
                            e[i.id] = {},
                            e[i.id][n.id] = r,
                            i.addEventListener("dispose", t)
                        } else
                            void 0 === e[i.id][n.id] ? (r = new Jt,
                            e[i.id][n.id] = r) : r = e[i.id][n.id];
                        return r
                    },
                    dispose: function() {
                        e = {}
                    }
                }
            }
            ,
            X = new Z(et,B,V,P),
            Y = new function(t, e, i, n) {
                var r;
                this.setMode = function(t) {
                    r = t
                }
                ,
                this.render = function(e, n) {
                    t.drawArrays(r, e, n),
                    i.update(n, r)
                }
                ,
                this.renderInstances = function(a, o, s) {
                    if (n.isWebGL2)
                        var c = t;
                    else if (null === (c = e.get("ANGLE_instanced_arrays")))
                        return;
                    c[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, o, s, a.maxInstancedCount),
                    i.update(s, r, a.maxInstancedCount)
                }
            }
            (Et,D,N,z),
            J = new function(t, e, i, n) {
                var r, a, o;
                this.setMode = function(t) {
                    r = t
                }
                ,
                this.setIndex = function(t) {
                    a = t.type,
                    o = t.bytesPerElement
                }
                ,
                this.render = function(e, n) {
                    t.drawElements(r, n, a, e * o),
                    i.update(n, r)
                }
                ,
                this.renderInstances = function(s, c, h) {
                    if (n.isWebGL2)
                        var l = t;
                    else if (null === (l = e.get("ANGLE_instanced_arrays")))
                        return;
                    l[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, h, a, c * o, s.maxInstancedCount),
                    i.update(h, r, s.maxInstancedCount)
                }
            }
            (Et,D,N,z),
            N.programs = j.programs,
            et.context = Et,
            et.capabilities = z,
            et.extensions = D,
            et.properties = k,
            et.renderLists = H,
            et.state = B,
            et.info = N
        }
        function a(t) {
            t.preventDefault(),
            it = !0
        }
        function o() {
            it = !1,
            n()
        }
        function c(t) {
            (t = t.target).removeEventListener("dispose", c),
            h(t),
            k.remove(t)
        }
        function h(t) {
            var e = k.get(t).program;
            t.program = void 0,
            void 0 !== e && j.releaseProgram(e)
        }
        function l(t, e, i, n) {
            for (var r = 0, a = t.length; r < a; r++) {
                var o = t[r]
                  , s = o.object
                  , c = o.geometry
                  , h = void 0 === n ? o.material : n;
                if (o = o.group,
                i.isArrayCamera) {
                    lt = i;
                    for (var l = i.cameras, u = 0, d = l.length; u < d; u++) {
                        var f = l[u];
                        if (s.layers.test(f.layers)) {
                            if ("viewport"in f)
                                B.viewport(ut.copy(f.viewport));
                            else {
                                var m = f.bounds;
                                B.viewport(ut.set(m.x * ft, m.y * mt, m.z * ft, m.w * mt).multiplyScalar(gt))
                            }
                            O.setupLights(f),
                            p(s, e, f, c, h, o)
                        }
                    }
                } else
                    lt = null,
                    p(s, e, i, c, h, o)
            }
        }
        function p(t, i, n, r, a, o) {
            if (t.onBeforeRender(et, i, n, r, a, o),
            O = W.get(i, lt || n),
            t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            t.isImmediateRenderObject) {
                B.setMaterial(a);
                var s = f(n, i.fog, a, t);
                st = e = null,
                ct = !1,
                function(t, e) {
                    t.render(function(t) {
                        et.renderBufferImmediate(t, e)
                    })
                }(t, s)
            } else
                et.renderBufferDirect(n, i.fog, r, a, t, o);
            t.onAfterRender(et, i, n, r, a, o),
            O = W.get(i, lt || n)
        }
        function d(t, e, i) {
            var n = k.get(t)
              , r = O.state.lights
              , a = n.lightsHash
              , o = r.state.hash;
            i = j.getParameters(t, r.state, O.state.shadowsArray, e, wt.numPlanes, wt.numIntersection, i);
            var s = j.getProgramCode(t, i)
              , l = n.program
              , u = !0;
            if (void 0 === l)
                t.addEventListener("dispose", c);
            else if (l.code !== s)
                h(t);
            else {
                if (a.stateID !== o.stateID || a.directionalLength !== o.directionalLength || a.pointLength !== o.pointLength || a.spotLength !== o.spotLength || a.rectAreaLength !== o.rectAreaLength || a.hemiLength !== o.hemiLength || a.shadowsLength !== o.shadowsLength)
                    a.stateID = o.stateID,
                    a.directionalLength = o.directionalLength,
                    a.pointLength = o.pointLength,
                    a.spotLength = o.spotLength,
                    a.rectAreaLength = o.rectAreaLength,
                    a.hemiLength = o.hemiLength,
                    a.shadowsLength = o.shadowsLength;
                else if (void 0 !== i.shaderID)
                    return;
                u = !1
            }
            if (u && (i.shaderID ? (s = Zr[i.shaderID],
            n.shader = {
                name: t.type,
                uniforms: v(s.uniforms),
                vertexShader: s.vertexShader,
                fragmentShader: s.fragmentShader
            }) : n.shader = {
                name: t.type,
                uniforms: t.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader
            },
            t.onBeforeCompile(n.shader, et),
            s = j.getProgramCode(t, i),
            l = j.acquireProgram(t, n.shader, i, s),
            n.program = l,
            t.program = l),
            i = l.getAttributes(),
            t.morphTargets)
                for (s = t.numSupportedMorphTargets = 0; s < et.maxMorphTargets; s++)
                    0 <= i["morphTarget" + s] && t.numSupportedMorphTargets++;
            if (t.morphNormals)
                for (s = t.numSupportedMorphNormals = 0; s < et.maxMorphNormals; s++)
                    0 <= i["morphNormal" + s] && t.numSupportedMorphNormals++;
            i = n.shader.uniforms,
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = wt.numPlanes,
            n.numIntersection = wt.numIntersection,
            i.clippingPlanes = wt.uniform),
            n.fog = e,
            void 0 === a && (n.lightsHash = a = {}),
            a.stateID = o.stateID,
            a.directionalLength = o.directionalLength,
            a.pointLength = o.pointLength,
            a.spotLength = o.spotLength,
            a.rectAreaLength = o.rectAreaLength,
            a.hemiLength = o.hemiLength,
            a.shadowsLength = o.shadowsLength,
            t.lights && (i.ambientLightColor.value = r.state.ambient,
            i.directionalLights.value = r.state.directional,
            i.spotLights.value = r.state.spot,
            i.rectAreaLights.value = r.state.rectArea,
            i.pointLights.value = r.state.point,
            i.hemisphereLights.value = r.state.hemi,
            i.directionalShadowMap.value = r.state.directionalShadowMap,
            i.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
            i.spotShadowMap.value = r.state.spotShadowMap,
            i.spotShadowMatrix.value = r.state.spotShadowMatrix,
            i.pointShadowMap.value = r.state.pointShadowMap,
            i.pointShadowMatrix.value = r.state.pointShadowMatrix),
            t = n.program.getUniforms(),
            t = zt.seqWithValue(t.seq, i),
            n.uniformsList = t
        }
        function f(t, e, i, n) {
            U.resetTextureUnits();
            var r = k.get(i)
              , a = r.lightsHash
              , o = O.state.lights.state.hash;
            Mt && (_t || t !== ht) && wt.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, t === ht && i.id === ot),
            !1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i.needsUpdate = !0 : (!i.lights || a.stateID === o.stateID && a.directionalLength === o.directionalLength && a.pointLength === o.pointLength && a.spotLength === o.spotLength && a.rectAreaLength === o.rectAreaLength && a.hemiLength === o.hemiLength && a.shadowsLength === o.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === wt.numPlanes && r.numIntersection === wt.numIntersection) || (i.needsUpdate = !0)),
            i.needsUpdate && (d(i, e, n),
            i.needsUpdate = !1);
            var s = !1
              , c = !1
              , h = !1;
            o = (a = r.program).getUniforms();
            var l = r.shader.uniforms;
            if (B.useProgram(a.program) && (h = c = s = !0),
            i.id !== ot && (ot = i.id,
            c = !0),
            (s || ht !== t) && (o.setValue(Et, "projectionMatrix", t.projectionMatrix),
            z.logarithmicDepthBuffer && o.setValue(Et, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
            ht !== t && (ht = t,
            h = c = !0),
            (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && (void 0 !== (s = o.map.cameraPosition) && s.setValue(Et, Tt.setFromMatrixPosition(t.matrixWorld))),
            (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && o.setValue(Et, "viewMatrix", t.matrixWorldInverse)),
            i.skinning && (o.setOptional(Et, n, "bindMatrix"),
            o.setOptional(Et, n, "bindMatrixInverse"),
            t = n.skeleton))
                if (s = t.bones,
                z.floatVertexTextures) {
                    if (void 0 === t.boneTexture) {
                        s = Math.sqrt(4 * s.length),
                        s = Vr.ceilPowerOfTwo(s),
                        s = Math.max(s, 4);
                        var p = new Float32Array(s * s * 4);
                        p.set(t.boneMatrices);
                        var f = new u(p,s,s,1023,1015);
                        f.needsUpdate = !0,
                        t.boneMatrices = p,
                        t.boneTexture = f,
                        t.boneTextureSize = s
                    }
                    o.setValue(Et, "boneTexture", t.boneTexture, U),
                    o.setValue(Et, "boneTextureSize", t.boneTextureSize)
                } else
                    o.setOptional(Et, t, "boneMatrices");
            return c && (o.setValue(Et, "toneMappingExposure", et.toneMappingExposure),
            o.setValue(Et, "toneMappingWhitePoint", et.toneMappingWhitePoint),
            i.lights && (c = h,
            l.ambientLightColor.needsUpdate = c,
            l.directionalLights.needsUpdate = c,
            l.pointLights.needsUpdate = c,
            l.spotLights.needsUpdate = c,
            l.rectAreaLights.needsUpdate = c,
            l.hemisphereLights.needsUpdate = c),
            e && i.fog && (l.fogColor.value = e.color,
            e.isFog ? (l.fogNear.value = e.near,
            l.fogFar.value = e.far) : e.isFogExp2 && (l.fogDensity.value = e.density)),
            i.isMeshBasicMaterial ? y(l, i) : i.isMeshLambertMaterial ? (y(l, i),
            i.emissiveMap && (l.emissiveMap.value = i.emissiveMap)) : i.isMeshPhongMaterial ? (y(l, i),
            i.isMeshToonMaterial ? (x(l, i),
            i.gradientMap && (l.gradientMap.value = i.gradientMap)) : x(l, i)) : i.isMeshStandardMaterial ? (y(l, i),
            i.isMeshPhysicalMaterial ? (M(l, i),
            l.reflectivity.value = i.reflectivity,
            l.clearCoat.value = i.clearCoat,
            l.clearCoatRoughness.value = i.clearCoatRoughness) : M(l, i)) : i.isMeshMatcapMaterial ? (y(l, i),
            i.matcap && (l.matcap.value = i.matcap),
            i.bumpMap && (l.bumpMap.value = i.bumpMap,
            l.bumpScale.value = i.bumpScale,
            1 === i.side && (l.bumpScale.value *= -1)),
            i.normalMap && (l.normalMap.value = i.normalMap,
            l.normalScale.value.copy(i.normalScale),
            1 === i.side && l.normalScale.value.negate()),
            i.displacementMap && (l.displacementMap.value = i.displacementMap,
            l.displacementScale.value = i.displacementScale,
            l.displacementBias.value = i.displacementBias)) : i.isMeshDepthMaterial ? (y(l, i),
            i.displacementMap && (l.displacementMap.value = i.displacementMap,
            l.displacementScale.value = i.displacementScale,
            l.displacementBias.value = i.displacementBias)) : i.isMeshDistanceMaterial ? (y(l, i),
            i.displacementMap && (l.displacementMap.value = i.displacementMap,
            l.displacementScale.value = i.displacementScale,
            l.displacementBias.value = i.displacementBias),
            l.referencePosition.value.copy(i.referencePosition),
            l.nearDistance.value = i.nearDistance,
            l.farDistance.value = i.farDistance) : i.isMeshNormalMaterial ? (y(l, i),
            i.bumpMap && (l.bumpMap.value = i.bumpMap,
            l.bumpScale.value = i.bumpScale,
            1 === i.side && (l.bumpScale.value *= -1)),
            i.normalMap && (l.normalMap.value = i.normalMap,
            l.normalScale.value.copy(i.normalScale),
            1 === i.side && l.normalScale.value.negate()),
            i.displacementMap && (l.displacementMap.value = i.displacementMap,
            l.displacementScale.value = i.displacementScale,
            l.displacementBias.value = i.displacementBias)) : i.isLineBasicMaterial ? (l.diffuse.value = i.color,
            l.opacity.value = i.opacity,
            i.isLineDashedMaterial && (l.dashSize.value = i.dashSize,
            l.totalSize.value = i.dashSize + i.gapSize,
            l.scale.value = i.scale)) : i.isPointsMaterial ? (l.diffuse.value = i.color,
            l.opacity.value = i.opacity,
            l.size.value = i.size * gt,
            l.scale.value = .5 * mt,
            l.map.value = i.map,
            null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(),
            l.uvTransform.value.copy(i.map.matrix))) : i.isSpriteMaterial ? (l.diffuse.value = i.color,
            l.opacity.value = i.opacity,
            l.rotation.value = i.rotation,
            l.map.value = i.map,
            null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(),
            l.uvTransform.value.copy(i.map.matrix))) : i.isShadowMaterial && (l.color.value = i.color,
            l.opacity.value = i.opacity),
            void 0 !== l.ltc_1 && (l.ltc_1.value = Jr.LTC_1),
            void 0 !== l.ltc_2 && (l.ltc_2.value = Jr.LTC_2),
            zt.upload(Et, r.uniformsList, l, U)),
            i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (zt.upload(Et, r.uniformsList, l, U),
            i.uniformsNeedUpdate = !1),
            i.isSpriteMaterial && o.setValue(Et, "center", n.center),
            o.setValue(Et, "modelViewMatrix", n.modelViewMatrix),
            o.setValue(Et, "normalMatrix", n.normalMatrix),
            o.setValue(Et, "modelMatrix", n.matrixWorld),
            a
        }
        function y(t, e) {
            if (t.opacity.value = e.opacity,
            e.color && (t.diffuse.value = e.color),
            e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
            e.map && (t.map.value = e.map),
            e.alphaMap && (t.alphaMap.value = e.alphaMap),
            e.specularMap && (t.specularMap.value = e.specularMap),
            e.envMap && (t.envMap.value = e.envMap,
            t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1,
            t.reflectivity.value = e.reflectivity,
            t.refractionRatio.value = e.refractionRatio,
            t.maxMipLevel.value = k.get(e.envMap).__maxMipLevel),
            e.lightMap && (t.lightMap.value = e.lightMap,
            t.lightMapIntensity.value = e.lightMapIntensity),
            e.aoMap && (t.aoMap.value = e.aoMap,
            t.aoMapIntensity.value = e.aoMapIntensity),
            e.map)
                var i = e.map;
            else
                e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap);
            void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture),
            !0 === i.matrixAutoUpdate && i.updateMatrix(),
            t.uvTransform.value.copy(i.matrix))
        }
        function x(t, e) {
            t.specular.value = e.specular,
            t.shininess.value = Math.max(e.shininess, 1e-4),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap && (t.bumpMap.value = e.bumpMap,
            t.bumpScale.value = e.bumpScale,
            1 === e.side && (t.bumpScale.value *= -1)),
            e.normalMap && (t.normalMap.value = e.normalMap,
            t.normalScale.value.copy(e.normalScale),
            1 === e.side && t.normalScale.value.negate()),
            e.displacementMap && (t.displacementMap.value = e.displacementMap,
            t.displacementScale.value = e.displacementScale,
            t.displacementBias.value = e.displacementBias)
        }
        function M(t, e) {
            t.roughness.value = e.roughness,
            t.metalness.value = e.metalness,
            e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
            e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap && (t.bumpMap.value = e.bumpMap,
            t.bumpScale.value = e.bumpScale,
            1 === e.side && (t.bumpScale.value *= -1)),
            e.normalMap && (t.normalMap.value = e.normalMap,
            t.normalScale.value.copy(e.normalScale),
            1 === e.side && t.normalScale.value.negate()),
            e.displacementMap && (t.displacementMap.value = e.displacementMap,
            t.displacementScale.value = e.displacementScale,
            t.displacementBias.value = e.displacementBias),
            e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
        }
        var _ = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
          , S = void 0 !== t.context ? t.context : null
          , T = void 0 !== t.alpha && t.alpha
          , E = void 0 === t.depth || t.depth
          , A = void 0 === t.stencil || t.stencil
          , L = void 0 !== t.antialias && t.antialias
          , P = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
          , C = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
          , I = void 0 !== t.powerPreference ? t.powerPreference : "default"
          , R = null
          , O = null;
        this.domElement = _,
        this.context = null,
        this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1,
        this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        var D, z, B, N, k, U, F, G, V, j, H, W, X, q, Y, J, tt, et = this, it = !1, nt = null, rt = null, at = null, ot = -1, st = e = null, ct = !1, ht = null, lt = null, ut = new s, pt = new s, dt = null, ft = _.width, mt = _.height, gt = 1, vt = new s(0,0,ft,mt), yt = new s(0,0,ft,mt), xt = !1, bt = new m, wt = new Q, Mt = !1, _t = !1, St = new g, Tt = new r;
        try {
            T = {
                alpha: T,
                depth: E,
                stencil: A,
                antialias: L,
                premultipliedAlpha: P,
                preserveDrawingBuffer: C,
                powerPreference: I
            },
            _.addEventListener("webglcontextlost", a, !1),
            _.addEventListener("webglcontextrestored", o, !1);
            var Et = S || _.getContext("webgl", T) || _.getContext("experimental-webgl", T);
            if (null === Et) {
                if (null !== _.getContext("webgl"))
                    throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.")
            }
            void 0 === Et.getShaderPrecisionFormat && (Et.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (t) {
            throw t
        }
        n();
        var At = null;
        "undefined" != typeof navigator && (At = "xr"in navigator ? new oe(et) : new ae(et)),
        this.vr = At;
        var Lt = new Kt(et,V,z.maxTextureSize);
        this.shadowMap = Lt,
        this.getContext = function() {
            return Et
        }
        ,
        this.getContextAttributes = function() {
            return Et.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            var t = D.get("WEBGL_lose_context");
            t && t.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            var t = D.get("WEBGL_lose_context");
            t && t.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return gt
        }
        ,
        this.setPixelRatio = function(t) {
            void 0 !== t && (gt = t,
            this.setSize(ft, mt, !1))
        }
        ,
        this.getSize = function(t) {
            return void 0 === t && (t = new i),
            t.set(ft, mt)
        }
        ,
        this.setSize = function(t, e, i) {
            At.isPresenting() || (ft = t,
            mt = e,
            _.width = t * gt,
            _.height = e * gt,
            !1 !== i && (_.style.width = t + "px",
            _.style.height = e + "px"),
            this.setViewport(0, 0, t, e))
        }
        ,
        this.getDrawingBufferSize = function(t) {
            return void 0 === t && (t = new i),
            t.set(ft * gt, mt * gt)
        }
        ,
        this.setDrawingBufferSize = function(t, e, i) {
            ft = t,
            mt = e,
            gt = i,
            _.width = t * i,
            _.height = e * i,
            this.setViewport(0, 0, t, e)
        }
        ,
        this.getCurrentViewport = function(t) {
            return void 0 === t && (t = new s),
            t.copy(ut)
        }
        ,
        this.getViewport = function(t) {
            return t.copy(vt)
        }
        ,
        this.setViewport = function(t, e, i, n) {
            t.isVector4 ? vt.set(t.x, t.y, t.z, t.w) : vt.set(t, e, i, n),
            B.viewport(ut.copy(vt).multiplyScalar(gt))
        }
        ,
        this.getScissor = function(t) {
            return t.copy(yt)
        }
        ,
        this.setScissor = function(t, e, i, n) {
            t.isVector4 ? yt.set(t.x, t.y, t.z, t.w) : yt.set(t, e, i, n),
            B.scissor(pt.copy(yt).multiplyScalar(gt))
        }
        ,
        this.getScissorTest = function() {
            return xt
        }
        ,
        this.setScissorTest = function(t) {
            B.setScissorTest(xt = t)
        }
        ,
        this.getClearColor = function() {
            return X.getClearColor()
        }
        ,
        this.setClearColor = function() {
            X.setClearColor.apply(X, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return X.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            X.setClearAlpha.apply(X, arguments)
        }
        ,
        this.clear = function(t, e, i) {
            var n = 0;
            (void 0 === t || t) && (n |= 16384),
            (void 0 === e || e) && (n |= 256),
            (void 0 === i || i) && (n |= 1024),
            Et.clear(n)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            _.removeEventListener("webglcontextlost", a, !1),
            _.removeEventListener("webglcontextrestored", o, !1),
            H.dispose(),
            W.dispose(),
            k.dispose(),
            V.dispose(),
            At.dispose(),
            Ct.stop()
        }
        ,
        this.renderBufferImmediate = function(t, e) {
            B.initAttributes();
            var i = k.get(t);
            t.hasPositions && !i.position && (i.position = Et.createBuffer()),
            t.hasNormals && !i.normal && (i.normal = Et.createBuffer()),
            t.hasUvs && !i.uv && (i.uv = Et.createBuffer()),
            t.hasColors && !i.color && (i.color = Et.createBuffer()),
            e = e.getAttributes(),
            t.hasPositions && (Et.bindBuffer(34962, i.position),
            Et.bufferData(34962, t.positionArray, 35048),
            B.enableAttribute(e.position),
            Et.vertexAttribPointer(e.position, 3, 5126, !1, 0, 0)),
            t.hasNormals && (Et.bindBuffer(34962, i.normal),
            Et.bufferData(34962, t.normalArray, 35048),
            B.enableAttribute(e.normal),
            Et.vertexAttribPointer(e.normal, 3, 5126, !1, 0, 0)),
            t.hasUvs && (Et.bindBuffer(34962, i.uv),
            Et.bufferData(34962, t.uvArray, 35048),
            B.enableAttribute(e.uv),
            Et.vertexAttribPointer(e.uv, 2, 5126, !1, 0, 0)),
            t.hasColors && (Et.bindBuffer(34962, i.color),
            Et.bufferData(34962, t.colorArray, 35048),
            B.enableAttribute(e.color),
            Et.vertexAttribPointer(e.color, 3, 5126, !1, 0, 0)),
            B.disableUnusedAttributes(),
            Et.drawArrays(4, 0, t.count),
            t.count = 0
        }
        ,
        this.renderBufferDirect = function(t, i, n, r, a, o) {
            var s = a.isMesh && 0 > a.matrixWorld.determinant();
            B.setMaterial(r, s);
            var c = f(t, i, r, a)
              , h = !1;
            e === n.id && st === c.id && ct === (!0 === r.wireframe) || (e = n.id,
            st = c.id,
            ct = !0 === r.wireframe,
            h = !0),
            a.morphTargetInfluences && (q.update(a, n, r, c),
            h = !0),
            s = n.index;
            var l = n.attributes.position;
            if (i = 1,
            !0 === r.wireframe && (s = G.getWireframeAttribute(n),
            i = 2),
            t = Y,
            null !== s) {
                var u = F.get(s);
                (t = J).setIndex(u)
            }
            if (h) {
                if (n && n.isInstancedBufferGeometry && !z.isWebGL2 && null === D.get("ANGLE_instanced_arrays"))
                    ;
                else {
                    B.initAttributes(),
                    h = n.attributes,
                    c = c.getAttributes();
                    var p = r.defaultAttributeValues;
                    for (_ in c) {
                        var d = c[_];
                        if (0 <= d) {
                            var m = h[_];
                            if (void 0 !== m) {
                                var g = m.normalized
                                  , v = m.itemSize
                                  , y = F.get(m);
                                if (void 0 !== y) {
                                    var x = y.buffer
                                      , b = y.type;
                                    if (y = y.bytesPerElement,
                                    m.isInterleavedBufferAttribute) {
                                        var w = m.data
                                          , M = w.stride;
                                        m = m.offset,
                                        w && w.isInstancedInterleavedBuffer ? (B.enableAttributeAndDivisor(d, w.meshPerAttribute),
                                        void 0 === n.maxInstancedCount && (n.maxInstancedCount = w.meshPerAttribute * w.count)) : B.enableAttribute(d),
                                        Et.bindBuffer(34962, x),
                                        Et.vertexAttribPointer(d, v, b, g, M * y, m * y)
                                    } else
                                        m.isInstancedBufferAttribute ? (B.enableAttributeAndDivisor(d, m.meshPerAttribute),
                                        void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : B.enableAttribute(d),
                                        Et.bindBuffer(34962, x),
                                        Et.vertexAttribPointer(d, v, b, g, 0, 0)
                                }
                            } else if (void 0 !== p && void 0 !== (g = p[_]))
                                switch (g.length) {
                                case 2:
                                    Et.vertexAttrib2fv(d, g);
                                    break;
                                case 3:
                                    Et.vertexAttrib3fv(d, g);
                                    break;
                                case 4:
                                    Et.vertexAttrib4fv(d, g);
                                    break;
                                default:
                                    Et.vertexAttrib1fv(d, g)
                                }
                        }
                    }
                    B.disableUnusedAttributes()
                }
                null !== s && Et.bindBuffer(34963, u.buffer)
            }
            u = 1 / 0,
            null !== s ? u = s.count : void 0 !== l && (u = l.count),
            s = n.drawRange.start * i,
            l = null !== o ? o.start * i : 0;
            var _ = Math.max(s, l);
            if (0 !== (o = Math.max(0, Math.min(u, s + n.drawRange.count * i, l + (null !== o ? o.count * i : 1 / 0)) - 1 - _ + 1))) {
                if (a.isMesh)
                    if (!0 === r.wireframe)
                        B.setLineWidth(r.wireframeLinewidth * (null === rt ? gt : 1)),
                        t.setMode(1);
                    else
                        switch (a.drawMode) {
                        case 0:
                            t.setMode(4);
                            break;
                        case 1:
                            t.setMode(5);
                            break;
                        case 2:
                            t.setMode(6)
                        }
                else
                    a.isLine ? (void 0 === (r = r.linewidth) && (r = 1),
                    B.setLineWidth(r * (null === rt ? gt : 1)),
                    a.isLineSegments ? t.setMode(1) : a.isLineLoop ? t.setMode(2) : t.setMode(3)) : a.isPoints ? t.setMode(0) : a.isSprite && t.setMode(4);
                n && n.isInstancedBufferGeometry ? 0 < n.maxInstancedCount && t.renderInstances(n, _, o) : t.render(_, o)
            }
        }
        ,
        this.compile = function(t, e) {
            (O = W.get(t, e)).init(),
            t.traverse(function(t) {
                t.isLight && (O.pushLight(t),
                t.castShadow && O.pushShadow(t))
            }),
            O.setupLights(e),
            t.traverse(function(e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var i = 0; i < e.material.length; i++)
                            d(e.material[i], t.fog, e);
                    else
                        d(e.material, t.fog, e)
            })
        }
        ;
        var Pt = null
          , Ct = new b;
        Ct.setAnimationLoop(function(t) {
            At.isPresenting() || Pt && Pt(t)
        }),
        "undefined" != typeof window && Ct.setContext(window),
        this.setAnimationLoop = function(t) {
            Pt = t,
            At.setAnimationLoop(t),
            Ct.start()
        }
        ,
        this.render = function(t, i, n, r) {
            if (void 0 !== n)
                var a = n;
            if (void 0 !== r)
                var o = r;
            i && i.isCamera && (it || (st = e = null,
            ct = !1,
            ot = -1,
            ht = null,
            !0 === t.autoUpdate && t.updateMatrixWorld(),
            null === i.parent && i.updateMatrixWorld(),
            At.enabled && (i = At.getCamera(i)),
            (O = W.get(t, i)).init(),
            t.onBeforeRender(et, t, i, a || rt),
            St.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            bt.setFromMatrix(St),
            _t = this.localClippingEnabled,
            Mt = wt.init(this.clippingPlanes, _t, i),
            (R = H.get(t, i)).init(),
            function t(e, i, n, r) {
                if (!1 !== e.visible) {
                    if (e.layers.test(i.layers))
                        if (e.isGroup)
                            n = e.renderOrder;
                        else if (e.isLight)
                            O.pushLight(e),
                            e.castShadow && O.pushShadow(e);
                        else if (e.isSprite) {
                            if (!e.frustumCulled || bt.intersectsSprite(e)) {
                                r && Tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(St);
                                var a = V.update(e)
                                  , o = e.material;
                                o.visible && R.push(e, a, o, n, Tt.z, null)
                            }
                        } else if (e.isImmediateRenderObject)
                            r && Tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(St),
                            R.push(e, null, e.material, n, Tt.z, null);
                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(),
                        !e.frustumCulled || bt.intersectsObject(e)))
                            if (r && Tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(St),
                            a = V.update(e),
                            o = e.material,
                            Array.isArray(o))
                                for (var s = a.groups, c = 0, h = s.length; c < h; c++) {
                                    var l = s[c]
                                      , u = o[l.materialIndex];
                                    u && u.visible && R.push(e, a, u, n, Tt.z, l)
                                }
                            else
                                o.visible && R.push(e, a, o, n, Tt.z, null);
                    for (c = 0,
                    h = (e = e.children).length; c < h; c++)
                        t(e[c], i, n, r)
                }
            }(t, i, 0, et.sortObjects),
            !0 === et.sortObjects && R.sort(),
            Mt && wt.beginShadows(),
            Lt.render(O.state.shadowsArray, t, i),
            O.setupLights(i),
            Mt && wt.endShadows(),
            this.info.autoReset && this.info.reset(),
            void 0 !== a && this.setRenderTarget(a),
            X.render(R, t, i, o),
            n = R.opaque,
            r = R.transparent,
            t.overrideMaterial ? (a = t.overrideMaterial,
            n.length && l(n, t, i, a),
            r.length && l(r, t, i, a)) : (n.length && l(n, t, i),
            r.length && l(r, t, i)),
            t.onAfterRender(et, t, i),
            null !== rt && (U.updateRenderTargetMipmap(rt),
            U.updateMultisampleRenderTarget(rt)),
            B.buffers.depth.setTest(!0),
            B.buffers.depth.setMask(!0),
            B.buffers.color.setMask(!0),
            B.setPolygonOffset(!1),
            At.enabled && At.submitFrame(),
            O = R = null))
        }
        ,
        this.setFramebuffer = function(t) {
            nt = t
        }
        ,
        this.getRenderTarget = function() {
            return rt
        }
        ,
        this.setRenderTarget = function(t, e, i) {
            (rt = t) && void 0 === k.get(t).__webglFramebuffer && U.setupRenderTarget(t);
            var n = nt
              , r = !1;
            t ? (n = k.get(t).__webglFramebuffer,
            t.isWebGLRenderTargetCube ? (n = n[e || 0],
            r = !0) : n = t.isWebGLMultisampleRenderTarget ? k.get(t).__webglMultisampledFramebuffer : n,
            ut.copy(t.viewport),
            pt.copy(t.scissor),
            dt = t.scissorTest) : (ut.copy(vt).multiplyScalar(gt),
            pt.copy(yt).multiplyScalar(gt),
            dt = xt),
            at !== n && (Et.bindFramebuffer(36160, n),
            at = n),
            B.viewport(ut),
            B.scissor(pt),
            B.setScissorTest(dt),
            r && (t = k.get(t.texture),
            Et.framebufferTexture2D(36160, 36064, 34069 + (e || 0), t.__webglTexture, i || 0))
        }
        ,
        this.readRenderTargetPixels = function(t, e, i, n, r, a) {
            if (t && t.isWebGLRenderTarget) {
                var o = k.get(t).__webglFramebuffer;
                if (o) {
                    var s = !1;
                    o !== at && (Et.bindFramebuffer(36160, o),
                    s = !0);
                    try {
                        var c = t.texture
                          , h = c.format
                          , l = c.type;
                        1023 !== h && tt.convert(h) !== Et.getParameter(35739) || (1009 === l || tt.convert(l) === Et.getParameter(35738) || 1015 === l && (z.isWebGL2 || D.get("OES_texture_float") || D.get("WEBGL_color_buffer_float")) || 1016 === l && (z.isWebGL2 ? D.get("EXT_color_buffer_float") : D.get("EXT_color_buffer_half_float"))) && 36053 === Et.checkFramebufferStatus(36160) && 0 <= e && e <= t.width - n && 0 <= i && i <= t.height - r && Et.readPixels(e, i, n, r, tt.convert(h), tt.convert(l), a)
                    } finally {
                        s && Et.bindFramebuffer(36160, at)
                    }
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(t, e, i) {
            var n = e.image.width
              , r = e.image.height
              , a = tt.convert(e.format);
            U.setTexture2D(e, 0),
            Et.copyTexImage2D(3553, i || 0, a, t.x, t.y, n, r, 0)
        }
        ,
        this.copyTextureToTexture = function(t, e, i, n) {
            var r = e.image.width
              , a = e.image.height
              , o = tt.convert(i.format)
              , s = tt.convert(i.type);
            U.setTexture2D(i, 0),
            e.isDataTexture ? Et.texSubImage2D(3553, n || 0, t.x, t.y, r, a, o, s, e.image.data) : Et.texSubImage2D(3553, n || 0, t.x, t.y, o, s, e.image)
        }
    }
    function ce(t, e) {
        this.name = "",
        this.color = new x(t),
        this.density = void 0 !== e ? e : 25e-5
    }
    function he(t, e, i) {
        this.name = "",
        this.color = new x(t),
        this.near = void 0 !== e ? e : 1,
        this.far = void 0 !== i ? i : 1e3
    }
    function le() {
        T.call(this),
        this.type = "Scene",
        this.overrideMaterial = this.fog = this.background = null,
        this.autoUpdate = !0
    }
    function ue(t, e) {
        this.array = t,
        this.stride = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function pe(t, e, i, n) {
        this.data = t,
        this.itemSize = e,
        this.offset = i,
        this.normalized = !0 === n
    }
    function de(t) {
        H.call(this),
        this.type = "SpriteMaterial",
        this.color = new x(16777215),
        this.map = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.lights = !1,
        this.transparent = !0,
        this.setValues(t)
    }
    function fe(t) {
        if (T.call(this),
        this.type = "Sprite",
        void 0 === da) {
            da = new U;
            var e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
            e = new ue(e,5),
            da.setIndex([0, 1, 2, 0, 2, 3]),
            da.addAttribute("position", new pe(e,3,0,!1)),
            da.addAttribute("uv", new pe(e,2,3,!1))
        }
        this.geometry = da,
        this.material = void 0 !== t ? t : new de,
        this.center = new i(.5,.5)
    }
    function me() {
        T.call(this),
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }
    function ge(t, e) {
        t && t.isGeometry,
        J.call(this, t, e),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new g,
        this.bindMatrixInverse = new g
    }
    function ve(t, e) {
        if (t = t || [],
        this.bones = t.slice(0),
        this.boneMatrices = new Float32Array(16 * this.bones.length),
        void 0 === e)
            this.calculateInverses();
        else if (this.bones.length === e.length)
            this.boneInverses = e.slice(0);
        else
            for (this.boneInverses = [],
            t = 0,
            e = this.bones.length; t < e; t++)
                this.boneInverses.push(new g)
    }
    function ye() {
        T.call(this),
        this.type = "Bone"
    }
    function xe(t) {
        H.call(this),
        this.type = "LineBasicMaterial",
        this.color = new x(16777215),
        this.linewidth = 1,
        this.linejoin = this.linecap = "round",
        this.lights = !1,
        this.setValues(t)
    }
    function be(t, e) {
        T.call(this),
        this.type = "Line",
        this.geometry = void 0 !== t ? t : new U,
        this.material = void 0 !== e ? e : new xe({
            color: 16777215 * Math.random()
        })
    }
    function we(t, e) {
        be.call(this, t, e),
        this.type = "LineSegments"
    }
    function Me(t, e) {
        be.call(this, t, e),
        this.type = "LineLoop"
    }
    function _e(t) {
        H.call(this),
        this.type = "PointsMaterial",
        this.color = new x(16777215),
        this.map = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.lights = this.morphTargets = !1,
        this.setValues(t)
    }
    function Se(t, e) {
        T.call(this),
        this.type = "Points",
        this.geometry = void 0 !== t ? t : new U,
        this.material = void 0 !== e ? e : new _e({
            color: 16777215 * Math.random()
        })
    }
    function Te(t, e, i, n, r, a, s, c, h) {
        o.call(this, t, e, i, n, r, a, s, c, h),
        this.format = void 0 !== s ? s : 1022,
        this.minFilter = void 0 !== a ? a : 1006,
        this.magFilter = void 0 !== r ? r : 1006,
        this.generateMipmaps = !1
    }
    function Ee(t, e, i, n, r, a, s, c, h, l, u, p) {
        o.call(this, null, a, s, c, h, l, n, r, u, p),
        this.image = {
            width: e,
            height: i
        },
        this.mipmaps = t,
        this.generateMipmaps = this.flipY = !1
    }
    function Ae(t, e, i, n, r, a, s, c, h) {
        o.call(this, t, e, i, n, r, a, s, c, h),
        this.needsUpdate = !0
    }
    function Le(t, e, i, n, r, a, s, c, h, l) {
        if (1026 !== (l = void 0 !== l ? l : 1026) && 1027 !== l)
            throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && 1026 === l && (i = 1012),
        void 0 === i && 1027 === l && (i = 1020),
        o.call(this, null, n, r, a, s, c, l, i, h),
        this.image = {
            width: t,
            height: e
        },
        this.magFilter = void 0 !== s ? s : 1003,
        this.minFilter = void 0 !== c ? c : 1003,
        this.generateMipmaps = this.flipY = !1
    }
    function Pe(t) {
        U.call(this),
        this.type = "WireframeGeometry";
        var e, i, n, a = [], o = [0, 0], s = {}, c = ["a", "b", "c"];
        if (t && t.isGeometry) {
            var h = t.faces
              , l = 0;
            for (i = h.length; l < i; l++) {
                var u = h[l];
                for (e = 0; 3 > e; e++) {
                    var p = u[c[e]]
                      , d = u[c[(e + 1) % 3]];
                    o[0] = Math.min(p, d),
                    o[1] = Math.max(p, d),
                    void 0 === s[p = o[0] + "," + o[1]] && (s[p] = {
                        index1: o[0],
                        index2: o[1]
                    })
                }
            }
            for (p in s)
                l = s[p],
                c = t.vertices[l.index1],
                a.push(c.x, c.y, c.z),
                c = t.vertices[l.index2],
                a.push(c.x, c.y, c.z)
        } else if (t && t.isBufferGeometry)
            if (c = new r,
            null !== t.index) {
                h = t.attributes.position,
                u = t.index;
                var f = t.groups;
                for (0 === f.length && (f = [{
                    start: 0,
                    count: u.count,
                    materialIndex: 0
                }]),
                t = 0,
                n = f.length; t < n; ++t)
                    for (e = (l = f[t]).start,
                    i = l.count,
                    l = e,
                    i = e + i; l < i; l += 3)
                        for (e = 0; 3 > e; e++)
                            p = u.getX(l + e),
                            d = u.getX(l + (e + 1) % 3),
                            o[0] = Math.min(p, d),
                            o[1] = Math.max(p, d),
                            void 0 === s[p = o[0] + "," + o[1]] && (s[p] = {
                                index1: o[0],
                                index2: o[1]
                            });
                for (p in s)
                    l = s[p],
                    c.fromBufferAttribute(h, l.index1),
                    a.push(c.x, c.y, c.z),
                    c.fromBufferAttribute(h, l.index2),
                    a.push(c.x, c.y, c.z)
            } else
                for (l = 0,
                i = (h = t.attributes.position).count / 3; l < i; l++)
                    for (e = 0; 3 > e; e++)
                        s = 3 * l + e,
                        c.fromBufferAttribute(h, s),
                        a.push(c.x, c.y, c.z),
                        s = 3 * l + (e + 1) % 3,
                        c.fromBufferAttribute(h, s),
                        a.push(c.x, c.y, c.z);
        this.addAttribute("position", new z(a,3))
    }
    function Ce(t, e, i) {
        E.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: t,
            slices: e,
            stacks: i
        },
        this.fromBufferGeometry(new Ie(t,e,i)),
        this.mergeVertices()
    }
    function Ie(t, e, i) {
        U.call(this),
        this.type = "ParametricBufferGeometry",
        this.parameters = {
            func: t,
            slices: e,
            stacks: i
        };
        var n, a, o = [], s = [], c = [], h = [], l = new r, u = new r, p = new r, d = new r, f = new r;
        t.length;
        var m = e + 1;
        for (n = 0; n <= i; n++) {
            var g = n / i;
            for (a = 0; a <= e; a++) {
                var v = a / e;
                t(v, g, u),
                s.push(u.x, u.y, u.z),
                0 <= v - 1e-5 ? (t(v - 1e-5, g, p),
                d.subVectors(u, p)) : (t(v + 1e-5, g, p),
                d.subVectors(p, u)),
                0 <= g - 1e-5 ? (t(v, g - 1e-5, p),
                f.subVectors(u, p)) : (t(v, g + 1e-5, p),
                f.subVectors(p, u)),
                l.crossVectors(d, f).normalize(),
                c.push(l.x, l.y, l.z),
                h.push(v, g)
            }
        }
        for (n = 0; n < i; n++)
            for (a = 0; a < e; a++)
                t = n * m + a + 1,
                l = (n + 1) * m + a + 1,
                u = (n + 1) * m + a,
                o.push(n * m + a, t, u),
                o.push(t, l, u);
        this.setIndex(o),
        this.addAttribute("position", new z(s,3)),
        this.addAttribute("normal", new z(c,3)),
        this.addAttribute("uv", new z(h,2))
    }
    function Re(t, e, i, n) {
        E.call(this),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: t,
            indices: e,
            radius: i,
            detail: n
        },
        this.fromBufferGeometry(new Oe(t,e,i,n)),
        this.mergeVertices()
    }
    function Oe(t, e, n, a) {
        function o(t) {
            h.push(t.x, t.y, t.z)
        }
        function s(e, i) {
            e *= 3,
            i.x = t[e + 0],
            i.y = t[e + 1],
            i.z = t[e + 2]
        }
        function c(t, e, i, n) {
            0 > n && 1 === t.x && (l[e] = t.x - 1),
            0 === i.x && 0 === i.z && (l[e] = n / 2 / Math.PI + .5)
        }
        U.call(this),
        this.type = "PolyhedronBufferGeometry",
        this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: a
        },
        n = n || 1;
        var h = []
          , l = [];
        !function(t) {
            for (var i = new r, n = new r, a = new r, c = 0; c < e.length; c += 3) {
                s(e[c + 0], i),
                s(e[c + 1], n),
                s(e[c + 2], a);
                var h, l, u = i, p = n, d = a, f = Math.pow(2, t), m = [];
                for (l = 0; l <= f; l++) {
                    m[l] = [];
                    var g = u.clone().lerp(d, l / f)
                      , v = p.clone().lerp(d, l / f)
                      , y = f - l;
                    for (h = 0; h <= y; h++)
                        m[l][h] = 0 === h && l === f ? g : g.clone().lerp(v, h / y)
                }
                for (l = 0; l < f; l++)
                    for (h = 0; h < 2 * (f - l) - 1; h++)
                        u = Math.floor(h / 2),
                        0 == h % 2 ? (o(m[l][u + 1]),
                        o(m[l + 1][u]),
                        o(m[l][u])) : (o(m[l][u + 1]),
                        o(m[l + 1][u + 1]),
                        o(m[l + 1][u]))
            }
        }(a = a || 0),
        function(t) {
            for (var e = new r, i = 0; i < h.length; i += 3)
                e.x = h[i + 0],
                e.y = h[i + 1],
                e.z = h[i + 2],
                e.normalize().multiplyScalar(t),
                h[i + 0] = e.x,
                h[i + 1] = e.y,
                h[i + 2] = e.z
        }(n),
        function() {
            for (var t = new r, e = 0; e < h.length; e += 3)
                t.x = h[e + 0],
                t.y = h[e + 1],
                t.z = h[e + 2],
                l.push(Math.atan2(t.z, -t.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5));
            t = new r,
            e = new r;
            for (var n = new r, a = new r, o = new i, s = new i, u = new i, p = 0, d = 0; p < h.length; p += 9,
            d += 6) {
                t.set(h[p + 0], h[p + 1], h[p + 2]),
                e.set(h[p + 3], h[p + 4], h[p + 5]),
                n.set(h[p + 6], h[p + 7], h[p + 8]),
                o.set(l[d + 0], l[d + 1]),
                s.set(l[d + 2], l[d + 3]),
                u.set(l[d + 4], l[d + 5]),
                a.copy(t).add(e).add(n).divideScalar(3);
                var f = Math.atan2(a.z, -a.x);
                c(o, d + 0, t, f),
                c(s, d + 2, e, f),
                c(u, d + 4, n, f)
            }
            for (t = 0; t < l.length; t += 6)
                e = l[t + 0],
                n = l[t + 2],
                a = l[t + 4],
                o = Math.min(e, n, a),
                .9 < Math.max(e, n, a) && .1 > o && (.2 > e && (l[t + 0] += 1),
                .2 > n && (l[t + 2] += 1),
                .2 > a && (l[t + 4] += 1))
        }(),
        this.addAttribute("position", new z(h,3)),
        this.addAttribute("normal", new z(h.slice(),3)),
        this.addAttribute("uv", new z(l,2)),
        0 === a ? this.computeVertexNormals() : this.normalizeNormals()
    }
    function De(t, e) {
        E.call(this),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new ze(t,e)),
        this.mergeVertices()
    }
    function ze(t, e) {
        Oe.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e),
        this.type = "TetrahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Be(t, e) {
        E.call(this),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new Ne(t,e)),
        this.mergeVertices()
    }
    function Ne(t, e) {
        Oe.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e),
        this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function ke(t, e) {
        E.call(this),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new Ue(t,e)),
        this.mergeVertices()
    }
    function Ue(t, e) {
        var i = (1 + Math.sqrt(5)) / 2;
        Oe.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e),
        this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Fe(t, e) {
        E.call(this),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new Ge(t,e)),
        this.mergeVertices()
    }
    function Ge(t, e) {
        var i = (1 + Math.sqrt(5)) / 2
          , n = 1 / i;
        Oe.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e),
        this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Ve(t, e, i, n, r) {
        E.call(this),
        this.type = "TubeGeometry",
        this.parameters = {
            path: t,
            tubularSegments: e,
            radius: i,
            radialSegments: n,
            closed: r
        },
        t = new je(t,e,i,n,r),
        this.tangents = t.tangents,
        this.normals = t.normals,
        this.binormals = t.binormals,
        this.fromBufferGeometry(t),
        this.mergeVertices()
    }
    function je(t, e, n, a, o) {
        function s(i) {
            f = t.getPointAt(i / e, f);
            var r = c.normals[i];
            for (i = c.binormals[i],
            l = 0; l <= a; l++) {
                var o = l / a * Math.PI * 2
                  , s = Math.sin(o);
                o = -Math.cos(o),
                p.x = o * r.x + s * i.x,
                p.y = o * r.y + s * i.y,
                p.z = o * r.z + s * i.z,
                p.normalize(),
                g.push(p.x, p.y, p.z),
                u.x = f.x + n * p.x,
                u.y = f.y + n * p.y,
                u.z = f.z + n * p.z,
                m.push(u.x, u.y, u.z)
            }
        }
        U.call(this),
        this.type = "TubeBufferGeometry",
        this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: a,
            closed: o
        },
        e = e || 64,
        n = n || 1,
        a = a || 8,
        o = o || !1;
        var c = t.computeFrenetFrames(e, o);
        this.tangents = c.tangents,
        this.normals = c.normals,
        this.binormals = c.binormals;
        var h, l, u = new r, p = new r, d = new i, f = new r, m = [], g = [], v = [], y = [];
        for (h = 0; h < e; h++)
            s(h);
        for (s(!1 === o ? e : 0),
        h = 0; h <= e; h++)
            for (l = 0; l <= a; l++)
                d.x = h / e,
                d.y = l / a,
                v.push(d.x, d.y);
        !function() {
            for (l = 1; l <= e; l++)
                for (h = 1; h <= a; h++) {
                    var t = (a + 1) * l + (h - 1)
                      , i = (a + 1) * l + h
                      , n = (a + 1) * (l - 1) + h;
                    y.push((a + 1) * (l - 1) + (h - 1), t, n),
                    y.push(t, i, n)
                }
        }(),
        this.setIndex(y),
        this.addAttribute("position", new z(m,3)),
        this.addAttribute("normal", new z(g,3)),
        this.addAttribute("uv", new z(v,2))
    }
    function He(t, e, i, n, r, a) {
        E.call(this),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: a
        },
        this.fromBufferGeometry(new We(t,e,i,n,r,a)),
        this.mergeVertices()
    }
    function We(t, e, i, n, a, o) {
        function s(t, e, i, n, r) {
            var a = Math.sin(t);
            e = i / e * t,
            i = Math.cos(e),
            r.x = n * (2 + i) * .5 * Math.cos(t),
            r.y = n * (2 + i) * a * .5,
            r.z = n * Math.sin(e) * .5
        }
        U.call(this),
        this.type = "TorusKnotBufferGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: i,
            radialSegments: n,
            p: a,
            q: o
        },
        t = t || 1,
        e = e || .4,
        i = Math.floor(i) || 64,
        n = Math.floor(n) || 8,
        a = a || 2,
        o = o || 3;
        var c, h = [], l = [], u = [], p = [], d = new r, f = new r, m = new r, g = new r, v = new r, y = new r, x = new r;
        for (c = 0; c <= i; ++c) {
            var b = c / i * a * Math.PI * 2;
            for (s(b, a, o, t, m),
            s(b + .01, a, o, t, g),
            y.subVectors(g, m),
            x.addVectors(g, m),
            v.crossVectors(y, x),
            x.crossVectors(v, y),
            v.normalize(),
            x.normalize(),
            b = 0; b <= n; ++b) {
                var w = b / n * Math.PI * 2
                  , M = -e * Math.cos(w);
                w = e * Math.sin(w),
                d.x = m.x + (M * x.x + w * v.x),
                d.y = m.y + (M * x.y + w * v.y),
                d.z = m.z + (M * x.z + w * v.z),
                l.push(d.x, d.y, d.z),
                f.subVectors(d, m).normalize(),
                u.push(f.x, f.y, f.z),
                p.push(c / i),
                p.push(b / n)
            }
        }
        for (b = 1; b <= i; b++)
            for (c = 1; c <= n; c++)
                t = (n + 1) * b + (c - 1),
                e = (n + 1) * b + c,
                a = (n + 1) * (b - 1) + c,
                h.push((n + 1) * (b - 1) + (c - 1), t, a),
                h.push(t, e, a);
        this.setIndex(h),
        this.addAttribute("position", new z(l,3)),
        this.addAttribute("normal", new z(u,3)),
        this.addAttribute("uv", new z(p,2))
    }
    function Xe(t, e, i, n, r) {
        E.call(this),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        },
        this.fromBufferGeometry(new qe(t,e,i,n,r)),
        this.mergeVertices()
    }
    function qe(t, e, i, n, a) {
        U.call(this),
        this.type = "TorusBufferGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            radialSegments: i,
            tubularSegments: n,
            arc: a
        },
        t = t || 1,
        e = e || .4,
        i = Math.floor(i) || 8,
        n = Math.floor(n) || 6,
        a = a || 2 * Math.PI;
        var o, s, c = [], h = [], l = [], u = [], p = new r, d = new r, f = new r;
        for (o = 0; o <= i; o++)
            for (s = 0; s <= n; s++) {
                var m = s / n * a
                  , g = o / i * Math.PI * 2;
                d.x = (t + e * Math.cos(g)) * Math.cos(m),
                d.y = (t + e * Math.cos(g)) * Math.sin(m),
                d.z = e * Math.sin(g),
                h.push(d.x, d.y, d.z),
                p.x = t * Math.cos(m),
                p.y = t * Math.sin(m),
                f.subVectors(d, p).normalize(),
                l.push(f.x, f.y, f.z),
                u.push(s / n),
                u.push(o / i)
            }
        for (o = 1; o <= i; o++)
            for (s = 1; s <= n; s++)
                t = (n + 1) * (o - 1) + s - 1,
                e = (n + 1) * (o - 1) + s,
                a = (n + 1) * o + s,
                c.push((n + 1) * o + s - 1, t, a),
                c.push(t, e, a);
        this.setIndex(c),
        this.addAttribute("position", new z(h,3)),
        this.addAttribute("normal", new z(l,3)),
        this.addAttribute("uv", new z(u,2))
    }
    function Ye(t, e, i, n, r) {
        for (var a, o = 0, s = e, c = i - n; s < i; s += n)
            o += (t[c] - t[s]) * (t[s + 1] + t[c + 1]),
            c = s;
        if (r === 0 < o)
            for (r = e; r < i; r += n)
                a = oi(r, t[r], t[r + 1], a);
        else
            for (r = i - n; r >= e; r -= n)
                a = oi(r, t[r], t[r + 1], a);
        return a && ii(a, a.next) && (si(a),
        a = a.next),
        a
    }
    function Je(t, e) {
        if (!t)
            return t;
        e || (e = t);
        do {
            var i = !1;
            if (t.steiner || !ii(t, t.next) && 0 !== ei(t.prev, t, t.next))
                t = t.next;
            else {
                if (si(t),
                (t = e = t.prev) === t.next)
                    break;
                i = !0
            }
        } while (i || t !== e);
        return e
    }
    function Ze(t, e) {
        return t.x - e.x
    }
    function Qe(t, e) {
        var i = e
          , n = t.x
          , r = t.y
          , a = -1 / 0;
        do {
            if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                var o = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                if (o <= n && o > a) {
                    if (a = o,
                    o === n) {
                        if (r === i.y)
                            return i;
                        if (r === i.next.y)
                            return i.next
                    }
                    var s = i.x < i.next.x ? i : i.next
                }
            }
            i = i.next
        } while (i !== e);
        if (!s)
            return null;
        if (n === a)
            return s.prev;
        e = s,
        o = s.x;
        var c = s.y
          , h = 1 / 0;
        for (i = s.next; i !== e; ) {
            if (n >= i.x && i.x >= o && n !== i.x && ti(r < c ? n : a, r, o, c, r < c ? a : n, r, i.x, i.y)) {
                var l = Math.abs(r - i.y) / (n - i.x);
                (l < h || l === h && i.x > s.x) && ri(i, t) && (s = i,
                h = l)
            }
            i = i.next
        }
        return s
    }
    function Ke(t, e, i, n, r) {
        return 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1) | (1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }
    function $e(t) {
        var e = t
          , i = t;
        do {
            e.x < i.x && (i = e),
            e = e.next
        } while (e !== t);
        return i
    }
    function ti(t, e, i, n, r, a, o, s) {
        return 0 <= (r - o) * (e - s) - (t - o) * (a - s) && 0 <= (t - o) * (n - s) - (i - o) * (e - s) && 0 <= (i - o) * (a - s) - (r - o) * (n - s)
    }
    function ei(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
    }
    function ii(t, e) {
        return t.x === e.x && t.y === e.y
    }
    function ni(t, e, i, n) {
        return !!(ii(t, e) && ii(i, n) || ii(t, n) && ii(i, e)) || 0 < ei(t, e, i) != 0 < ei(t, e, n) && 0 < ei(i, n, t) != 0 < ei(i, n, e)
    }
    function ri(t, e) {
        return 0 > ei(t.prev, t, t.next) ? 0 <= ei(t, e, t.next) && 0 <= ei(t, t.prev, e) : 0 > ei(t, e, t.prev) || 0 > ei(t, t.next, e)
    }
    function ai(t, e) {
        var i = new ci(t.i,t.x,t.y)
          , n = new ci(e.i,e.x,e.y)
          , r = t.next
          , a = e.prev;
        return t.next = e,
        e.prev = t,
        i.next = r,
        r.prev = i,
        n.next = i,
        i.prev = n,
        a.next = n,
        n.prev = a,
        n
    }
    function oi(t, e, i, n) {
        return t = new ci(t,e,i),
        n ? (t.next = n.next,
        t.prev = n,
        n.next.prev = t,
        n.next = t) : (t.prev = t,
        t.next = t),
        t
    }
    function si(t) {
        t.next.prev = t.prev,
        t.prev.next = t.next,
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }
    function ci(t, e, i) {
        this.i = t,
        this.x = e,
        this.y = i,
        this.nextZ = this.prevZ = this.z = this.next = this.prev = null,
        this.steiner = !1
    }
    function hi(t) {
        var e = t.length;
        2 < e && t[e - 1].equals(t[0]) && t.pop()
    }
    function li(t, e) {
        for (var i = 0; i < e.length; i++)
            t.push(e[i].x),
            t.push(e[i].y)
    }
    function ui(t, e) {
        E.call(this),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: t,
            options: e
        },
        this.fromBufferGeometry(new pi(t,e)),
        this.mergeVertices()
    }
    function pi(t, e) {
        function n(t) {
            function n(t, e, i) {
                return e.clone().multiplyScalar(i).add(t)
            }
            function c(t, e, n) {
                var r = t.x - e.x
                  , a = t.y - e.y
                  , o = n.x - t.x
                  , s = n.y - t.y
                  , c = r * r + a * a;
                if (Math.abs(r * s - a * o) > Number.EPSILON) {
                    var h = Math.sqrt(c)
                      , l = Math.sqrt(o * o + s * s);
                    if (c = e.x - a / h,
                    e = e.y + r / h,
                    2 >= (a = (o = c + r * (s = ((n.x - s / l - c) * s - (n.y + o / l - e) * o) / (r * s - a * o)) - t.x) * o + (r = e + a * s - t.y) * r))
                        return new i(o,r);
                    a = Math.sqrt(a / 2)
                } else
                    t = !1,
                    r > Number.EPSILON ? o > Number.EPSILON && (t = !0) : r < -Number.EPSILON ? o < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(s) && (t = !0),
                    t ? (o = -a,
                    a = Math.sqrt(c)) : (o = r,
                    r = a,
                    a = Math.sqrt(c / 2));
                return new i(o / a,r / a)
            }
            function h(t, e) {
                for (F = t.length; 0 <= --F; ) {
                    var i = F
                      , n = F - 1;
                    0 > n && (n = t.length - 1);
                    var r, s = g + 2 * w;
                    for (r = 0; r < s; r++) {
                        var c = k * r
                          , h = k * (r + 1)
                          , l = e + n + c
                          , u = e + n + h;
                        h = e + i + h,
                        p(e + i + c),
                        p(l),
                        p(h),
                        p(l),
                        p(u),
                        p(h),
                        c = o.length / 3,
                        d((c = _.generateSideWallUV(a, o, c - 6, c - 3, c - 2, c - 1))[0]),
                        d(c[1]),
                        d(c[3]),
                        d(c[1]),
                        d(c[2]),
                        d(c[3])
                    }
                }
            }
            function l(t, e, i) {
                f.push(t),
                f.push(e),
                f.push(i)
            }
            function u(t, e, i) {
                p(t),
                p(e),
                p(i),
                t = o.length / 3,
                d((t = _.generateTopUV(a, o, t - 3, t - 2, t - 1))[0]),
                d(t[1]),
                d(t[2])
            }
            function p(t) {
                o.push(f[3 * t]),
                o.push(f[3 * t + 1]),
                o.push(f[3 * t + 2])
            }
            function d(t) {
                s.push(t.x),
                s.push(t.y)
            }
            var f = []
              , m = void 0 !== e.curveSegments ? e.curveSegments : 12
              , g = void 0 !== e.steps ? e.steps : 1
              , v = void 0 !== e.depth ? e.depth : 100
              , y = void 0 === e.bevelEnabled || e.bevelEnabled
              , x = void 0 !== e.bevelThickness ? e.bevelThickness : 6
              , b = void 0 !== e.bevelSize ? e.bevelSize : x - 2
              , w = void 0 !== e.bevelSegments ? e.bevelSegments : 3
              , M = e.extrudePath
              , _ = void 0 !== e.UVGenerator ? e.UVGenerator : ya;
            void 0 !== e.amount && (v = e.amount);
            var S, T = !1;
            if (M) {
                var E = M.getSpacedPoints(g);
                T = !0,
                y = !1;
                var A = M.computeFrenetFrames(g, !1)
                  , L = new r
                  , P = new r
                  , C = new r
            }
            y || (b = x = w = 0),
            t = (m = t.extractPoints(m)).shape;
            var I = m.holes;
            if (!va.isClockWise(t)) {
                t = t.reverse();
                var R = 0;
                for (S = I.length; R < S; R++) {
                    var O = I[R];
                    va.isClockWise(O) && (I[R] = O.reverse())
                }
            }
            var D = va.triangulateShape(t, I)
              , z = t;
            for (R = 0,
            S = I.length; R < S; R++)
                O = I[R],
                t = t.concat(O);
            var B, N, k = t.length, U = D.length;
            m = [];
            var F = 0
              , G = z.length
              , V = G - 1;
            for (B = F + 1; F < G; F++,
            V++,
            B++)
                V === G && (V = 0),
                B === G && (B = 0),
                m[F] = c(z[F], z[V], z[B]);
            M = [];
            var j = m.concat();
            for (R = 0,
            S = I.length; R < S; R++) {
                O = I[R];
                var H = [];
                for (F = 0,
                V = (G = O.length) - 1,
                B = F + 1; F < G; F++,
                V++,
                B++)
                    V === G && (V = 0),
                    B === G && (B = 0),
                    H[F] = c(O[F], O[V], O[B]);
                M.push(H),
                j = j.concat(H)
            }
            for (V = 0; V < w; V++) {
                G = V / w;
                var W = x * Math.cos(G * Math.PI / 2);
                for (B = b * Math.sin(G * Math.PI / 2),
                F = 0,
                G = z.length; F < G; F++) {
                    var X = n(z[F], m[F], B);
                    l(X.x, X.y, -W)
                }
                for (R = 0,
                S = I.length; R < S; R++)
                    for (O = I[R],
                    H = M[R],
                    F = 0,
                    G = O.length; F < G; F++)
                        l((X = n(O[F], H[F], B)).x, X.y, -W)
            }
            for (B = b,
            F = 0; F < k; F++)
                X = y ? n(t[F], j[F], B) : t[F],
                T ? (P.copy(A.normals[0]).multiplyScalar(X.x),
                L.copy(A.binormals[0]).multiplyScalar(X.y),
                C.copy(E[0]).add(P).add(L),
                l(C.x, C.y, C.z)) : l(X.x, X.y, 0);
            for (G = 1; G <= g; G++)
                for (F = 0; F < k; F++)
                    X = y ? n(t[F], j[F], B) : t[F],
                    T ? (P.copy(A.normals[G]).multiplyScalar(X.x),
                    L.copy(A.binormals[G]).multiplyScalar(X.y),
                    C.copy(E[G]).add(P).add(L),
                    l(C.x, C.y, C.z)) : l(X.x, X.y, v / g * G);
            for (V = w - 1; 0 <= V; V--) {
                for (G = V / w,
                W = x * Math.cos(G * Math.PI / 2),
                B = b * Math.sin(G * Math.PI / 2),
                F = 0,
                G = z.length; F < G; F++)
                    l((X = n(z[F], m[F], B)).x, X.y, v + W);
                for (R = 0,
                S = I.length; R < S; R++)
                    for (O = I[R],
                    H = M[R],
                    F = 0,
                    G = O.length; F < G; F++)
                        X = n(O[F], H[F], B),
                        T ? l(X.x, X.y + E[g - 1].y, E[g - 1].x + W) : l(X.x, X.y, v + W)
            }
            !function() {
                var t = o.length / 3;
                if (y) {
                    var e = 0 * k;
                    for (F = 0; F < U; F++)
                        u((N = D[F])[2] + e, N[1] + e, N[0] + e);
                    for (e = k * (g + 2 * w),
                    F = 0; F < U; F++)
                        u((N = D[F])[0] + e, N[1] + e, N[2] + e)
                } else {
                    for (F = 0; F < U; F++)
                        u((N = D[F])[2], N[1], N[0]);
                    for (F = 0; F < U; F++)
                        u((N = D[F])[0] + k * g, N[1] + k * g, N[2] + k * g)
                }
                a.addGroup(t, o.length / 3 - t, 0)
            }(),
            function() {
                var t = o.length / 3
                  , e = 0;
                for (h(z, e),
                e += z.length,
                R = 0,
                S = I.length; R < S; R++)
                    h(O = I[R], e),
                    e += O.length;
                a.addGroup(t, o.length / 3 - t, 1)
            }()
        }
        U.call(this),
        this.type = "ExtrudeBufferGeometry",
        this.parameters = {
            shapes: t,
            options: e
        };
        for (var a = this, o = [], s = [], c = 0, h = (t = Array.isArray(t) ? t : [t]).length; c < h; c++)
            n(t[c]);
        this.addAttribute("position", new z(o,3)),
        this.addAttribute("uv", new z(s,2)),
        this.computeVertexNormals()
    }
    function di(t, e, i) {
        if (i.shapes = [],
        Array.isArray(t))
            for (var n = 0, r = t.length; n < r; n++)
                i.shapes.push(t[n].uuid);
        else
            i.shapes.push(t.uuid);
        return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()),
        i
    }
    function fi(t, e) {
        E.call(this),
        this.type = "TextGeometry",
        this.parameters = {
            text: t,
            parameters: e
        },
        this.fromBufferGeometry(new mi(t,e)),
        this.mergeVertices()
    }
    function mi(t, e) {
        var i = (e = e || {}).font;
        if (!i || !i.isFont)
            return new E;
        t = i.generateShapes(t, e.size),
        e.depth = void 0 !== e.height ? e.height : 50,
        void 0 === e.bevelThickness && (e.bevelThickness = 10),
        void 0 === e.bevelSize && (e.bevelSize = 8),
        void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
        pi.call(this, t, e),
        this.type = "TextBufferGeometry"
    }
    function gi(t, e, i, n, r, a, o) {
        E.call(this),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: a,
            thetaLength: o
        },
        this.fromBufferGeometry(new vi(t,e,i,n,r,a,o)),
        this.mergeVertices()
    }
    function vi(t, e, i, n, a, o, s) {
        U.call(this),
        this.type = "SphereBufferGeometry",
        this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: i,
            phiStart: n,
            phiLength: a,
            thetaStart: o,
            thetaLength: s
        },
        t = t || 1,
        e = Math.max(3, Math.floor(e) || 8),
        i = Math.max(2, Math.floor(i) || 6),
        n = void 0 !== n ? n : 0,
        a = void 0 !== a ? a : 2 * Math.PI;
        var c, h, l = (o = void 0 !== o ? o : 0) + (s = void 0 !== s ? s : Math.PI), u = 0, p = [], d = new r, f = new r, m = [], g = [], v = [], y = [];
        for (h = 0; h <= i; h++) {
            var x = []
              , b = h / i
              , w = 0 == h ? .5 / e : h == i ? -.5 / e : 0;
            for (c = 0; c <= e; c++) {
                var M = c / e;
                d.x = -t * Math.cos(n + M * a) * Math.sin(o + b * s),
                d.y = t * Math.cos(o + b * s),
                d.z = t * Math.sin(n + M * a) * Math.sin(o + b * s),
                g.push(d.x, d.y, d.z),
                f.copy(d).normalize(),
                v.push(f.x, f.y, f.z),
                y.push(M + w, 1 - b),
                x.push(u++)
            }
            p.push(x)
        }
        for (h = 0; h < i; h++)
            for (c = 0; c < e; c++)
                t = p[h][c + 1],
                n = p[h][c],
                a = p[h + 1][c],
                s = p[h + 1][c + 1],
                (0 !== h || 0 < o) && m.push(t, n, s),
                (h !== i - 1 || l < Math.PI) && m.push(n, a, s);
        this.setIndex(m),
        this.addAttribute("position", new z(g,3)),
        this.addAttribute("normal", new z(v,3)),
        this.addAttribute("uv", new z(y,2))
    }
    function yi(t, e, i, n, r, a) {
        E.call(this),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: a
        },
        this.fromBufferGeometry(new xi(t,e,i,n,r,a)),
        this.mergeVertices()
    }
    function xi(t, e, n, a, o, s) {
        U.call(this),
        this.type = "RingBufferGeometry",
        this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: a,
            thetaStart: o,
            thetaLength: s
        },
        t = t || .5,
        e = e || 1,
        o = void 0 !== o ? o : 0,
        s = void 0 !== s ? s : 2 * Math.PI,
        n = void 0 !== n ? Math.max(3, n) : 8;
        var c, h, l = [], u = [], p = [], d = [], f = t, m = (e - t) / (a = void 0 !== a ? Math.max(1, a) : 1), g = new r, v = new i;
        for (c = 0; c <= a; c++) {
            for (h = 0; h <= n; h++)
                t = o + h / n * s,
                g.x = f * Math.cos(t),
                g.y = f * Math.sin(t),
                u.push(g.x, g.y, g.z),
                p.push(0, 0, 1),
                v.x = (g.x / e + 1) / 2,
                v.y = (g.y / e + 1) / 2,
                d.push(v.x, v.y);
            f += m
        }
        for (c = 0; c < a; c++)
            for (e = c * (n + 1),
            h = 0; h < n; h++)
                o = (t = h + e) + n + 1,
                s = t + n + 2,
                f = t + 1,
                l.push(t, o, f),
                l.push(o, s, f);
        this.setIndex(l),
        this.addAttribute("position", new z(u,3)),
        this.addAttribute("normal", new z(p,3)),
        this.addAttribute("uv", new z(d,2))
    }
    function bi(t, e, i, n) {
        E.call(this),
        this.type = "LatheGeometry",
        this.parameters = {
            points: t,
            segments: e,
            phiStart: i,
            phiLength: n
        },
        this.fromBufferGeometry(new wi(t,e,i,n)),
        this.mergeVertices()
    }
    function wi(t, e, n, a) {
        U.call(this),
        this.type = "LatheBufferGeometry",
        this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: a
        },
        e = Math.floor(e) || 12,
        n = n || 0,
        a = a || 2 * Math.PI,
        a = Vr.clamp(a, 0, 2 * Math.PI);
        var o, s = [], c = [], h = [], l = 1 / e, u = new r, p = new i;
        for (o = 0; o <= e; o++) {
            var d = n + o * l * a
              , f = Math.sin(d)
              , m = Math.cos(d);
            for (d = 0; d <= t.length - 1; d++)
                u.x = t[d].x * f,
                u.y = t[d].y,
                u.z = t[d].x * m,
                c.push(u.x, u.y, u.z),
                p.x = o / e,
                p.y = d / (t.length - 1),
                h.push(p.x, p.y)
        }
        for (o = 0; o < e; o++)
            for (d = 0; d < t.length - 1; d++)
                l = (n = d + o * t.length) + t.length,
                u = n + t.length + 1,
                p = n + 1,
                s.push(n, l, p),
                s.push(l, u, p);
        if (this.setIndex(s),
        this.addAttribute("position", new z(c,3)),
        this.addAttribute("uv", new z(h,2)),
        this.computeVertexNormals(),
        a === 2 * Math.PI)
            for (a = this.attributes.normal.array,
            s = new r,
            c = new r,
            h = new r,
            n = e * t.length * 3,
            d = o = 0; o < t.length; o++,
            d += 3)
                s.x = a[d + 0],
                s.y = a[d + 1],
                s.z = a[d + 2],
                c.x = a[n + d + 0],
                c.y = a[n + d + 1],
                c.z = a[n + d + 2],
                h.addVectors(s, c).normalize(),
                a[d + 0] = a[n + d + 0] = h.x,
                a[d + 1] = a[n + d + 1] = h.y,
                a[d + 2] = a[n + d + 2] = h.z
    }
    function Mi(t, e) {
        E.call(this),
        this.type = "ShapeGeometry",
        "object" == typeof e && (e = e.curveSegments),
        this.parameters = {
            shapes: t,
            curveSegments: e
        },
        this.fromBufferGeometry(new _i(t,e)),
        this.mergeVertices()
    }
    function _i(t, e) {
        function i(t) {
            var i, s = r.length / 3, h = (t = t.extractPoints(e)).shape, l = t.holes;
            for (!1 === va.isClockWise(h) && (h = h.reverse()),
            t = 0,
            i = l.length; t < i; t++) {
                var u = l[t];
                !0 === va.isClockWise(u) && (l[t] = u.reverse())
            }
            var p = va.triangulateShape(h, l);
            for (t = 0,
            i = l.length; t < i; t++)
                u = l[t],
                h = h.concat(u);
            for (t = 0,
            i = h.length; t < i; t++)
                u = h[t],
                r.push(u.x, u.y, 0),
                a.push(0, 0, 1),
                o.push(u.x, u.y);
            for (t = 0,
            i = p.length; t < i; t++)
                h = p[t],
                n.push(h[0] + s, h[1] + s, h[2] + s),
                c += 3
        }
        U.call(this),
        this.type = "ShapeBufferGeometry",
        this.parameters = {
            shapes: t,
            curveSegments: e
        },
        e = e || 12;
        var n = []
          , r = []
          , a = []
          , o = []
          , s = 0
          , c = 0;
        if (!1 === Array.isArray(t))
            i(t);
        else
            for (var h = 0; h < t.length; h++)
                i(t[h]),
                this.addGroup(s, c, h),
                s += c,
                c = 0;
        this.setIndex(n),
        this.addAttribute("position", new z(r,3)),
        this.addAttribute("normal", new z(a,3)),
        this.addAttribute("uv", new z(o,2))
    }
    function Si(t, e) {
        if (e.shapes = [],
        Array.isArray(t))
            for (var i = 0, n = t.length; i < n; i++)
                e.shapes.push(t[i].uuid);
        else
            e.shapes.push(t.uuid);
        return e
    }
    function Ti(t, e) {
        U.call(this),
        this.type = "EdgesGeometry",
        this.parameters = {
            thresholdAngle: e
        };
        var i = [];
        e = Math.cos(Vr.DEG2RAD * (void 0 !== e ? e : 1));
        var n = [0, 0]
          , r = {}
          , a = ["a", "b", "c"];
        if (t.isBufferGeometry) {
            var o = new E;
            o.fromBufferGeometry(t)
        } else
            o = t.clone();
        o.mergeVertices(),
        o.computeFaceNormals(),
        t = o.vertices;
        for (var s = 0, c = (o = o.faces).length; s < c; s++)
            for (var h = o[s], l = 0; 3 > l; l++) {
                var u = h[a[l]]
                  , p = h[a[(l + 1) % 3]];
                n[0] = Math.min(u, p),
                n[1] = Math.max(u, p),
                void 0 === r[u = n[0] + "," + n[1]] ? r[u] = {
                    index1: n[0],
                    index2: n[1],
                    face1: s,
                    face2: void 0
                } : r[u].face2 = s
            }
        for (u in r)
            (void 0 === (n = r[u]).face2 || o[n.face1].normal.dot(o[n.face2].normal) <= e) && (a = t[n.index1],
            i.push(a.x, a.y, a.z),
            a = t[n.index2],
            i.push(a.x, a.y, a.z));
        this.addAttribute("position", new z(i,3))
    }
    function Ei(t, e, i, n, r, a, o, s) {
        E.call(this),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: a,
            thetaStart: o,
            thetaLength: s
        },
        this.fromBufferGeometry(new Ai(t,e,i,n,r,a,o,s)),
        this.mergeVertices()
    }
    function Ai(t, e, n, a, o, s, c, h) {
        function l(n) {
            var o, s = new i, l = new r, v = 0, b = !0 === n ? t : e, w = !0 === n ? 1 : -1, M = g;
            for (o = 1; o <= a; o++)
                d.push(0, y * w, 0),
                f.push(0, w, 0),
                m.push(.5, .5),
                g++;
            var _ = g;
            for (o = 0; o <= a; o++) {
                var S = o / a * h + c
                  , T = Math.cos(S);
                S = Math.sin(S),
                l.x = b * S,
                l.y = y * w,
                l.z = b * T,
                d.push(l.x, l.y, l.z),
                f.push(0, w, 0),
                s.x = .5 * T + .5,
                s.y = .5 * S * w + .5,
                m.push(s.x, s.y),
                g++
            }
            for (o = 0; o < a; o++)
                s = M + o,
                l = _ + o,
                !0 === n ? p.push(l, l + 1, s) : p.push(l + 1, l, s),
                v += 3;
            u.addGroup(x, v, !0 === n ? 1 : 2),
            x += v
        }
        U.call(this),
        this.type = "CylinderBufferGeometry",
        this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: a,
            heightSegments: o,
            openEnded: s,
            thetaStart: c,
            thetaLength: h
        };
        var u = this;
        t = void 0 !== t ? t : 1,
        e = void 0 !== e ? e : 1,
        n = n || 1,
        a = Math.floor(a) || 8,
        o = Math.floor(o) || 1,
        s = void 0 !== s && s,
        c = void 0 !== c ? c : 0,
        h = void 0 !== h ? h : 2 * Math.PI;
        var p = []
          , d = []
          , f = []
          , m = []
          , g = 0
          , v = []
          , y = n / 2
          , x = 0;
        !function() {
            var i, s, l = new r, b = new r, w = 0, M = (e - t) / n;
            for (s = 0; s <= o; s++) {
                var _ = []
                  , S = s / o
                  , T = S * (e - t) + t;
                for (i = 0; i <= a; i++) {
                    var E = i / a
                      , A = E * h + c
                      , L = Math.sin(A);
                    A = Math.cos(A),
                    b.x = T * L,
                    b.y = -S * n + y,
                    b.z = T * A,
                    d.push(b.x, b.y, b.z),
                    l.set(L, M, A).normalize(),
                    f.push(l.x, l.y, l.z),
                    m.push(E, 1 - S),
                    _.push(g++)
                }
                v.push(_)
            }
            for (i = 0; i < a; i++)
                for (s = 0; s < o; s++)
                    l = v[s + 1][i],
                    b = v[s + 1][i + 1],
                    M = v[s][i + 1],
                    p.push(v[s][i], l, M),
                    p.push(l, b, M),
                    w += 6;
            u.addGroup(x, w, 0),
            x += w
        }(),
        !1 === s && (0 < t && l(!0),
        0 < e && l(!1)),
        this.setIndex(p),
        this.addAttribute("position", new z(d,3)),
        this.addAttribute("normal", new z(f,3)),
        this.addAttribute("uv", new z(m,2))
    }
    function Li(t, e, i, n, r, a, o) {
        Ei.call(this, 0, t, e, i, n, r, a, o),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: t,
            height: e,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: a,
            thetaLength: o
        }
    }
    function Pi(t, e, i, n, r, a, o) {
        Ai.call(this, 0, t, e, i, n, r, a, o),
        this.type = "ConeBufferGeometry",
        this.parameters = {
            radius: t,
            height: e,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: a,
            thetaLength: o
        }
    }
    function Ci(t, e, i, n) {
        E.call(this),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: t,
            segments: e,
            thetaStart: i,
            thetaLength: n
        },
        this.fromBufferGeometry(new Ii(t,e,i,n)),
        this.mergeVertices()
    }
    function Ii(t, e, n, a) {
        U.call(this),
        this.type = "CircleBufferGeometry",
        this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: a
        },
        t = t || 1,
        e = void 0 !== e ? Math.max(3, e) : 8,
        n = void 0 !== n ? n : 0,
        a = void 0 !== a ? a : 2 * Math.PI;
        var o, s = [], c = [], h = [], l = [], u = new r, p = new i;
        c.push(0, 0, 0),
        h.push(0, 0, 1),
        l.push(.5, .5);
        var d = 0;
        for (o = 3; d <= e; d++,
        o += 3) {
            var f = n + d / e * a;
            u.x = t * Math.cos(f),
            u.y = t * Math.sin(f),
            c.push(u.x, u.y, u.z),
            h.push(0, 0, 1),
            p.x = (c[o] / t + 1) / 2,
            p.y = (c[o + 1] / t + 1) / 2,
            l.push(p.x, p.y)
        }
        for (o = 1; o <= e; o++)
            s.push(o, o + 1, 0);
        this.setIndex(s),
        this.addAttribute("position", new z(c,3)),
        this.addAttribute("normal", new z(h,3)),
        this.addAttribute("uv", new z(l,2))
    }
    function Ri(t) {
        H.call(this),
        this.type = "ShadowMaterial",
        this.color = new x(0),
        this.transparent = !0,
        this.setValues(t)
    }
    function Oi(t) {
        W.call(this, t),
        this.type = "RawShaderMaterial"
    }
    function Di(t) {
        H.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new x(16777215),
        this.metalness = this.roughness = .5,
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new x(0),
        this.emissiveIntensity = 1,
        this.bumpMap = this.emissiveMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new i(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(t)
    }
    function zi(t) {
        Di.call(this),
        this.defines = {
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.reflectivity = .5,
        this.clearCoatRoughness = this.clearCoat = 0,
        this.setValues(t)
    }
    function Bi(t) {
        H.call(this),
        this.type = "MeshPhongMaterial",
        this.color = new x(16777215),
        this.specular = new x(1118481),
        this.shininess = 30,
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new x(0),
        this.emissiveIntensity = 1,
        this.bumpMap = this.emissiveMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new i(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.envMap = this.alphaMap = this.specularMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(t)
    }
    function Ni(t) {
        Bi.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.gradientMap = null,
        this.setValues(t)
    }
    function ki(t) {
        H.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new i(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1,
        this.setValues(t)
    }
    function Ui(t) {
        H.call(this),
        this.type = "MeshLambertMaterial",
        this.color = new x(16777215),
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new x(0),
        this.emissiveIntensity = 1,
        this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(t)
    }
    function Fi(t) {
        H.call(this),
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new x(16777215),
        this.bumpMap = this.map = this.matcap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new i(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.lights = this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(t)
    }
    function Gi(t) {
        xe.call(this),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(t)
    }
    function Vi(t, e, i, n) {
        this.parameterPositions = t,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== n ? n : new e.constructor(i),
        this.sampleValues = e,
        this.valueSize = i
    }
    function ji(t, e, i, n) {
        Vi.call(this, t, e, i, n),
        this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
    }
    function Hi(t, e, i, n) {
        Vi.call(this, t, e, i, n)
    }
    function Wi(t, e, i, n) {
        Vi.call(this, t, e, i, n)
    }
    function Xi(t, e, i, n) {
        if (void 0 === t)
            throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length)
            throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t,
        this.times = wa.convertArray(e, this.TimeBufferType),
        this.values = wa.convertArray(i, this.ValueBufferType),
        this.setInterpolation(n || this.DefaultInterpolation)
    }
    function qi(t, e, i) {
        Xi.call(this, t, e, i)
    }
    function Yi(t, e, i, n) {
        Xi.call(this, t, e, i, n)
    }
    function Ji(t, e, i, n) {
        Xi.call(this, t, e, i, n)
    }
    function Zi(t, e, i, n) {
        Vi.call(this, t, e, i, n)
    }
    function Qi(t, e, i, n) {
        Xi.call(this, t, e, i, n)
    }
    function Ki(t, e, i, n) {
        Xi.call(this, t, e, i, n)
    }
    function $i(t, e, i, n) {
        Xi.call(this, t, e, i, n)
    }
    function tn(t, e, i) {
        this.name = t,
        this.tracks = i,
        this.duration = void 0 !== e ? e : -1,
        this.uuid = Vr.generateUUID(),
        0 > this.duration && this.resetDuration()
    }
    function en(t) {
        if (void 0 === t.type)
            throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var e = function(t) {
            switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Ji;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return $i;
            case "color":
                return Yi;
            case "quaternion":
                return Qi;
            case "bool":
            case "boolean":
                return qi;
            case "string":
                return Ki
            }
            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }(t.type);
        if (void 0 === t.times) {
            var i = []
              , n = [];
            wa.flattenJSON(t.keys, i, n, "value"),
            t.times = i,
            t.values = n
        }
        return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
    }
    function nn(t, e, i) {
        var n = this
          , r = !1
          , a = 0
          , o = 0
          , s = void 0;
        this.onStart = void 0,
        this.onLoad = t,
        this.onProgress = e,
        this.onError = i,
        this.itemStart = function(t) {
            o++,
            !1 === r && void 0 !== n.onStart && n.onStart(t, a, o),
            r = !0
        }
        ,
        this.itemEnd = function(t) {
            a++,
            void 0 !== n.onProgress && n.onProgress(t, a, o),
            a === o && (r = !1,
            void 0 !== n.onLoad) && n.onLoad()
        }
        ,
        this.itemError = function(t) {
            void 0 !== n.onError && n.onError(t)
        }
        ,
        this.resolveURL = function(t) {
            return s ? s(t) : t
        }
        ,
        this.setURLModifier = function(t) {
            return s = t,
            this
        }
    }
    function rn(t) {
        this.manager = void 0 !== t ? t : _a
    }
    function an(t) {
        this.manager = void 0 !== t ? t : _a
    }
    function on(t) {
        this.manager = void 0 !== t ? t : _a,
        this._parser = null
    }
    function sn(t) {
        this.manager = void 0 !== t ? t : _a,
        this._parser = null
    }
    function cn(t) {
        this.manager = void 0 !== t ? t : _a
    }
    function hn(t) {
        this.manager = void 0 !== t ? t : _a
    }
    function ln(t) {
        this.manager = void 0 !== t ? t : _a
    }
    function un() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function pn(t, e, i, n, r, a, o, s) {
        un.call(this),
        this.type = "EllipseCurve",
        this.aX = t || 0,
        this.aY = e || 0,
        this.xRadius = i || 1,
        this.yRadius = n || 1,
        this.aStartAngle = r || 0,
        this.aEndAngle = a || 2 * Math.PI,
        this.aClockwise = o || !1,
        this.aRotation = s || 0
    }
    function dn(t, e, i, n, r, a) {
        pn.call(this, t, e, i, i, n, r, a),
        this.type = "ArcCurve"
    }
    function fn() {
        var t = 0
          , e = 0
          , i = 0
          , n = 0;
        return {
            initCatmullRom: function(r, a, o, s, c) {
                t = a,
                e = r = c * (o - r),
                i = -3 * a + 3 * o - 2 * r - (s = c * (s - a)),
                n = 2 * a - 2 * o + r + s
            },
            initNonuniformCatmullRom: function(r, a, o, s, c, h, l) {
                t = a,
                e = r = ((a - r) / c - (o - r) / (c + h) + (o - a) / h) * h,
                i = -3 * a + 3 * o - 2 * r - (s = ((o - a) / h - (s - a) / (h + l) + (s - o) / l) * h),
                n = 2 * a - 2 * o + r + s
            },
            calc: function(r) {
                var a = r * r;
                return t + e * r + i * a + n * a * r
            }
        }
    }
    function mn(t, e, i, n) {
        un.call(this),
        this.type = "CatmullRomCurve3",
        this.points = t || [],
        this.closed = e || !1,
        this.curveType = i || "centripetal",
        this.tension = n || .5
    }
    function gn(t, e, i, n, r) {
        var a = t * t;
        return (2 * i - 2 * n + (e = .5 * (n - e)) + (r = .5 * (r - i))) * t * a + (-3 * i + 3 * n - 2 * e - r) * a + e * t + i
    }
    function vn(t, e, i, n) {
        var r = 1 - t;
        return r * r * e + 2 * (1 - t) * t * i + t * t * n
    }
    function yn(t, e, i, n, r) {
        var a = 1 - t
          , o = 1 - t;
        return a * a * a * e + 3 * o * o * t * i + 3 * (1 - t) * t * t * n + t * t * t * r
    }
    function xn(t, e, n, r) {
        un.call(this),
        this.type = "CubicBezierCurve",
        this.v0 = t || new i,
        this.v1 = e || new i,
        this.v2 = n || new i,
        this.v3 = r || new i
    }
    function bn(t, e, i, n) {
        un.call(this),
        this.type = "CubicBezierCurve3",
        this.v0 = t || new r,
        this.v1 = e || new r,
        this.v2 = i || new r,
        this.v3 = n || new r
    }
    function wn(t, e) {
        un.call(this),
        this.type = "LineCurve",
        this.v1 = t || new i,
        this.v2 = e || new i
    }
    function Mn(t, e) {
        un.call(this),
        this.type = "LineCurve3",
        this.v1 = t || new r,
        this.v2 = e || new r
    }
    function _n(t, e, n) {
        un.call(this),
        this.type = "QuadraticBezierCurve",
        this.v0 = t || new i,
        this.v1 = e || new i,
        this.v2 = n || new i
    }
    function Sn(t, e, i) {
        un.call(this),
        this.type = "QuadraticBezierCurve3",
        this.v0 = t || new r,
        this.v1 = e || new r,
        this.v2 = i || new r
    }
    function Tn(t) {
        un.call(this),
        this.type = "SplineCurve",
        this.points = t || []
    }
    function En() {
        un.call(this),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    function An(t) {
        En.call(this),
        this.type = "Path",
        this.currentPoint = new i,
        t && this.setFromPoints(t)
    }
    function Ln(t) {
        An.call(this, t),
        this.uuid = Vr.generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    function Pn(t, e) {
        T.call(this),
        this.type = "Light",
        this.color = new x(t),
        this.intensity = void 0 !== e ? e : 1,
        this.receiveShadow = void 0
    }
    function Cn(t, e, i) {
        Pn.call(this, t, i),
        this.type = "HemisphereLight",
        this.castShadow = void 0,
        this.position.copy(T.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new x(e)
    }
    function In(t) {
        this.camera = t,
        this.bias = 0,
        this.radius = 1,
        this.mapSize = new i(512,512),
        this.map = null,
        this.matrix = new g
    }
    function Rn() {
        In.call(this, new ie(50,1,.5,500))
    }
    function On(t, e, i, n, r, a) {
        Pn.call(this, t, e),
        this.type = "SpotLight",
        this.position.copy(T.DefaultUp),
        this.updateMatrix(),
        this.target = new T,
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / Math.PI
            }
        }),
        this.distance = void 0 !== i ? i : 0,
        this.angle = void 0 !== n ? n : Math.PI / 3,
        this.penumbra = void 0 !== r ? r : 0,
        this.decay = void 0 !== a ? a : 1,
        this.shadow = new Rn
    }
    function Dn(t, e, i, n) {
        Pn.call(this, t, e),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== i ? i : 0,
        this.decay = void 0 !== n ? n : 1,
        this.shadow = new In(new ie(90,1,.5,500))
    }
    function zn(t, e, i, n, r, a) {
        ee.call(this),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = void 0 !== t ? t : -1,
        this.right = void 0 !== e ? e : 1,
        this.top = void 0 !== i ? i : 1,
        this.bottom = void 0 !== n ? n : -1,
        this.near = void 0 !== r ? r : .1,
        this.far = void 0 !== a ? a : 2e3,
        this.updateProjectionMatrix()
    }
    function Bn() {
        In.call(this, new zn(-5,5,5,-5,.5,500))
    }
    function Nn(t, e) {
        Pn.call(this, t, e),
        this.type = "DirectionalLight",
        this.position.copy(T.DefaultUp),
        this.updateMatrix(),
        this.target = new T,
        this.shadow = new Bn
    }
    function kn(t, e) {
        Pn.call(this, t, e),
        this.type = "AmbientLight",
        this.castShadow = void 0
    }
    function Un(t, e, i, n) {
        Pn.call(this, t, e),
        this.type = "RectAreaLight",
        this.width = void 0 !== i ? i : 10,
        this.height = void 0 !== n ? n : 10
    }
    function Fn(t) {
        this.manager = void 0 !== t ? t : _a,
        this.textures = {}
    }
    function Gn(t) {
        this.manager = void 0 !== t ? t : _a
    }
    function Vn(t) {
        this.manager = void 0 !== t ? t : _a,
        this.resourcePath = ""
    }
    function jn(t) {
        this.manager = void 0 !== t ? t : _a,
        this.options = void 0
    }
    function Hn() {
        this.type = "ShapePath",
        this.color = new x,
        this.subPaths = [],
        this.currentPath = null
    }
    function Wn(t) {
        this.type = "Font",
        this.data = t
    }
    function Xn(t) {
        this.manager = void 0 !== t ? t : _a
    }
    function qn() {}
    function Yn(t) {
        this.manager = void 0 !== t ? t : _a
    }
    function Jn() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new ie,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new ie,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1
    }
    function Zn(t, e, i, n) {
        T.call(this),
        this.type = "CubeCamera";
        var a = new ie(90,1,t,e);
        a.up.set(0, -1, 0),
        a.lookAt(new r(1,0,0)),
        this.add(a);
        var o = new ie(90,1,t,e);
        o.up.set(0, -1, 0),
        o.lookAt(new r(-1,0,0)),
        this.add(o);
        var s = new ie(90,1,t,e);
        s.up.set(0, 0, 1),
        s.lookAt(new r(0,1,0)),
        this.add(s);
        var c = new ie(90,1,t,e);
        c.up.set(0, 0, -1),
        c.lookAt(new r(0,-1,0)),
        this.add(c);
        var h = new ie(90,1,t,e);
        h.up.set(0, -1, 0),
        h.lookAt(new r(0,0,1)),
        this.add(h);
        var u = new ie(90,1,t,e);
        u.up.set(0, -1, 0),
        u.lookAt(new r(0,0,-1)),
        this.add(u),
        n = n || {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        },
        this.renderTarget = new l(i,i,n),
        this.renderTarget.texture.name = "CubeCamera",
        this.update = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            var i = t.getRenderTarget()
              , n = this.renderTarget
              , r = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1,
            t.setRenderTarget(n, 0),
            t.render(e, a),
            t.setRenderTarget(n, 1),
            t.render(e, o),
            t.setRenderTarget(n, 2),
            t.render(e, s),
            t.setRenderTarget(n, 3),
            t.render(e, c),
            t.setRenderTarget(n, 4),
            t.render(e, h),
            n.texture.generateMipmaps = r,
            t.setRenderTarget(n, 5),
            t.render(e, u),
            t.setRenderTarget(i)
        }
        ,
        this.clear = function(t, e, i, n) {
            for (var r = t.getRenderTarget(), a = this.renderTarget, o = 0; 6 > o; o++)
                t.setRenderTarget(a, o),
                t.clear(e, i, n);
            t.setRenderTarget(r)
        }
    }
    function Qn(t) {
        this.autoStart = void 0 === t || t,
        this.elapsedTime = this.oldTime = this.startTime = 0,
        this.running = !1
    }
    function Kn() {
        T.call(this),
        this.type = "AudioListener",
        this.context = ka.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0
    }
    function $n(t) {
        T.call(this),
        this.type = "Audio",
        this.listener = t,
        this.context = t.context,
        this.gain = this.context.createGain(),
        this.gain.connect(t.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.offset = this.startTime = 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.sourceType = "empty",
        this.filters = []
    }
    function tr(t) {
        $n.call(this, t),
        this.panner = this.context.createPanner(),
        this.panner.connect(this.gain)
    }
    function er(t, e) {
        this.analyser = t.context.createAnalyser(),
        this.analyser.fftSize = void 0 !== e ? e : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        t.getOutput().connect(this.analyser)
    }
    function ir(t, e, i) {
        switch (this.binding = t,
        this.valueSize = i,
        t = Float64Array,
        e) {
        case "quaternion":
            e = this._slerp;
            break;
        case "string":
        case "bool":
            t = Array,
            e = this._select;
            break;
        default:
            e = this._lerp
        }
        this.buffer = new t(4 * i),
        this._mixBufferRegion = e,
        this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }
    function nr(t, e, i) {
        i = i || rr.parseTrackName(e),
        this._targetGroup = t,
        this._bindings = t.subscribe_(e, i)
    }
    function rr(t, e, i) {
        this.path = e,
        this.parsedPath = i || rr.parseTrackName(e),
        this.node = rr.findNode(t, this.parsedPath.nodeName) || t,
        this.rootNode = t
    }
    function ar() {
        this.uuid = Vr.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var t = {};
        this._indicesByUUID = t;
        for (var e = 0, i = arguments.length; e !== i; ++e)
            t[arguments[e].uuid] = e;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                },
                get inUse() {
                    return this.total - n.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }
    function or(t, e, i) {
        this._mixer = t,
        this._clip = e,
        this._localRoot = i || null,
        e = (t = e.tracks).length,
        i = Array(e);
        for (var n = {
            endingStart: 2400,
            endingEnd: 2400
        }, r = 0; r !== e; ++r) {
            var a = t[r].createInterpolant(null);
            i[r] = a,
            a.settings = n
        }
        this._interpolantSettings = n,
        this._interpolants = i,
        this._propertyBindings = Array(e),
        this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null,
        this.loop = 2201,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }
    function sr(t) {
        this._root = t,
        this._initMemoryManager(),
        this.time = this._accuIndex = 0,
        this.timeScale = 1
    }
    function cr(t, e) {
        "string" == typeof t && (t = e),
        this.value = t
    }
    function hr() {
        U.call(this),
        this.type = "InstancedBufferGeometry",
        this.maxInstancedCount = void 0
    }
    function lr(t, e, i) {
        ue.call(this, t, e),
        this.meshPerAttribute = i || 1
    }
    function ur(t, e, i, n) {
        "number" == typeof i && (n = i,
        i = !1),
        A.call(this, t, e, i),
        this.meshPerAttribute = n || 1
    }
    function pr(t, e, i, n) {
        this.ray = new X(t,e),
        this.near = i || 0,
        this.far = n || 1 / 0,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return this.Points
                }
            }
        })
    }
    function dr(t, e) {
        return t.distance - e.distance
    }
    function fr(t, e, i, n) {
        if (!1 !== t.visible && (t.raycast(e, i),
        !0 === n)) {
            n = 0;
            for (var r = (t = t.children).length; n < r; n++)
                fr(t[n], e, i, !0)
        }
    }
    function mr(t, e, i) {
        return this.radius = void 0 !== t ? t : 1,
        this.phi = void 0 !== e ? e : 0,
        this.theta = void 0 !== i ? i : 0,
        this
    }
    function gr(t, e, i) {
        return this.radius = void 0 !== t ? t : 1,
        this.theta = void 0 !== e ? e : 0,
        this.y = void 0 !== i ? i : 0,
        this
    }
    function vr(t, e) {
        this.min = void 0 !== t ? t : new i(1 / 0,1 / 0),
        this.max = void 0 !== e ? e : new i(-1 / 0,-1 / 0)
    }
    function yr(t, e) {
        this.start = void 0 !== t ? t : new r,
        this.end = void 0 !== e ? e : new r
    }
    function xr(t) {
        T.call(this),
        this.material = t,
        this.render = function() {}
    }
    function br(t, e, i, n) {
        this.object = t,
        this.size = void 0 !== e ? e : 1,
        t = void 0 !== i ? i : 16711680,
        n = void 0 !== n ? n : 1,
        e = 0,
        (i = this.object.geometry) && i.isGeometry ? e = 3 * i.faces.length : i && i.isBufferGeometry && (e = i.attributes.normal.count),
        i = new U,
        e = new z(6 * e,3),
        i.addAttribute("position", e),
        we.call(this, i, new xe({
            color: t,
            linewidth: n
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function wr(t, e) {
        T.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = e,
        t = new U,
        e = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var i = 0, n = 1; 32 > i; i++,
        n++) {
            var r = i / 32 * Math.PI * 2
              , a = n / 32 * Math.PI * 2;
            e.push(Math.cos(r), Math.sin(r), 1, Math.cos(a), Math.sin(a), 1)
        }
        t.addAttribute("position", new z(e,3)),
        e = new xe({
            fog: !1
        }),
        this.cone = new we(t,e),
        this.add(this.cone),
        this.update()
    }
    function Mr(t) {
        for (var e = function t(e) {
            var i = [];
            e && e.isBone && i.push(e);
            for (var n = 0; n < e.children.length; n++)
                i.push.apply(i, t(e.children[n]));
            return i
        }(t), i = new U, n = [], r = [], a = new x(0,0,1), o = new x(0,1,0), s = 0; s < e.length; s++) {
            var c = e[s];
            c.parent && c.parent.isBone && (n.push(0, 0, 0),
            n.push(0, 0, 0),
            r.push(a.r, a.g, a.b),
            r.push(o.r, o.g, o.b))
        }
        i.addAttribute("position", new z(n,3)),
        i.addAttribute("color", new z(r,3)),
        n = new xe({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }),
        we.call(this, i, n),
        this.root = t,
        this.bones = e,
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    function _r(t, e, i) {
        this.light = t,
        this.light.updateMatrixWorld(),
        this.color = i,
        t = new vi(e,4,2),
        e = new Y({
            wireframe: !0,
            fog: !1
        }),
        J.call(this, t, e),
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Sr(t, e) {
        this.type = "RectAreaLightHelper",
        this.light = t,
        this.color = e,
        (t = new U).addAttribute("position", new z([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],3)),
        t.computeBoundingSphere(),
        e = new xe({
            fog: !1
        }),
        be.call(this, t, e),
        (t = new U).addAttribute("position", new z([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],3)),
        t.computeBoundingSphere(),
        this.add(new J(t,new Y({
            side: 1,
            fog: !1
        }))),
        this.update()
    }
    function Tr(t, e, i) {
        T.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        (t = new Ne(e)).rotateY(.5 * Math.PI),
        this.material = new Y({
            wireframe: !0,
            fog: !1
        }),
        void 0 === this.color && (this.material.vertexColors = 2),
        e = t.getAttribute("position"),
        e = new Float32Array(3 * e.count),
        t.addAttribute("color", new A(e,3)),
        this.add(new J(t,this.material)),
        this.update()
    }
    function Er(t, e, i, n) {
        t = t || 10,
        e = e || 10,
        i = new x(void 0 !== i ? i : 4473924),
        n = new x(void 0 !== n ? n : 8947848);
        var r = e / 2
          , a = t / e
          , o = t / 2;
        t = [];
        for (var s = [], c = 0, h = 0, l = -o; c <= e; c++,
        l += a) {
            t.push(-o, 0, l, o, 0, l),
            t.push(l, 0, -o, l, 0, o);
            var u = c === r ? i : n;
            u.toArray(s, h),
            h += 3,
            u.toArray(s, h),
            h += 3,
            u.toArray(s, h),
            h += 3,
            u.toArray(s, h),
            h += 3
        }
        (e = new U).addAttribute("position", new z(t,3)),
        e.addAttribute("color", new z(s,3)),
        i = new xe({
            vertexColors: 2
        }),
        we.call(this, e, i)
    }
    function Ar(t, e, i, n, r, a) {
        t = t || 10,
        e = e || 16,
        i = i || 8,
        n = n || 64,
        r = new x(void 0 !== r ? r : 4473924),
        a = new x(void 0 !== a ? a : 8947848);
        var o, s = [], c = [];
        for (o = 0; o <= e; o++) {
            var h = o / e * 2 * Math.PI
              , l = Math.sin(h) * t;
            h = Math.cos(h) * t,
            s.push(0, 0, 0),
            s.push(l, 0, h);
            var u = 1 & o ? r : a;
            c.push(u.r, u.g, u.b),
            c.push(u.r, u.g, u.b)
        }
        for (o = 0; o <= i; o++) {
            u = 1 & o ? r : a;
            var p = t - t / i * o;
            for (e = 0; e < n; e++)
                h = e / n * 2 * Math.PI,
                l = Math.sin(h) * p,
                h = Math.cos(h) * p,
                s.push(l, 0, h),
                c.push(u.r, u.g, u.b),
                h = (e + 1) / n * 2 * Math.PI,
                l = Math.sin(h) * p,
                h = Math.cos(h) * p,
                s.push(l, 0, h),
                c.push(u.r, u.g, u.b)
        }
        (t = new U).addAttribute("position", new z(s,3)),
        t.addAttribute("color", new z(c,3)),
        s = new xe({
            vertexColors: 2
        }),
        we.call(this, t, s)
    }
    function Lr(t, e, i, n) {
        this.audio = t,
        this.range = e || 1,
        this.divisionsInnerAngle = i || 16,
        this.divisionsOuterAngle = n || 2,
        t = new U,
        e = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3)),
        t.addAttribute("position", new A(e,3)),
        e = new xe({
            color: 65280
        }),
        i = new xe({
            color: 16776960
        }),
        be.call(this, t, [i, e]),
        this.update()
    }
    function Pr(t, e, i, n) {
        this.object = t,
        this.size = void 0 !== e ? e : 1,
        t = void 0 !== i ? i : 16776960,
        n = void 0 !== n ? n : 1,
        e = 0,
        (i = this.object.geometry) && i.isGeometry && (e = i.faces.length),
        i = new U,
        e = new z(6 * e,3),
        i.addAttribute("position", e),
        we.call(this, i, new xe({
            color: t,
            linewidth: n
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Cr(t, e, i) {
        T.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        void 0 === e && (e = 1),
        (t = new U).addAttribute("position", new z([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0],3)),
        e = new xe({
            fog: !1
        }),
        this.lightPlane = new be(t,e),
        this.add(this.lightPlane),
        (t = new U).addAttribute("position", new z([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new be(t,e),
        this.add(this.targetLine),
        this.update()
    }
    function Ir(t) {
        function e(t, e, n) {
            i(t, n),
            i(e, n)
        }
        function i(t, e) {
            a.push(0, 0, 0),
            o.push(e.r, e.g, e.b),
            void 0 === s[t] && (s[t] = []),
            s[t].push(a.length / 3 - 1)
        }
        var n = new U
          , r = new xe({
            color: 16777215,
            vertexColors: 1
        })
          , a = []
          , o = []
          , s = {}
          , c = new x(16755200)
          , h = new x(16711680)
          , l = new x(43775)
          , u = new x(16777215)
          , p = new x(3355443);
        e("n1", "n2", c),
        e("n2", "n4", c),
        e("n4", "n3", c),
        e("n3", "n1", c),
        e("f1", "f2", c),
        e("f2", "f4", c),
        e("f4", "f3", c),
        e("f3", "f1", c),
        e("n1", "f1", c),
        e("n2", "f2", c),
        e("n3", "f3", c),
        e("n4", "f4", c),
        e("p", "n1", h),
        e("p", "n2", h),
        e("p", "n3", h),
        e("p", "n4", h),
        e("u1", "u2", l),
        e("u2", "u3", l),
        e("u3", "u1", l),
        e("c", "t", u),
        e("p", "c", p),
        e("cn1", "cn2", p),
        e("cn3", "cn4", p),
        e("cf1", "cf2", p),
        e("cf3", "cf4", p),
        n.addAttribute("position", new z(a,3)),
        n.addAttribute("color", new z(o,3)),
        we.call(this, n, r),
        this.camera = t,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = s,
        this.update()
    }
    function Rr(t, e) {
        this.object = t,
        void 0 === e && (e = 16776960),
        t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new Float32Array(24)
          , n = new U;
        n.setIndex(new A(t,1)),
        n.addAttribute("position", new A(i,3)),
        we.call(this, n, new xe({
            color: e
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Or(t, e) {
        this.type = "Box3Helper",
        this.box = t,
        t = void 0 !== e ? e : 16776960,
        e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new U;
        i.setIndex(new A(e,1)),
        i.addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
        we.call(this, i, new xe({
            color: t
        })),
        this.geometry.computeBoundingSphere()
    }
    function Dr(t, e, i) {
        this.type = "PlaneHelper",
        this.plane = t,
        this.size = void 0 === e ? 1 : e,
        t = void 0 !== i ? i : 16776960,
        (e = new U).addAttribute("position", new z([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
        e.computeBoundingSphere(),
        be.call(this, e, new xe({
            color: t
        })),
        (e = new U).addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
        e.computeBoundingSphere(),
        this.add(new J(e,new Y({
            color: t,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }
    function zr(t, e, i, n, a, o) {
        T.call(this),
        void 0 === t && (t = new r(0,0,1)),
        void 0 === e && (e = new r(0,0,0)),
        void 0 === i && (i = 1),
        void 0 === n && (n = 16776960),
        void 0 === a && (a = .2 * i),
        void 0 === o && (o = .2 * a),
        void 0 === Ba && ((Ba = new U).addAttribute("position", new z([0, 0, 0, 0, 1, 0],3)),
        (Na = new Ai(0,.5,1,5,1)).translate(0, -.5, 0)),
        this.position.copy(e),
        this.line = new be(Ba,new xe({
            color: n
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new J(Na,new Y({
            color: n
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(t),
        this.setLength(i, a, o)
    }
    function Br(t) {
        var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t];
        (t = new U).addAttribute("position", new z(e,3)),
        t.addAttribute("color", new z([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3)),
        e = new xe({
            vertexColors: 2
        }),
        we.call(this, t, e)
    }
    function Nr(t) {
        mn.call(this, t),
        this.type = "catmullrom",
        this.closed = !0
    }
    function kr(t) {
        mn.call(this, t),
        this.type = "catmullrom"
    }
    function Ur(t) {
        mn.call(this, t),
        this.type = "catmullrom"
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger && (Number.isInteger = function(t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t
    }
    ),
    void 0 === Math.sign && (Math.sign = function(t) {
        return 0 > t ? -1 : 0 < t ? 1 : +t
    }
    ),
    !1 == "name"in Function.prototype && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }),
    void 0 === Object.assign && (Object.assign = function(t) {
        if (void 0 === t || null === t)
            throw new TypeError("Cannot convert undefined or null to object");
        for (var e = Object(t), i = 1; i < arguments.length; i++) {
            var n = arguments[i];
            if (void 0 !== n && null !== n)
                for (var r in n)
                    Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }
    ),
    Object.assign(e.prototype, {
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[t] && (i[t] = []),
            -1 === i[t].indexOf(e) && i[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners)
                return !1;
            var i = this._listeners;
            return void 0 !== i[t] && -1 !== i[t].indexOf(e)
        },
        removeEventListener: function(t, e) {
            void 0 !== this._listeners && (void 0 !== (t = this._listeners[t]) && (-1 !== (e = t.indexOf(e)) && t.splice(e, 1)))
        },
        dispatchEvent: function(t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    for (var i = 0, n = (e = e.slice(0)).length; i < n; i++)
                        e[i].call(this, t)
                }
            }
        }
    });
    var Fr, Gr, Vr = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var t = [], e = 0; 256 > e; e++)
                t[e] = (16 > e ? "0" : "") + e.toString(16);
            return function() {
                var e = 4294967295 * Math.random() | 0
                  , i = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0
                  , r = 4294967295 * Math.random() | 0;
                return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & i] + t[i >> 8 & 255] + "-" + t[i >> 16 & 15 | 64] + t[i >> 24 & 255] + "-" + t[63 & n | 128] + t[n >> 8 & 255] + "-" + t[n >> 16 & 255] + t[n >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >> 16 & 255] + t[r >> 24 & 255]).toUpperCase()
            }
        }(),
        clamp: function(t, e, i) {
            return Math.max(e, Math.min(i, t))
        },
        euclideanModulo: function(t, e) {
            return (t % e + e) % e
        },
        mapLinear: function(t, e, i, n, r) {
            return n + (t - e) * (r - n) / (i - e)
        },
        lerp: function(t, e, i) {
            return (1 - i) * t + i * e
        },
        smoothstep: function(t, e, i) {
            return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
        },
        smootherstep: function(t, e, i) {
            return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function(t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function(t) {
            return t * (.5 - Math.random())
        },
        degToRad: function(t) {
            return t * Vr.DEG2RAD
        },
        radToDeg: function(t) {
            return t * Vr.RAD2DEG
        },
        isPowerOfTwo: function(t) {
            return 0 == (t & t - 1) && 0 !== t
        },
        ceilPowerOfTwo: function(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        },
        floorPowerOfTwo: function(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
    };
    Object.defineProperties(i.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }
    }),
    Object.assign(i.prototype, {
        isVector2: !0,
        set: function(t, e) {
            return this.x = t,
            this.y = e,
            this
        },
        setScalar: function(t) {
            return this.y = this.x = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x,
            this.y += t.y,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x,
            this.y -= t.y,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this
        },
        multiply: function(t) {
            return this.x *= t.x,
            this.y *= t.y,
            this
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this
        },
        divide: function(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        applyMatrix3: function(t) {
            var e = this.x
              , i = this.y;
            return t = t.elements,
            this.x = t[0] * e + t[3] * i + t[6],
            this.y = t[1] * e + t[4] * i + t[7],
            this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this
        },
        clampScalar: (Fr = new i,
        Gr = new i,
        function(t, e) {
            return Fr.set(t, t),
            Gr.set(e, e),
            this.clamp(Fr, Gr)
        }
        ),
        clampLength: function(t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        cross: function(t) {
            return this.x * t.y - this.y * t.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var t = Math.atan2(this.y, this.x);
            return 0 > t && (t += 2 * Math.PI),
            t
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x;
            return e * e + (t = this.y - t.y) * t
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this
        },
        lerpVectors: function(t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t
        },
        fromBufferAttribute: function(t, e) {
            return this.x = t.getX(e),
            this.y = t.getY(e),
            this
        },
        rotateAround: function(t, e) {
            var i = Math.cos(e);
            e = Math.sin(e);
            var n = this.x - t.x
              , r = this.y - t.y;
            return this.x = n * i - r * e + t.x,
            this.y = n * e + r * i + t.y,
            this
        }
    }),
    Object.assign(n, {
        slerp: function(t, e, i, n) {
            return i.copy(t).slerp(e, n)
        },
        slerpFlat: function(t, e, i, n, r, a, o) {
            var s = i[n + 0]
              , c = i[n + 1]
              , h = i[n + 2];
            i = i[n + 3],
            n = r[a + 0];
            var l = r[a + 1]
              , u = r[a + 2];
            if (i !== (r = r[a + 3]) || s !== n || c !== l || h !== u) {
                a = 1 - o;
                var p = s * n + c * l + h * u + i * r
                  , d = 0 <= p ? 1 : -1
                  , f = 1 - p * p;
                f > Number.EPSILON && (f = Math.sqrt(f),
                p = Math.atan2(f, p * d),
                a = Math.sin(a * p) / f,
                o = Math.sin(o * p) / f),
                s = s * a + n * (d *= o),
                c = c * a + l * d,
                h = h * a + u * d,
                i = i * a + r * d,
                a === 1 - o && (s *= o = 1 / Math.sqrt(s * s + c * c + h * h + i * i),
                c *= o,
                h *= o,
                i *= o)
            }
            t[e] = s,
            t[e + 1] = c,
            t[e + 2] = h,
            t[e + 3] = i
        }
    }),
    Object.defineProperties(n.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t,
                this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(t) {
                this._w = t,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(n.prototype, {
        isQuaternion: !0,
        set: function(t, e, i, n) {
            return this._x = t,
            this._y = e,
            this._z = i,
            this._w = n,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        },
        copy: function(t) {
            return this._x = t.x,
            this._y = t.y,
            this._z = t.z,
            this._w = t.w,
            this.onChangeCallback(),
            this
        },
        setFromEuler: function(t, e) {
            if (!t || !t.isEuler)
                throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var i = t._x
              , n = t._y
              , r = t._z;
            t = t.order;
            var a = Math.cos
              , o = Math.sin
              , s = a(i / 2)
              , c = a(n / 2);
            return a = a(r / 2),
            i = o(i / 2),
            n = o(n / 2),
            r = o(r / 2),
            "XYZ" === t ? (this._x = i * c * a + s * n * r,
            this._y = s * n * a - i * c * r,
            this._z = s * c * r + i * n * a,
            this._w = s * c * a - i * n * r) : "YXZ" === t ? (this._x = i * c * a + s * n * r,
            this._y = s * n * a - i * c * r,
            this._z = s * c * r - i * n * a,
            this._w = s * c * a + i * n * r) : "ZXY" === t ? (this._x = i * c * a - s * n * r,
            this._y = s * n * a + i * c * r,
            this._z = s * c * r + i * n * a,
            this._w = s * c * a - i * n * r) : "ZYX" === t ? (this._x = i * c * a - s * n * r,
            this._y = s * n * a + i * c * r,
            this._z = s * c * r - i * n * a,
            this._w = s * c * a + i * n * r) : "YZX" === t ? (this._x = i * c * a + s * n * r,
            this._y = s * n * a + i * c * r,
            this._z = s * c * r - i * n * a,
            this._w = s * c * a - i * n * r) : "XZY" === t && (this._x = i * c * a - s * n * r,
            this._y = s * n * a - i * c * r,
            this._z = s * c * r + i * n * a,
            this._w = s * c * a + i * n * r),
            !1 !== e && this.onChangeCallback(),
            this
        },
        setFromAxisAngle: function(t, e) {
            e /= 2;
            var i = Math.sin(e);
            return this._x = t.x * i,
            this._y = t.y * i,
            this._z = t.z * i,
            this._w = Math.cos(e),
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(t) {
            var e = t.elements
              , i = e[0];
            t = e[4];
            var n = e[8]
              , r = e[1]
              , a = e[5]
              , o = e[9]
              , s = e[2]
              , c = e[6]
              , h = i + a + (e = e[10]);
            return 0 < h ? (i = .5 / Math.sqrt(h + 1),
            this._w = .25 / i,
            this._x = (c - o) * i,
            this._y = (n - s) * i,
            this._z = (r - t) * i) : i > a && i > e ? (i = 2 * Math.sqrt(1 + i - a - e),
            this._w = (c - o) / i,
            this._x = .25 * i,
            this._y = (t + r) / i,
            this._z = (n + s) / i) : a > e ? (i = 2 * Math.sqrt(1 + a - i - e),
            this._w = (n - s) / i,
            this._x = (t + r) / i,
            this._y = .25 * i,
            this._z = (o + c) / i) : (i = 2 * Math.sqrt(1 + e - i - a),
            this._w = (r - t) / i,
            this._x = (n + s) / i,
            this._y = (o + c) / i,
            this._z = .25 * i),
            this.onChangeCallback(),
            this
        },
        setFromUnitVectors: function(t, e) {
            var i = t.dot(e) + 1;
            return 1e-6 > i ? (i = 0,
            Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
            this._y = t.x,
            this._z = 0) : (this._x = 0,
            this._y = -t.z,
            this._z = t.y)) : (this._x = t.y * e.z - t.z * e.y,
            this._y = t.z * e.x - t.x * e.z,
            this._z = t.x * e.y - t.y * e.x),
            this._w = i,
            this.normalize()
        },
        angleTo: function(t) {
            return 2 * Math.acos(Math.abs(Vr.clamp(this.dot(t), -1, 1)))
        },
        rotateTowards: function(t, e) {
            var i = this.angleTo(t);
            return 0 === i ? this : (this.slerp(t, Math.min(1, e / i)),
            this)
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this.onChangeCallback(),
            this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var t = this.length();
            return 0 === t ? (this._z = this._y = this._x = 0,
            this._w = 1) : (t = 1 / t,
            this._x *= t,
            this._y *= t,
            this._z *= t,
            this._w *= t),
            this.onChangeCallback(),
            this
        },
        multiply: function(t, e) {
            return void 0 !== e ? this.multiplyQuaternions(t, e) : this.multiplyQuaternions(this, t)
        },
        premultiply: function(t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function(t, e) {
            var i = t._x
              , n = t._y
              , r = t._z;
            t = t._w;
            var a = e._x
              , o = e._y
              , s = e._z;
            return e = e._w,
            this._x = i * e + t * a + n * s - r * o,
            this._y = n * e + t * o + r * a - i * s,
            this._z = r * e + t * s + i * o - n * a,
            this._w = t * e - i * a - n * o - r * s,
            this.onChangeCallback(),
            this
        },
        slerp: function(t, e) {
            if (0 === e)
                return this;
            if (1 === e)
                return this.copy(t);
            var i = this._x
              , n = this._y
              , r = this._z
              , a = this._w
              , o = a * t._w + i * t._x + n * t._y + r * t._z;
            if (0 > o ? (this._w = -t._w,
            this._x = -t._x,
            this._y = -t._y,
            this._z = -t._z,
            o = -o) : this.copy(t),
            1 <= o)
                return this._w = a,
                this._x = i,
                this._y = n,
                this._z = r,
                this;
            if ((t = 1 - o * o) <= Number.EPSILON)
                return o = 1 - e,
                this._w = o * a + e * this._w,
                this._x = o * i + e * this._x,
                this._y = o * n + e * this._y,
                this._z = o * r + e * this._z,
                this.normalize();
            t = Math.sqrt(t);
            var s = Math.atan2(t, o);
            return o = Math.sin((1 - e) * s) / t,
            e = Math.sin(e * s) / t,
            this._w = a * o + this._w * e,
            this._x = i * o + this._x * e,
            this._y = n * o + this._y * e,
            this._z = r * o + this._z * e,
            this.onChangeCallback(),
            this
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this._x = t[e],
            this._y = t[e + 1],
            this._z = t[e + 2],
            this._w = t[e + 3],
            this.onChangeCallback(),
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._w,
            t
        },
        onChange: function(t) {
            return this.onChangeCallback = t,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(r.prototype, {
        isVector3: !0,
        set: function(t, e, i) {
            return this.x = t,
            this.y = e,
            this.z = i,
            this
        },
        setScalar: function(t) {
            return this.z = this.y = this.x = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setZ: function(t) {
            return this.z = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this
        },
        multiply: function(t, e) {
            return void 0 !== e ? this.multiplyVectors(t, e) : (this.x *= t.x,
            this.y *= t.y,
            this.z *= t.z,
            this)
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x,
            this.y = t.y * e.y,
            this.z = t.z * e.z,
            this
        },
        applyEuler: function() {
            var t = new n;
            return function(e) {
                return e && e.isEuler,
                this.applyQuaternion(t.setFromEuler(e))
            }
        }(),
        applyAxisAngle: function() {
            var t = new n;
            return function(e, i) {
                return this.applyQuaternion(t.setFromAxisAngle(e, i))
            }
        }(),
        applyMatrix3: function(t) {
            var e = this.x
              , i = this.y
              , n = this.z;
            return t = t.elements,
            this.x = t[0] * e + t[3] * i + t[6] * n,
            this.y = t[1] * e + t[4] * i + t[7] * n,
            this.z = t[2] * e + t[5] * i + t[8] * n,
            this
        },
        applyMatrix4: function(t) {
            var e = this.x
              , i = this.y
              , n = this.z
              , r = 1 / ((t = t.elements)[3] * e + t[7] * i + t[11] * n + t[15]);
            return this.x = (t[0] * e + t[4] * i + t[8] * n + t[12]) * r,
            this.y = (t[1] * e + t[5] * i + t[9] * n + t[13]) * r,
            this.z = (t[2] * e + t[6] * i + t[10] * n + t[14]) * r,
            this
        },
        applyQuaternion: function(t) {
            var e = this.x
              , i = this.y
              , n = this.z
              , r = t.x
              , a = t.y
              , o = t.z
              , s = (t = t.w) * e + a * n - o * i
              , c = t * i + o * e - r * n
              , h = t * n + r * i - a * e;
            return e = -r * e - a * i - o * n,
            this.x = s * t + e * -r + c * -o - h * -a,
            this.y = c * t + e * -a + h * -r - s * -o,
            this.z = h * t + e * -o + s * -a - c * -r,
            this
        },
        project: function(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        },
        unproject: function(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        },
        transformDirection: function(t) {
            var e = this.x
              , i = this.y
              , n = this.z;
            return t = t.elements,
            this.x = t[0] * e + t[4] * i + t[8] * n,
            this.y = t[1] * e + t[5] * i + t[9] * n,
            this.z = t[2] * e + t[6] * i + t[10] * n,
            this.normalize()
        },
        divide: function(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this.z /= t.z,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this
        },
        clampScalar: function() {
            var t = new r
              , e = new r;
            return function(i, n) {
                return t.set(i, i, i),
                e.set(n, n, n),
                this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this
        },
        lerpVectors: function(t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        },
        cross: function(t, e) {
            return void 0 !== e ? this.crossVectors(t, e) : this.crossVectors(this, t)
        },
        crossVectors: function(t, e) {
            var i = t.x
              , n = t.y;
            t = t.z;
            var r = e.x
              , a = e.y;
            return e = e.z,
            this.x = n * e - t * a,
            this.y = t * r - i * e,
            this.z = i * a - n * r,
            this
        },
        projectOnVector: function(t) {
            var e = t.dot(this) / t.lengthSq();
            return this.copy(t).multiplyScalar(e)
        },
        projectOnPlane: function() {
            var t = new r;
            return function(e) {
                return t.copy(this).projectOnVector(e),
                this.sub(t)
            }
        }(),
        reflect: function() {
            var t = new r;
            return function(e) {
                return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
            }
        }(),
        angleTo: function(t) {
            return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()),
            Math.acos(Vr.clamp(t, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x
              , i = this.y - t.y;
            return e * e + i * i + (t = this.z - t.z) * t
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        },
        setFromSphericalCoords: function(t, e, i) {
            var n = Math.sin(e) * t;
            return this.x = n * Math.sin(i),
            this.y = Math.cos(e) * t,
            this.z = n * Math.cos(i),
            this
        },
        setFromCylindrical: function(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        },
        setFromCylindricalCoords: function(t, e, i) {
            return this.x = t * Math.sin(e),
            this.y = i,
            this.z = t * Math.cos(e),
            this
        },
        setFromMatrixPosition: function(t) {
            return t = t.elements,
            this.x = t[12],
            this.y = t[13],
            this.z = t[14],
            this
        },
        setFromMatrixScale: function(t) {
            var e = this.setFromMatrixColumn(t, 0).length()
              , i = this.setFromMatrixColumn(t, 1).length();
            return t = this.setFromMatrixColumn(t, 2).length(),
            this.x = e,
            this.y = i,
            this.z = t,
            this
        },
        setFromMatrixColumn: function(t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t
        },
        fromBufferAttribute: function(t, e) {
            return this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this
        }
    }),
    Object.assign(a.prototype, {
        isMatrix3: !0,
        set: function(t, e, i, n, r, a, o, s, c) {
            var h = this.elements;
            return h[0] = t,
            h[1] = n,
            h[2] = o,
            h[3] = e,
            h[4] = r,
            h[5] = s,
            h[6] = i,
            h[7] = a,
            h[8] = c,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements;
            return t = t.elements,
            e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e[3] = t[3],
            e[4] = t[4],
            e[5] = t[5],
            e[6] = t[6],
            e[7] = t[7],
            e[8] = t[8],
            this
        },
        setFromMatrix4: function(t) {
            return t = t.elements,
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        },
        applyToBufferAttribute: function() {
            var t = new r;
            return function(e) {
                for (var i = 0, n = e.count; i < n; i++)
                    t.x = e.getX(i),
                    t.y = e.getY(i),
                    t.z = e.getZ(i),
                    t.applyMatrix3(this),
                    e.setXYZ(i, t.x, t.y, t.z);
                return e
            }
        }(),
        multiply: function(t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var i = t.elements
              , n = e.elements;
            e = this.elements,
            t = i[0];
            var r = i[3]
              , a = i[6]
              , o = i[1]
              , s = i[4]
              , c = i[7]
              , h = i[2]
              , l = i[5];
            i = i[8];
            var u = n[0]
              , p = n[3]
              , d = n[6]
              , f = n[1]
              , m = n[4]
              , g = n[7]
              , v = n[2]
              , y = n[5];
            return n = n[8],
            e[0] = t * u + r * f + a * v,
            e[3] = t * p + r * m + a * y,
            e[6] = t * d + r * g + a * n,
            e[1] = o * u + s * f + c * v,
            e[4] = o * p + s * m + c * y,
            e[7] = o * d + s * g + c * n,
            e[2] = h * u + l * f + i * v,
            e[5] = h * p + l * m + i * y,
            e[8] = h * d + l * g + i * n,
            this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t,
            e[3] *= t,
            e[6] *= t,
            e[1] *= t,
            e[4] *= t,
            e[7] *= t,
            e[2] *= t,
            e[5] *= t,
            e[8] *= t,
            this
        },
        determinant: function() {
            var t = this.elements
              , e = t[0]
              , i = t[1]
              , n = t[2]
              , r = t[3]
              , a = t[4]
              , o = t[5]
              , s = t[6]
              , c = t[7];
            return e * a * (t = t[8]) - e * o * c - i * r * t + i * o * s + n * r * c - n * a * s
        },
        getInverse: function(t, e) {
            t && t.isMatrix4;
            var i = t.elements;
            t = this.elements;
            var n = i[0]
              , r = i[1]
              , a = i[2]
              , o = i[3]
              , s = i[4]
              , c = i[5]
              , h = i[6]
              , l = i[7]
              , u = (i = i[8]) * s - c * l
              , p = c * h - i * o
              , d = l * o - s * h
              , f = n * u + r * p + a * d;
            if (0 === f) {
                if (!0 === e)
                    throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return this.identity()
            }
            return e = 1 / f,
            t[0] = u * e,
            t[1] = (a * l - i * r) * e,
            t[2] = (c * r - a * s) * e,
            t[3] = p * e,
            t[4] = (i * n - a * h) * e,
            t[5] = (a * o - c * n) * e,
            t[6] = d * e,
            t[7] = (r * h - l * n) * e,
            t[8] = (s * n - r * o) * e,
            this
        },
        transpose: function() {
            var t = this.elements
              , e = t[1];
            return t[1] = t[3],
            t[3] = e,
            e = t[2],
            t[2] = t[6],
            t[6] = e,
            e = t[5],
            t[5] = t[7],
            t[7] = e,
            this
        },
        getNormalMatrix: function(t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function(t) {
            var e = this.elements;
            return t[0] = e[0],
            t[1] = e[3],
            t[2] = e[6],
            t[3] = e[1],
            t[4] = e[4],
            t[5] = e[7],
            t[6] = e[2],
            t[7] = e[5],
            t[8] = e[8],
            this
        },
        setUvTransform: function(t, e, i, n, r, a, o) {
            var s = Math.cos(r);
            r = Math.sin(r),
            this.set(i * s, i * r, -i * (s * a + r * o) + a + t, -n * r, n * s, -n * (-r * a + s * o) + o + e, 0, 0, 1)
        },
        scale: function(t, e) {
            var i = this.elements;
            return i[0] *= t,
            i[3] *= t,
            i[6] *= t,
            i[1] *= e,
            i[4] *= e,
            i[7] *= e,
            this
        },
        rotate: function(t) {
            var e = Math.cos(t);
            t = Math.sin(t);
            var i = this.elements
              , n = i[0]
              , r = i[3]
              , a = i[6]
              , o = i[1]
              , s = i[4]
              , c = i[7];
            return i[0] = e * n + t * o,
            i[3] = e * r + t * s,
            i[6] = e * a + t * c,
            i[1] = -t * n + e * o,
            i[4] = -t * r + e * s,
            i[7] = -t * a + e * c,
            this
        },
        translate: function(t, e) {
            var i = this.elements;
            return i[0] += t * i[2],
            i[3] += t * i[5],
            i[6] += t * i[8],
            i[1] += e * i[2],
            i[4] += e * i[5],
            i[7] += e * i[8],
            this
        },
        equals: function(t) {
            var e = this.elements;
            t = t.elements;
            for (var i = 0; 9 > i; i++)
                if (e[i] !== t[i])
                    return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var i = 0; 9 > i; i++)
                this.elements[i] = t[i + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []),
            void 0 === e && (e = 0);
            var i = this.elements;
            return t[e] = i[0],
            t[e + 1] = i[1],
            t[e + 2] = i[2],
            t[e + 3] = i[3],
            t[e + 4] = i[4],
            t[e + 5] = i[5],
            t[e + 6] = i[6],
            t[e + 7] = i[7],
            t[e + 8] = i[8],
            t
        }
    });
    var jr, Hr = {
        getDataURL: function(t) {
            if ("undefined" == typeof HTMLCanvasElement)
                return t.src;
            if (!(t instanceof HTMLCanvasElement)) {
                void 0 === jr && (jr = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                jr.width = t.width,
                jr.height = t.height;
                var e = jr.getContext("2d");
                t instanceof ImageData ? e.putImageData(t, 0, 0) : e.drawImage(t, 0, 0, t.width, t.height),
                t = jr
            }
            return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
        }
    }, Wr = 0;
    o.DEFAULT_IMAGE = void 0,
    o.DEFAULT_MAPPING = 300,
    o.prototype = Object.assign(Object.create(e.prototype), {
        constructor: o,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name,
            this.image = t.image,
            this.mipmaps = t.mipmaps.slice(0),
            this.mapping = t.mapping,
            this.wrapS = t.wrapS,
            this.wrapT = t.wrapT,
            this.magFilter = t.magFilter,
            this.minFilter = t.minFilter,
            this.anisotropy = t.anisotropy,
            this.format = t.format,
            this.type = t.type,
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            this.rotation = t.rotation,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrix.copy(t.matrix),
            this.generateMipmaps = t.generateMipmaps,
            this.premultiplyAlpha = t.premultiplyAlpha,
            this.flipY = t.flipY,
            this.unpackAlignment = t.unpackAlignment,
            this.encoding = t.encoding,
            this
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
                return t.textures[this.uuid];
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var n = this.image;
                if (void 0 === n.uuid && (n.uuid = Vr.generateUUID()),
                !e && void 0 === t.images[n.uuid]) {
                    if (Array.isArray(n))
                        for (var r = [], a = 0, o = n.length; a < o; a++)
                            r.push(Hr.getDataURL(n[a]));
                    else
                        r = Hr.getDataURL(n);
                    t.images[n.uuid] = {
                        uuid: n.uuid,
                        url: r
                    }
                }
                i.image = n.uuid
            }
            return e || (t.textures[this.uuid] = i),
            i
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(t) {
            if (300 !== this.mapping)
                return t;
            if (t.applyMatrix3(this.matrix),
            0 > t.x || 1 < t.x)
                switch (this.wrapS) {
                case 1e3:
                    t.x -= Math.floor(t.x);
                    break;
                case 1001:
                    t.x = 0 > t.x ? 0 : 1;
                    break;
                case 1002:
                    t.x = 1 === Math.abs(Math.floor(t.x) % 2) ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x)
                }
            if (0 > t.y || 1 < t.y)
                switch (this.wrapT) {
                case 1e3:
                    t.y -= Math.floor(t.y);
                    break;
                case 1001:
                    t.y = 0 > t.y ? 0 : 1;
                    break;
                case 1002:
                    t.y = 1 === Math.abs(Math.floor(t.y) % 2) ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y)
                }
            return this.flipY && (t.y = 1 - t.y),
            t
        }
    }),
    Object.defineProperty(o.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(s.prototype, {
        isVector4: !0,
        set: function(t, e, i, n) {
            return this.x = t,
            this.y = e,
            this.z = i,
            this.w = n,
            this
        },
        setScalar: function(t) {
            return this.w = this.z = this.y = this.x = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setZ: function(t) {
            return this.z = t,
            this
        },
        setW: function(t) {
            return this.w = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this.w = void 0 !== t.w ? t.w : 1,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this.w += t.w,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this.w += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this.w = t.w + e.w,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this.w += t.w * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this.w -= t.w,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this.w -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this.w = t.w - e.w,
            this
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this.w *= t,
            this
        },
        applyMatrix4: function(t) {
            var e = this.x
              , i = this.y
              , n = this.z
              , r = this.w;
            return t = t.elements,
            this.x = t[0] * e + t[4] * i + t[8] * n + t[12] * r,
            this.y = t[1] * e + t[5] * i + t[9] * n + t[13] * r,
            this.z = t[2] * e + t[6] * i + t[10] * n + t[14] * r,
            this.w = t[3] * e + t[7] * i + t[11] * n + t[15] * r,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return 1e-4 > e ? (this.x = 1,
            this.z = this.y = 0) : (this.x = t.x / e,
            this.y = t.y / e,
            this.z = t.z / e),
            this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            var e = (t = t.elements)[0]
              , i = t[4]
              , n = t[8]
              , r = t[1]
              , a = t[5]
              , o = t[9]
              , s = t[2]
              , c = t[6]
              , h = t[10];
            return .01 > Math.abs(i - r) && .01 > Math.abs(n - s) && .01 > Math.abs(o - c) ? .1 > Math.abs(i + r) && .1 > Math.abs(n + s) && .1 > Math.abs(o + c) && .1 > Math.abs(e + a + h - 3) ? (this.set(1, 0, 0, 0),
            this) : (t = Math.PI,
            h = (h + 1) / 2,
            i = (i + r) / 4,
            n = (n + s) / 4,
            o = (o + c) / 4,
            (e = (e + 1) / 2) > (a = (a + 1) / 2) && e > h ? .01 > e ? (c = 0,
            i = s = .707106781) : (s = i / (c = Math.sqrt(e)),
            i = n / c) : a > h ? .01 > a ? (c = .707106781,
            s = 0,
            i = .707106781) : (c = i / (s = Math.sqrt(a)),
            i = o / s) : .01 > h ? (s = c = .707106781,
            i = 0) : (c = n / (i = Math.sqrt(h)),
            s = o / i),
            this.set(c, s, i, t),
            this) : (t = Math.sqrt((c - o) * (c - o) + (n - s) * (n - s) + (r - i) * (r - i)),
            .001 > Math.abs(t) && (t = 1),
            this.x = (c - o) / t,
            this.y = (n - s) / t,
            this.z = (r - i) / t,
            this.w = Math.acos((e + a + h - 1) / 2),
            this)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this.w = Math.min(this.w, t.w),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this.w = Math.max(this.w, t.w),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this.w = Math.max(t.w, Math.min(e.w, this.w)),
            this
        },
        clampScalar: function() {
            var t, e;
            return function(i, n) {
                return void 0 === t && (t = new s,
                e = new s),
                t.set(i, i, i, i),
                e.set(n, n, n, n),
                this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this.w += (t.w - this.w) * e,
            this
        },
        lerpVectors: function(t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this.w = t[e + 3],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t[e + 3] = this.w,
            t
        },
        fromBufferAttribute: function(t, e) {
            return this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this.w = t.getW(e),
            this
        }
    }),
    c.prototype = Object.assign(Object.create(e.prototype), {
        constructor: c,
        isWebGLRenderTarget: !0,
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t,
            this.height = e,
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width,
            this.height = t.height,
            this.viewport.copy(t.viewport),
            this.texture = t.texture.clone(),
            this.depthBuffer = t.depthBuffer,
            this.stencilBuffer = t.stencilBuffer,
            this.depthTexture = t.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    h.prototype = Object.assign(Object.create(c.prototype), {
        constructor: h,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(t) {
            return c.prototype.copy.call(this, t),
            this.samples = t.samples,
            this
        }
    }),
    l.prototype = Object.create(c.prototype),
    l.prototype.constructor = l,
    l.prototype.isWebGLRenderTargetCube = !0,
    u.prototype = Object.create(o.prototype),
    u.prototype.constructor = u,
    u.prototype.isDataTexture = !0,
    Object.assign(p.prototype, {
        isBox3: !0,
        set: function(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        },
        setFromArray: function(t) {
            for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                var h = t[s]
                  , l = t[s + 1]
                  , u = t[s + 2];
                h < e && (e = h),
                l < i && (i = l),
                u < n && (n = u),
                h > r && (r = h),
                l > a && (a = l),
                u > o && (o = u)
            }
            return this.min.set(e, i, n),
            this.max.set(r, a, o),
            this
        },
        setFromBufferAttribute: function(t) {
            for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.count; s < c; s++) {
                var h = t.getX(s)
                  , l = t.getY(s)
                  , u = t.getZ(s);
                h < e && (e = h),
                l < i && (i = l),
                u < n && (n = u),
                h > r && (r = h),
                l > a && (a = l),
                u > o && (o = u)
            }
            return this.min.set(e, i, n),
            this.max.set(r, a, o),
            this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, i = t.length; e < i; e++)
                this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new r;
            return function(e, i) {
                return i = t.copy(i).multiplyScalar(.5),
                this.min.copy(e).sub(i),
                this.max.copy(e).add(i),
                this
            }
        }(),
        setFromObject: function(t) {
            return this.makeEmpty(),
            this.expandByObject(t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(t) {
            return void 0 === t && (t = new r),
            this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (t = new r),
            this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        },
        expandByVector: function(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        },
        expandByObject: function() {
            function t(t) {
                var r = t.geometry;
                if (void 0 !== r)
                    if (r.isGeometry)
                        for (r = r.vertices,
                        i = 0,
                        n = r.length; i < n; i++)
                            a.copy(r[i]),
                            a.applyMatrix4(t.matrixWorld),
                            e.expandByPoint(a);
                    else if (r.isBufferGeometry && void 0 !== (r = r.attributes.position))
                        for (i = 0,
                        n = r.count; i < n; i++)
                            a.fromBufferAttribute(r, i).applyMatrix4(t.matrixWorld),
                            e.expandByPoint(a)
            }
            var e, i, n, a = new r;
            return function(i) {
                return e = this,
                i.updateMatrixWorld(!0),
                i.traverse(t),
                this
            }
        }(),
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function(t, e) {
            return void 0 === e && (e = new r),
            e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        intersectsSphere: function() {
            var t = new r;
            return function(e) {
                return this.clampPoint(e.center, t),
                t.distanceToSquared(e.center) <= e.radius * e.radius
            }
        }(),
        intersectsPlane: function(t) {
            if (0 < t.normal.x)
                var e = t.normal.x * this.min.x
                  , i = t.normal.x * this.max.x;
            else
                e = t.normal.x * this.max.x,
                i = t.normal.x * this.min.x;
            return 0 < t.normal.y ? (e += t.normal.y * this.min.y,
            i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
            i += t.normal.y * this.min.y),
            0 < t.normal.z ? (e += t.normal.z * this.min.z,
            i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
            i += t.normal.z * this.min.z),
            e <= -t.constant && i >= -t.constant
        },
        intersectsTriangle: function() {
            function t(t) {
                var r, a = 0;
                for (r = t.length - 3; a <= r; a += 3) {
                    c.fromArray(t, a);
                    var o = l.x * Math.abs(c.x) + l.y * Math.abs(c.y) + l.z * Math.abs(c.z)
                      , s = e.dot(c)
                      , h = i.dot(c)
                      , u = n.dot(c);
                    if (Math.max(-Math.max(s, h, u), Math.min(s, h, u)) > o)
                        return !1
                }
                return !0
            }
            var e = new r
              , i = new r
              , n = new r
              , a = new r
              , o = new r
              , s = new r
              , c = new r
              , h = new r
              , l = new r
              , u = new r;
            return function(r) {
                return !this.isEmpty() && (this.getCenter(h),
                l.subVectors(this.max, h),
                e.subVectors(r.a, h),
                i.subVectors(r.b, h),
                n.subVectors(r.c, h),
                a.subVectors(i, e),
                o.subVectors(n, i),
                s.subVectors(e, n),
                !!t(r = [0, -a.z, a.y, 0, -o.z, o.y, 0, -s.z, s.y, a.z, 0, -a.x, o.z, 0, -o.x, s.z, 0, -s.x, -a.y, a.x, 0, -o.y, o.x, 0, -s.y, s.x, 0]) && (!!t(r = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (u.crossVectors(a, o),
                t(r = [u.x, u.y, u.z]))))
            }
        }(),
        clampPoint: function(t, e) {
            return void 0 === e && (e = new r),
            e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new r;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        getBoundingSphere: function() {
            var t = new r;
            return function(e) {
                return this.getCenter(e.center),
                e.radius = .5 * this.getSize(t).length(),
                e
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
        },
        union: function(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        },
        applyMatrix4: function() {
            var t = [new r, new r, new r, new r, new r, new r, new r, new r];
            return function(e) {
                return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                this.setFromPoints(t),
                this)
            }
        }(),
        translate: function(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }),
    Object.assign(d.prototype, {
        set: function(t, e) {
            return this.center.copy(t),
            this.radius = e,
            this
        },
        setFromPoints: function() {
            var t = new p;
            return function(e, i) {
                var n = this.center;
                void 0 !== i ? n.copy(i) : t.setFromPoints(e).getCenter(n);
                for (var r = i = 0, a = e.length; r < a; r++)
                    i = Math.max(i, n.distanceToSquared(e[r]));
                return this.radius = Math.sqrt(i),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.center.copy(t.center),
            this.radius = t.radius,
            this
        },
        empty: function() {
            return 0 >= this.radius
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function(t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(t, e) {
            var i = this.center.distanceToSquared(t);
            return void 0 === e && (e = new r),
            e.copy(t),
            i > this.radius * this.radius && (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
            e
        },
        getBoundingBox: function(t) {
            return void 0 === t && (t = new p),
            t.set(this.center, this.center),
            t.expandByScalar(this.radius),
            t
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t),
            this.radius *= t.getMaxScaleOnAxis(),
            this
        },
        translate: function(t) {
            return this.center.add(t),
            this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    }),
    Object.assign(f.prototype, {
        set: function(t, e) {
            return this.normal.copy(t),
            this.constant = e,
            this
        },
        setComponents: function(t, e, i, n) {
            return this.normal.set(t, e, i),
            this.constant = n,
            this
        },
        setFromNormalAndCoplanarPoint: function(t, e) {
            return this.normal.copy(t),
            this.constant = -e.dot(this.normal),
            this
        },
        setFromCoplanarPoints: function() {
            var t = new r
              , e = new r;
            return function(i, n, r) {
                return n = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize(),
                this.setFromNormalAndCoplanarPoint(n, i),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.normal.copy(t.normal),
            this.constant = t.constant,
            this
        },
        normalize: function() {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t),
            this.constant *= t,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function(t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function(t, e) {
            return void 0 === e && (e = new r),
            e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        },
        intersectLine: function() {
            var t = new r;
            return function(e, i) {
                void 0 === i && (i = new r);
                var n = e.delta(t)
                  , a = this.normal.dot(n);
                if (0 === a) {
                    if (0 === this.distanceToPoint(e.start))
                        return i.copy(e.start)
                } else if (!(0 > (a = -(e.start.dot(this.normal) + this.constant) / a) || 1 < a))
                    return i.copy(n).multiplyScalar(a).add(e.start)
            }
        }(),
        intersectsLine: function(t) {
            var e = this.distanceToPoint(t.start);
            return t = this.distanceToPoint(t.end),
            0 > e && 0 < t || 0 > t && 0 < e
        },
        intersectsBox: function(t) {
            return t.intersectsPlane(this)
        },
        intersectsSphere: function(t) {
            return t.intersectsPlane(this)
        },
        coplanarPoint: function(t) {
            return void 0 === t && (t = new r),
            t.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var t = new r
              , e = new a;
            return function(i, n) {
                return n = n || e.getNormalMatrix(i),
                i = this.coplanarPoint(t).applyMatrix4(i),
                n = this.normal.applyMatrix3(n).normalize(),
                this.constant = -i.dot(n),
                this
            }
        }(),
        translate: function(t) {
            return this.constant -= t.dot(this.normal),
            this
        },
        equals: function(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    }),
    Object.assign(m.prototype, {
        set: function(t, e, i, n, r, a) {
            var o = this.planes;
            return o[0].copy(t),
            o[1].copy(e),
            o[2].copy(i),
            o[3].copy(n),
            o[4].copy(r),
            o[5].copy(a),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            for (var e = this.planes, i = 0; 6 > i; i++)
                e[i].copy(t.planes[i]);
            return this
        },
        setFromMatrix: function(t) {
            var e = this.planes
              , i = t.elements;
            t = i[0];
            var n = i[1]
              , r = i[2]
              , a = i[3]
              , o = i[4]
              , s = i[5]
              , c = i[6]
              , h = i[7]
              , l = i[8]
              , u = i[9]
              , p = i[10]
              , d = i[11]
              , f = i[12]
              , m = i[13]
              , g = i[14];
            return i = i[15],
            e[0].setComponents(a - t, h - o, d - l, i - f).normalize(),
            e[1].setComponents(a + t, h + o, d + l, i + f).normalize(),
            e[2].setComponents(a + n, h + s, d + u, i + m).normalize(),
            e[3].setComponents(a - n, h - s, d - u, i - m).normalize(),
            e[4].setComponents(a - r, h - c, d - p, i - g).normalize(),
            e[5].setComponents(a + r, h + c, d + p, i + g).normalize(),
            this
        },
        intersectsObject: function() {
            var t = new d;
            return function(e) {
                var i = e.geometry;
                return null === i.boundingSphere && i.computeBoundingSphere(),
                t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld),
                this.intersectsSphere(t)
            }
        }(),
        intersectsSprite: function() {
            var t = new d;
            return function(e) {
                return t.center.set(0, 0, 0),
                t.radius = .7071067811865476,
                t.applyMatrix4(e.matrixWorld),
                this.intersectsSphere(t)
            }
        }(),
        intersectsSphere: function(t) {
            var e = this.planes
              , i = t.center;
            t = -t.radius;
            for (var n = 0; 6 > n; n++)
                if (e[n].distanceToPoint(i) < t)
                    return !1;
            return !0
        },
        intersectsBox: function() {
            var t = new r;
            return function(e) {
                for (var i = this.planes, n = 0; 6 > n; n++) {
                    var r = i[n];
                    if (t.x = 0 < r.normal.x ? e.max.x : e.min.x,
                    t.y = 0 < r.normal.y ? e.max.y : e.min.y,
                    t.z = 0 < r.normal.z ? e.max.z : e.min.z,
                    0 > r.distanceToPoint(t))
                        return !1
                }
                return !0
            }
        }(),
        containsPoint: function(t) {
            for (var e = this.planes, i = 0; 6 > i; i++)
                if (0 > e[i].distanceToPoint(t))
                    return !1;
            return !0
        }
    }),
    Object.assign(g.prototype, {
        isMatrix4: !0,
        set: function(t, e, i, n, r, a, o, s, c, h, l, u, p, d, f, m) {
            var g = this.elements;
            return g[0] = t,
            g[4] = e,
            g[8] = i,
            g[12] = n,
            g[1] = r,
            g[5] = a,
            g[9] = o,
            g[13] = s,
            g[2] = c,
            g[6] = h,
            g[10] = l,
            g[14] = u,
            g[3] = p,
            g[7] = d,
            g[11] = f,
            g[15] = m,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new g).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements;
            return t = t.elements,
            e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e[3] = t[3],
            e[4] = t[4],
            e[5] = t[5],
            e[6] = t[6],
            e[7] = t[7],
            e[8] = t[8],
            e[9] = t[9],
            e[10] = t[10],
            e[11] = t[11],
            e[12] = t[12],
            e[13] = t[13],
            e[14] = t[14],
            e[15] = t[15],
            this
        },
        copyPosition: function(t) {
            var e = this.elements;
            return t = t.elements,
            e[12] = t[12],
            e[13] = t[13],
            e[14] = t[14],
            this
        },
        extractBasis: function(t, e, i) {
            return t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            i.setFromMatrixColumn(this, 2),
            this
        },
        makeBasis: function(t, e, i) {
            return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1),
            this
        },
        extractRotation: function() {
            var t = new r;
            return function(e) {
                var i = this.elements
                  , n = e.elements
                  , r = 1 / t.setFromMatrixColumn(e, 0).length()
                  , a = 1 / t.setFromMatrixColumn(e, 1).length();
                return e = 1 / t.setFromMatrixColumn(e, 2).length(),
                i[0] = n[0] * r,
                i[1] = n[1] * r,
                i[2] = n[2] * r,
                i[3] = 0,
                i[4] = n[4] * a,
                i[5] = n[5] * a,
                i[6] = n[6] * a,
                i[7] = 0,
                i[8] = n[8] * e,
                i[9] = n[9] * e,
                i[10] = n[10] * e,
                i[11] = 0,
                i[12] = 0,
                i[13] = 0,
                i[14] = 0,
                i[15] = 1,
                this
            }
        }(),
        makeRotationFromEuler: function(t) {
            t && t.isEuler;
            var e = this.elements
              , i = t.x
              , n = t.y
              , r = t.z
              , a = Math.cos(i);
            i = Math.sin(i);
            var o = Math.cos(n);
            n = Math.sin(n);
            var s = Math.cos(r);
            if (r = Math.sin(r),
            "XYZ" === t.order) {
                t = a * s;
                var c = a * r
                  , h = i * s
                  , l = i * r;
                e[0] = o * s,
                e[4] = -o * r,
                e[8] = n,
                e[1] = c + h * n,
                e[5] = t - l * n,
                e[9] = -i * o,
                e[2] = l - t * n,
                e[6] = h + c * n,
                e[10] = a * o
            } else
                "YXZ" === t.order ? (t = o * s,
                c = o * r,
                h = n * s,
                l = n * r,
                e[0] = t + l * i,
                e[4] = h * i - c,
                e[8] = a * n,
                e[1] = a * r,
                e[5] = a * s,
                e[9] = -i,
                e[2] = c * i - h,
                e[6] = l + t * i,
                e[10] = a * o) : "ZXY" === t.order ? (t = o * s,
                c = o * r,
                h = n * s,
                l = n * r,
                e[0] = t - l * i,
                e[4] = -a * r,
                e[8] = h + c * i,
                e[1] = c + h * i,
                e[5] = a * s,
                e[9] = l - t * i,
                e[2] = -a * n,
                e[6] = i,
                e[10] = a * o) : "ZYX" === t.order ? (t = a * s,
                c = a * r,
                h = i * s,
                l = i * r,
                e[0] = o * s,
                e[4] = h * n - c,
                e[8] = t * n + l,
                e[1] = o * r,
                e[5] = l * n + t,
                e[9] = c * n - h,
                e[2] = -n,
                e[6] = i * o,
                e[10] = a * o) : "YZX" === t.order ? (t = a * o,
                c = a * n,
                h = i * o,
                l = i * n,
                e[0] = o * s,
                e[4] = l - t * r,
                e[8] = h * r + c,
                e[1] = r,
                e[5] = a * s,
                e[9] = -i * s,
                e[2] = -n * s,
                e[6] = c * r + h,
                e[10] = t - l * r) : "XZY" === t.order && (t = a * o,
                c = a * n,
                h = i * o,
                l = i * n,
                e[0] = o * s,
                e[4] = -r,
                e[8] = n * s,
                e[1] = t * r + l,
                e[5] = a * s,
                e[9] = c * r - h,
                e[2] = h * r - c,
                e[6] = i * s,
                e[10] = l * r + t);
            return e[3] = 0,
            e[7] = 0,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        },
        makeRotationFromQuaternion: function() {
            var t = new r(0,0,0)
              , e = new r(1,1,1);
            return function(i) {
                return this.compose(t, i, e)
            }
        }(),
        lookAt: function() {
            var t = new r
              , e = new r
              , i = new r;
            return function(n, r, a) {
                var o = this.elements;
                return i.subVectors(n, r),
                0 === i.lengthSq() && (i.z = 1),
                i.normalize(),
                t.crossVectors(a, i),
                0 === t.lengthSq() && (1 === Math.abs(a.z) ? i.x += 1e-4 : i.z += 1e-4,
                i.normalize(),
                t.crossVectors(a, i)),
                t.normalize(),
                e.crossVectors(i, t),
                o[0] = t.x,
                o[4] = e.x,
                o[8] = i.x,
                o[1] = t.y,
                o[5] = e.y,
                o[9] = i.y,
                o[2] = t.z,
                o[6] = e.z,
                o[10] = i.z,
                this
            }
        }(),
        multiply: function(t, e) {
            return void 0 !== e ? this.multiplyMatrices(t, e) : this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var i = t.elements
              , n = e.elements;
            e = this.elements,
            t = i[0];
            var r = i[4]
              , a = i[8]
              , o = i[12]
              , s = i[1]
              , c = i[5]
              , h = i[9]
              , l = i[13]
              , u = i[2]
              , p = i[6]
              , d = i[10]
              , f = i[14]
              , m = i[3]
              , g = i[7]
              , v = i[11];
            i = i[15];
            var y = n[0]
              , x = n[4]
              , b = n[8]
              , w = n[12]
              , M = n[1]
              , _ = n[5]
              , S = n[9]
              , T = n[13]
              , E = n[2]
              , A = n[6]
              , L = n[10]
              , P = n[14]
              , C = n[3]
              , I = n[7]
              , R = n[11];
            return n = n[15],
            e[0] = t * y + r * M + a * E + o * C,
            e[4] = t * x + r * _ + a * A + o * I,
            e[8] = t * b + r * S + a * L + o * R,
            e[12] = t * w + r * T + a * P + o * n,
            e[1] = s * y + c * M + h * E + l * C,
            e[5] = s * x + c * _ + h * A + l * I,
            e[9] = s * b + c * S + h * L + l * R,
            e[13] = s * w + c * T + h * P + l * n,
            e[2] = u * y + p * M + d * E + f * C,
            e[6] = u * x + p * _ + d * A + f * I,
            e[10] = u * b + p * S + d * L + f * R,
            e[14] = u * w + p * T + d * P + f * n,
            e[3] = m * y + g * M + v * E + i * C,
            e[7] = m * x + g * _ + v * A + i * I,
            e[11] = m * b + g * S + v * L + i * R,
            e[15] = m * w + g * T + v * P + i * n,
            this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t,
            e[4] *= t,
            e[8] *= t,
            e[12] *= t,
            e[1] *= t,
            e[5] *= t,
            e[9] *= t,
            e[13] *= t,
            e[2] *= t,
            e[6] *= t,
            e[10] *= t,
            e[14] *= t,
            e[3] *= t,
            e[7] *= t,
            e[11] *= t,
            e[15] *= t,
            this
        },
        applyToBufferAttribute: function() {
            var t = new r;
            return function(e) {
                for (var i = 0, n = e.count; i < n; i++)
                    t.x = e.getX(i),
                    t.y = e.getY(i),
                    t.z = e.getZ(i),
                    t.applyMatrix4(this),
                    e.setXYZ(i, t.x, t.y, t.z);
                return e
            }
        }(),
        determinant: function() {
            var t = this.elements
              , e = t[0]
              , i = t[4]
              , n = t[8]
              , r = t[12]
              , a = t[1]
              , o = t[5]
              , s = t[9]
              , c = t[13]
              , h = t[2]
              , l = t[6]
              , u = t[10]
              , p = t[14];
            return t[3] * (+r * s * l - n * c * l - r * o * u + i * c * u + n * o * p - i * s * p) + t[7] * (+e * s * p - e * c * u + r * a * u - n * a * p + n * c * h - r * s * h) + t[11] * (+e * c * l - e * o * p - r * a * l + i * a * p + r * o * h - i * c * h) + t[15] * (-n * o * h - e * s * l + e * o * u + n * a * l - i * a * u + i * s * h)
        },
        transpose: function() {
            var t = this.elements
              , e = t[1];
            return t[1] = t[4],
            t[4] = e,
            e = t[2],
            t[2] = t[8],
            t[8] = e,
            e = t[6],
            t[6] = t[9],
            t[9] = e,
            e = t[3],
            t[3] = t[12],
            t[12] = e,
            e = t[7],
            t[7] = t[13],
            t[13] = e,
            e = t[11],
            t[11] = t[14],
            t[14] = e,
            this
        },
        setPosition: function(t) {
            var e = this.elements;
            return e[12] = t.x,
            e[13] = t.y,
            e[14] = t.z,
            this
        },
        getInverse: function(t, e) {
            var i = this.elements
              , n = t.elements;
            t = n[0];
            var r = n[1]
              , a = n[2]
              , o = n[3]
              , s = n[4]
              , c = n[5]
              , h = n[6]
              , l = n[7]
              , u = n[8]
              , p = n[9]
              , d = n[10]
              , f = n[11]
              , m = n[12]
              , g = n[13]
              , v = n[14]
              , y = p * v * l - g * d * l + g * h * f - c * v * f - p * h * (n = n[15]) + c * d * n
              , x = m * d * l - u * v * l - m * h * f + s * v * f + u * h * n - s * d * n
              , b = u * g * l - m * p * l + m * c * f - s * g * f - u * c * n + s * p * n
              , w = m * p * h - u * g * h - m * c * d + s * g * d + u * c * v - s * p * v
              , M = t * y + r * x + a * b + o * w;
            if (0 === M) {
                if (!0 === e)
                    throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return this.identity()
            }
            return e = 1 / M,
            i[0] = y * e,
            i[1] = (g * d * o - p * v * o - g * a * f + r * v * f + p * a * n - r * d * n) * e,
            i[2] = (c * v * o - g * h * o + g * a * l - r * v * l - c * a * n + r * h * n) * e,
            i[3] = (p * h * o - c * d * o - p * a * l + r * d * l + c * a * f - r * h * f) * e,
            i[4] = x * e,
            i[5] = (u * v * o - m * d * o + m * a * f - t * v * f - u * a * n + t * d * n) * e,
            i[6] = (m * h * o - s * v * o - m * a * l + t * v * l + s * a * n - t * h * n) * e,
            i[7] = (s * d * o - u * h * o + u * a * l - t * d * l - s * a * f + t * h * f) * e,
            i[8] = b * e,
            i[9] = (m * p * o - u * g * o - m * r * f + t * g * f + u * r * n - t * p * n) * e,
            i[10] = (s * g * o - m * c * o + m * r * l - t * g * l - s * r * n + t * c * n) * e,
            i[11] = (u * c * o - s * p * o - u * r * l + t * p * l + s * r * f - t * c * f) * e,
            i[12] = w * e,
            i[13] = (u * g * a - m * p * a + m * r * d - t * g * d - u * r * v + t * p * v) * e,
            i[14] = (m * c * a - s * g * a - m * r * h + t * g * h + s * r * v - t * c * v) * e,
            i[15] = (s * p * a - u * c * a + u * r * h - t * p * h - s * r * d + t * c * d) * e,
            this
        },
        scale: function(t) {
            var e = this.elements
              , i = t.x
              , n = t.y;
            return t = t.z,
            e[0] *= i,
            e[4] *= n,
            e[8] *= t,
            e[1] *= i,
            e[5] *= n,
            e[9] *= t,
            e[2] *= i,
            e[6] *= n,
            e[10] *= t,
            e[3] *= i,
            e[7] *= n,
            e[11] *= t,
            this
        },
        getMaxScaleOnAxis: function() {
            var t = this.elements;
            return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10]))
        },
        makeTranslation: function(t, e, i) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(t) {
            var e = Math.cos(t);
            return t = Math.sin(t),
            this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(t) {
            var e = Math.cos(t);
            return t = Math.sin(t),
            this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(t) {
            var e = Math.cos(t);
            return t = Math.sin(t),
            this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(t, e) {
            var i = Math.cos(e);
            e = Math.sin(e);
            var n = 1 - i
              , r = t.x
              , a = t.y;
            t = t.z;
            var o = n * r
              , s = n * a;
            return this.set(o * r + i, o * a - e * t, o * t + e * a, 0, o * a + e * t, s * a + i, s * t - e * r, 0, o * t - e * a, s * t + e * r, n * t * t + i, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(t, e, i) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
            this
        },
        makeShear: function(t, e, i) {
            return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1),
            this
        },
        compose: function(t, e, i) {
            var n = this.elements
              , r = e._x
              , a = e._y
              , o = e._z
              , s = e._w
              , c = r + r
              , h = a + a
              , l = o + o;
            e = r * c;
            var u = r * h;
            r *= l;
            var p = a * h;
            a *= l,
            o *= l,
            c *= s,
            h *= s,
            s *= l,
            l = i.x;
            var d = i.y;
            return i = i.z,
            n[0] = (1 - (p + o)) * l,
            n[1] = (u + s) * l,
            n[2] = (r - h) * l,
            n[3] = 0,
            n[4] = (u - s) * d,
            n[5] = (1 - (e + o)) * d,
            n[6] = (a + c) * d,
            n[7] = 0,
            n[8] = (r + h) * i,
            n[9] = (a - c) * i,
            n[10] = (1 - (e + p)) * i,
            n[11] = 0,
            n[12] = t.x,
            n[13] = t.y,
            n[14] = t.z,
            n[15] = 1,
            this
        },
        decompose: function() {
            var t = new r
              , e = new g;
            return function(i, n, r) {
                var a = this.elements
                  , o = t.set(a[0], a[1], a[2]).length()
                  , s = t.set(a[4], a[5], a[6]).length()
                  , c = t.set(a[8], a[9], a[10]).length();
                0 > this.determinant() && (o = -o),
                i.x = a[12],
                i.y = a[13],
                i.z = a[14],
                e.copy(this),
                i = 1 / o,
                a = 1 / s;
                var h = 1 / c;
                return e.elements[0] *= i,
                e.elements[1] *= i,
                e.elements[2] *= i,
                e.elements[4] *= a,
                e.elements[5] *= a,
                e.elements[6] *= a,
                e.elements[8] *= h,
                e.elements[9] *= h,
                e.elements[10] *= h,
                n.setFromRotationMatrix(e),
                r.x = o,
                r.y = s,
                r.z = c,
                this
            }
        }(),
        makePerspective: function(t, e, i, n, r, a) {
            var o = this.elements;
            return o[0] = 2 * r / (e - t),
            o[4] = 0,
            o[8] = (e + t) / (e - t),
            o[12] = 0,
            o[1] = 0,
            o[5] = 2 * r / (i - n),
            o[9] = (i + n) / (i - n),
            o[13] = 0,
            o[2] = 0,
            o[6] = 0,
            o[10] = -(a + r) / (a - r),
            o[14] = -2 * a * r / (a - r),
            o[3] = 0,
            o[7] = 0,
            o[11] = -1,
            o[15] = 0,
            this
        },
        makeOrthographic: function(t, e, i, n, r, a) {
            var o = this.elements
              , s = 1 / (e - t)
              , c = 1 / (i - n)
              , h = 1 / (a - r);
            return o[0] = 2 * s,
            o[4] = 0,
            o[8] = 0,
            o[12] = -(e + t) * s,
            o[1] = 0,
            o[5] = 2 * c,
            o[9] = 0,
            o[13] = -(i + n) * c,
            o[2] = 0,
            o[6] = 0,
            o[10] = -2 * h,
            o[14] = -(a + r) * h,
            o[3] = 0,
            o[7] = 0,
            o[11] = 0,
            o[15] = 1,
            this
        },
        equals: function(t) {
            var e = this.elements;
            t = t.elements;
            for (var i = 0; 16 > i; i++)
                if (e[i] !== t[i])
                    return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var i = 0; 16 > i; i++)
                this.elements[i] = t[i + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []),
            void 0 === e && (e = 0);
            var i = this.elements;
            return t[e] = i[0],
            t[e + 1] = i[1],
            t[e + 2] = i[2],
            t[e + 3] = i[3],
            t[e + 4] = i[4],
            t[e + 5] = i[5],
            t[e + 6] = i[6],
            t[e + 7] = i[7],
            t[e + 8] = i[8],
            t[e + 9] = i[9],
            t[e + 10] = i[10],
            t[e + 11] = i[11],
            t[e + 12] = i[12],
            t[e + 13] = i[13],
            t[e + 14] = i[14],
            t[e + 15] = i[15],
            t
        }
    });
    var Xr = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
        lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
        normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    }
      , qr = {
        clone: v,
        merge: y
    }
      , Yr = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    Object.assign(x.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
            this
        },
        setScalar: function(t) {
            return this.b = this.g = this.r = t,
            this
        },
        setHex: function(t) {
            return t = Math.floor(t),
            this.r = (t >> 16 & 255) / 255,
            this.g = (t >> 8 & 255) / 255,
            this.b = (255 & t) / 255,
            this
        },
        setRGB: function(t, e, i) {
            return this.r = t,
            this.g = e,
            this.b = i,
            this
        },
        setHSL: function() {
            function t(t, e, i) {
                return 0 > i && (i += 1),
                1 < i && --i,
                i < 1 / 6 ? t + 6 * (e - t) * i : .5 > i ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
            }
            return function(e, i, n) {
                return e = Vr.euclideanModulo(e, 1),
                i = Vr.clamp(i, 0, 1),
                n = Vr.clamp(n, 0, 1),
                0 === i ? this.r = this.g = this.b = n : (n = 2 * n - (i = .5 >= n ? n * (1 + i) : n + i - n * i),
                this.r = t(n, i, e + 1 / 3),
                this.g = t(n, i, e),
                this.b = t(n, i, e - 1 / 3)),
                this
            }
        }(),
        setStyle: function(t) {
            function e(t) {
                void 0 !== t && parseFloat(t)
            }
            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var n = i[2];
                switch (i[1]) {
                case "rgb":
                case "rgba":
                    if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n))
                        return this.r = Math.min(255, parseInt(i[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(i[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(i[3], 10)) / 255,
                        e(i[5]),
                        this;
                    if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n))
                        return this.r = Math.min(100, parseInt(i[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(i[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(i[3], 10)) / 100,
                        e(i[5]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) {
                        n = parseFloat(i[1]) / 360;
                        var r = parseInt(i[2], 10) / 100
                          , a = parseInt(i[3], 10) / 100;
                        return e(i[5]),
                        this.setHSL(n, r, a)
                    }
                }
            } else if (i = /^#([A-Fa-f0-9]+)$/.exec(t)) {
                if (3 === (n = (i = i[1]).length))
                    return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255,
                    this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255,
                    this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255,
                    this;
                if (6 === n)
                    return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255,
                    this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255,
                    this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255,
                    this
            }
            return t && 0 < t.length && (void 0 !== (i = Yr[t]) && this.setHex(i)),
            this
        },
        clone: function() {
            return new this.constructor(this.r,this.g,this.b)
        },
        copy: function(t) {
            return this.r = t.r,
            this.g = t.g,
            this.b = t.b,
            this
        },
        copyGammaToLinear: function(t, e) {
            return void 0 === e && (e = 2),
            this.r = Math.pow(t.r, e),
            this.g = Math.pow(t.g, e),
            this.b = Math.pow(t.b, e),
            this
        },
        copyLinearToGamma: function(t, e) {
            return void 0 === e && (e = 2),
            e = 0 < e ? 1 / e : 1,
            this.r = Math.pow(t.r, e),
            this.g = Math.pow(t.g, e),
            this.b = Math.pow(t.b, e),
            this
        },
        convertGammaToLinear: function(t) {
            return this.copyGammaToLinear(this, t),
            this
        },
        convertLinearToGamma: function(t) {
            return this.copyLinearToGamma(this, t),
            this
        },
        copySRGBToLinear: function() {
            function t(t) {
                return .04045 > t ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }
            return function(e) {
                return this.r = t(e.r),
                this.g = t(e.g),
                this.b = t(e.b),
                this
            }
        }(),
        copyLinearToSRGB: function() {
            function t(t) {
                return .0031308 > t ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }
            return function(e) {
                return this.r = t(e.r),
                this.g = t(e.g),
                this.b = t(e.b),
                this
            }
        }(),
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this),
            this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(t) {
            void 0 === t && (t = {
                h: 0,
                s: 0,
                l: 0
            });
            var e, i = this.r, n = this.g, r = this.b, a = Math.max(i, n, r), o = Math.min(i, n, r), s = (o + a) / 2;
            if (o === a)
                o = e = 0;
            else {
                var c = a - o;
                switch (o = .5 >= s ? c / (a + o) : c / (2 - a - o),
                a) {
                case i:
                    e = (n - r) / c + (n < r ? 6 : 0);
                    break;
                case n:
                    e = (r - i) / c + 2;
                    break;
                case r:
                    e = (i - n) / c + 4
                }
                e /= 6
            }
            return t.h = e,
            t.s = o,
            t.l = s,
            t
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function() {
            var t = {};
            return function(e, i, n) {
                return this.getHSL(t),
                t.h += e,
                t.s += i,
                t.l += n,
                this.setHSL(t.h, t.s, t.l),
                this
            }
        }(),
        add: function(t) {
            return this.r += t.r,
            this.g += t.g,
            this.b += t.b,
            this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r,
            this.g = t.g + e.g,
            this.b = t.b + e.b,
            this
        },
        addScalar: function(t) {
            return this.r += t,
            this.g += t,
            this.b += t,
            this
        },
        sub: function(t) {
            return this.r = Math.max(0, this.r - t.r),
            this.g = Math.max(0, this.g - t.g),
            this.b = Math.max(0, this.b - t.b),
            this
        },
        multiply: function(t) {
            return this.r *= t.r,
            this.g *= t.g,
            this.b *= t.b,
            this
        },
        multiplyScalar: function(t) {
            return this.r *= t,
            this.g *= t,
            this.b *= t,
            this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e,
            this.g += (t.g - this.g) * e,
            this.b += (t.b - this.b) * e,
            this
        },
        lerpHSL: function() {
            var t = {
                h: 0,
                s: 0,
                l: 0
            }
              , e = {
                h: 0,
                s: 0,
                l: 0
            };
            return function(i, n) {
                this.getHSL(t),
                i.getHSL(e),
                i = Vr.lerp(t.h, e.h, n);
                var r = Vr.lerp(t.s, e.s, n);
                return n = Vr.lerp(t.l, e.l, n),
                this.setHSL(i, r, n),
                this
            }
        }(),
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.r = t[e],
            this.g = t[e + 1],
            this.b = t[e + 2],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.r,
            t[e + 1] = this.g,
            t[e + 2] = this.b,
            t
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var Jr = {
        common: {
            diffuse: {
                value: new x(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new a
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new i(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new x(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new x(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new a
            }
        },
        sprite: {
            diffuse: {
                value: new x(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new i(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new a
            }
        }
    }
      , Zr = {
        basic: {
            uniforms: y([Jr.common, Jr.specularmap, Jr.envmap, Jr.aomap, Jr.lightmap, Jr.fog]),
            vertexShader: Xr.meshbasic_vert,
            fragmentShader: Xr.meshbasic_frag
        },
        lambert: {
            uniforms: y([Jr.common, Jr.specularmap, Jr.envmap, Jr.aomap, Jr.lightmap, Jr.emissivemap, Jr.fog, Jr.lights, {
                emissive: {
                    value: new x(0)
                }
            }]),
            vertexShader: Xr.meshlambert_vert,
            fragmentShader: Xr.meshlambert_frag
        },
        phong: {
            uniforms: y([Jr.common, Jr.specularmap, Jr.envmap, Jr.aomap, Jr.lightmap, Jr.emissivemap, Jr.bumpmap, Jr.normalmap, Jr.displacementmap, Jr.gradientmap, Jr.fog, Jr.lights, {
                emissive: {
                    value: new x(0)
                },
                specular: {
                    value: new x(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Xr.meshphong_vert,
            fragmentShader: Xr.meshphong_frag
        },
        standard: {
            uniforms: y([Jr.common, Jr.envmap, Jr.aomap, Jr.lightmap, Jr.emissivemap, Jr.bumpmap, Jr.normalmap, Jr.displacementmap, Jr.roughnessmap, Jr.metalnessmap, Jr.fog, Jr.lights, {
                emissive: {
                    value: new x(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Xr.meshphysical_vert,
            fragmentShader: Xr.meshphysical_frag
        },
        matcap: {
            uniforms: y([Jr.common, Jr.bumpmap, Jr.normalmap, Jr.displacementmap, Jr.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: Xr.meshmatcap_vert,
            fragmentShader: Xr.meshmatcap_frag
        },
        points: {
            uniforms: y([Jr.points, Jr.fog]),
            vertexShader: Xr.points_vert,
            fragmentShader: Xr.points_frag
        },
        dashed: {
            uniforms: y([Jr.common, Jr.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Xr.linedashed_vert,
            fragmentShader: Xr.linedashed_frag
        },
        depth: {
            uniforms: y([Jr.common, Jr.displacementmap]),
            vertexShader: Xr.depth_vert,
            fragmentShader: Xr.depth_frag
        },
        normal: {
            uniforms: y([Jr.common, Jr.bumpmap, Jr.normalmap, Jr.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Xr.normal_vert,
            fragmentShader: Xr.normal_frag
        },
        sprite: {
            uniforms: y([Jr.sprite, Jr.fog]),
            vertexShader: Xr.sprite_vert,
            fragmentShader: Xr.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new a
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: Xr.background_vert,
            fragmentShader: Xr.background_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Xr.cube_vert,
            fragmentShader: Xr.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Xr.equirect_vert,
            fragmentShader: Xr.equirect_frag
        },
        distanceRGBA: {
            uniforms: y([Jr.common, Jr.displacementmap, {
                referencePosition: {
                    value: new r
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Xr.distanceRGBA_vert,
            fragmentShader: Xr.distanceRGBA_frag
        },
        shadow: {
            uniforms: y([Jr.lights, Jr.fog, {
                color: {
                    value: new x(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Xr.shadow_vert,
            fragmentShader: Xr.shadow_frag
        }
    };
    Zr.physical = {
        uniforms: y([Zr.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: Xr.meshphysical_vert,
        fragmentShader: Xr.meshphysical_frag
    },
    Object.assign(M.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.a = t.a,
            this.b = t.b,
            this.c = t.c,
            this.normal.copy(t.normal),
            this.color.copy(t.color),
            this.materialIndex = t.materialIndex;
            for (var e = 0, i = t.vertexNormals.length; e < i; e++)
                this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0,
            i = t.vertexColors.length; e < i; e++)
                this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    }),
    _.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "),
    _.DefaultOrder = "XYZ",
    Object.defineProperties(_.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t,
                this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(t) {
                this._order = t,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(_.prototype, {
        isEuler: !0,
        set: function(t, e, i, n) {
            return this._x = t,
            this._y = e,
            this._z = i,
            this._order = n || this._order,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        },
        copy: function(t) {
            return this._x = t._x,
            this._y = t._y,
            this._z = t._z,
            this._order = t._order,
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(t, e, i) {
            var n = Vr.clamp
              , r = t.elements;
            t = r[0];
            var a = r[4]
              , o = r[8]
              , s = r[1]
              , c = r[5]
              , h = r[9]
              , l = r[2]
              , u = r[6];
            return r = r[10],
            "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(o, -1, 1)),
            .99999 > Math.abs(o) ? (this._x = Math.atan2(-h, r),
            this._z = Math.atan2(-a, t)) : (this._x = Math.atan2(u, c),
            this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(h, -1, 1)),
            .99999 > Math.abs(h) ? (this._y = Math.atan2(o, r),
            this._z = Math.atan2(s, c)) : (this._y = Math.atan2(-l, t),
            this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(u, -1, 1)),
            .99999 > Math.abs(u) ? (this._y = Math.atan2(-l, r),
            this._z = Math.atan2(-a, c)) : (this._y = 0,
            this._z = Math.atan2(s, t))) : "ZYX" === e ? (this._y = Math.asin(-n(l, -1, 1)),
            .99999 > Math.abs(l) ? (this._x = Math.atan2(u, r),
            this._z = Math.atan2(s, t)) : (this._x = 0,
            this._z = Math.atan2(-a, c))) : "YZX" === e ? (this._z = Math.asin(n(s, -1, 1)),
            .99999 > Math.abs(s) ? (this._x = Math.atan2(-h, c),
            this._y = Math.atan2(-l, t)) : (this._x = 0,
            this._y = Math.atan2(o, r))) : "XZY" === e && (this._z = Math.asin(-n(a, -1, 1)),
            .99999 > Math.abs(a) ? (this._x = Math.atan2(u, c),
            this._y = Math.atan2(o, t)) : (this._x = Math.atan2(-h, r),
            this._y = 0)),
            this._order = e,
            !1 !== i && this.onChangeCallback(),
            this
        },
        setFromQuaternion: function() {
            var t = new g;
            return function(e, i, n) {
                return t.makeRotationFromQuaternion(e),
                this.setFromRotationMatrix(t, i, n)
            }
        }(),
        setFromVector3: function(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: function() {
            var t = new n;
            return function(e) {
                return t.setFromEuler(this),
                this.setFromQuaternion(t, e)
            }
        }(),
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function(t) {
            return this._x = t[0],
            this._y = t[1],
            this._z = t[2],
            void 0 !== t[3] && (this._order = t[3]),
            this.onChangeCallback(),
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._order,
            t
        },
        toVector3: function(t) {
            return t ? t.set(this._x, this._y, this._z) : new r(this._x,this._y,this._z)
        },
        onChange: function(t) {
            return this.onChangeCallback = t,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(S.prototype, {
        set: function(t) {
            this.mask = 1 << t | 0
        },
        enable: function(t) {
            this.mask = this.mask | 1 << t | 0
        },
        toggle: function(t) {
            this.mask ^= 1 << t | 0
        },
        disable: function(t) {
            this.mask &= ~(1 << t | 0)
        },
        test: function(t) {
            return 0 != (this.mask & t.mask)
        }
    });
    var Qr = 0;
    T.DefaultUp = new r(0,1,0),
    T.DefaultMatrixAutoUpdate = !0,
    T.prototype = Object.assign(Object.create(e.prototype), {
        constructor: T,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(t) {
            this.matrix.multiplyMatrices(t, this.matrix),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(t) {
            return this.quaternion.premultiply(t),
            this
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function() {
            var t = new n;
            return function(e, i) {
                return t.setFromAxisAngle(e, i),
                this.quaternion.multiply(t),
                this
            }
        }(),
        rotateOnWorldAxis: function() {
            var t = new n;
            return function(e, i) {
                return t.setFromAxisAngle(e, i),
                this.quaternion.premultiply(t),
                this
            }
        }(),
        rotateX: function() {
            var t = new r(1,0,0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateY: function() {
            var t = new r(0,1,0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateZ: function() {
            var t = new r(0,0,1);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        translateOnAxis: function() {
            var t = new r;
            return function(e, i) {
                return t.copy(e).applyQuaternion(this.quaternion),
                this.position.add(t.multiplyScalar(i)),
                this
            }
        }(),
        translateX: function() {
            var t = new r(1,0,0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateY: function() {
            var t = new r(0,1,0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateZ: function() {
            var t = new r(0,0,1);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var t = new g;
            return function(e) {
                return e.applyMatrix4(t.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var t = new n
              , e = new g
              , i = new r
              , a = new r;
            return function(n, r, o) {
                n.isVector3 ? i.copy(n) : i.set(n, r, o),
                n = this.parent,
                this.updateWorldMatrix(!0, !1),
                a.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? e.lookAt(a, i, this.up) : e.lookAt(i, a, this.up),
                this.quaternion.setFromRotationMatrix(e),
                n && (e.extractRotation(n.matrixWorld),
                t.setFromRotationMatrix(e),
                this.quaternion.premultiply(t.inverse()))
            }
        }(),
        add: function(t) {
            if (1 < arguments.length) {
                for (var e = 0; e < arguments.length; e++)
                    this.add(arguments[e]);
                return this
            }
            return t === this ? this : (t && t.isObject3D && (null !== t.parent && t.parent.remove(t),
            t.parent = this,
            t.dispatchEvent({
                type: "added"
            }),
            this.children.push(t)),
            this)
        },
        remove: function(t) {
            if (1 < arguments.length) {
                for (var e = 0; e < arguments.length; e++)
                    this.remove(arguments[e]);
                return this
            }
            return -1 !== (e = this.children.indexOf(t)) && (t.parent = null,
            t.dispatchEvent({
                type: "removed"
            }),
            this.children.splice(e, 1)),
            this
        },
        getObjectById: function(t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function(t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function(t, e) {
            if (this[t] === e)
                return this;
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i].getObjectByProperty(t, e);
                if (void 0 !== r)
                    return r
            }
        },
        getWorldPosition: function(t) {
            return void 0 === t && (t = new r),
            this.updateMatrixWorld(!0),
            t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var t = new r
              , e = new r;
            return function(i) {
                return void 0 === i && (i = new n),
                this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(t, i, e),
                i
            }
        }(),
        getWorldScale: function() {
            var t = new r
              , e = new n;
            return function(i) {
                return void 0 === i && (i = new r),
                this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(t, e, i),
                i
            }
        }(),
        getWorldDirection: function(t) {
            void 0 === t && (t = new r),
            this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        },
        raycast: function() {},
        traverse: function(t) {
            t(this);
            for (var e = this.children, i = 0, n = e.length; i < n; i++)
                e[i].traverse(t)
        },
        traverseVisible: function(t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, i = 0, n = e.length; i < n; i++)
                    e[i].traverseVisible(t)
            }
        },
        traverseAncestors: function(t) {
            var e = this.parent;
            null !== e && (t(e),
            e.traverseAncestors(t))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            t = !0);
            for (var e = this.children, i = 0, n = e.length; i < n; i++)
                e[i].updateMatrixWorld(t)
        },
        updateWorldMatrix: function(t, e) {
            var i = this.parent;
            if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === e)
                for (e = 0,
                i = (t = this.children).length; e < i; e++)
                    t[e].updateWorldMatrix(!1, !0)
        },
        toJSON: function(t) {
            function e(e, i) {
                return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)),
                i.uuid
            }
            function i(t) {
                var e, i = [];
                for (e in t) {
                    var n = t[e];
                    delete n.metadata,
                    i.push(n)
                }
                return i
            }
            var n = void 0 === t || "string" == typeof t
              , r = {};
            n && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            },
            r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var a = {};
            if (a.uuid = this.uuid,
            a.type = this.type,
            "" !== this.name && (a.name = this.name),
            !0 === this.castShadow && (a.castShadow = !0),
            !0 === this.receiveShadow && (a.receiveShadow = !0),
            !1 === this.visible && (a.visible = !1),
            !1 === this.frustumCulled && (a.frustumCulled = !1),
            0 !== this.renderOrder && (a.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData),
            a.layers = this.layers.mask,
            a.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (a.matrixAutoUpdate = !1),
            this.isMesh && 0 !== this.drawMode && (a.drawMode = this.drawMode),
            this.isMesh || this.isLine || this.isPoints) {
                a.geometry = e(t.geometries, this.geometry);
                var o = this.geometry.parameters;
                if (void 0 !== o && void 0 !== o.shapes)
                    if (o = o.shapes,
                    Array.isArray(o))
                        for (var s = 0, c = o.length; s < c; s++)
                            e(t.shapes, o[s]);
                    else
                        e(t.shapes, o)
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (o = [],
                    s = 0,
                    c = this.material.length; s < c; s++)
                        o.push(e(t.materials, this.material[s]));
                    a.material = o
                } else
                    a.material = e(t.materials, this.material);
            if (0 < this.children.length)
                for (a.children = [],
                s = 0; s < this.children.length; s++)
                    a.children.push(this.children[s].toJSON(t).object);
            if (n) {
                n = i(t.geometries),
                s = i(t.materials),
                c = i(t.textures);
                var h = i(t.images);
                o = i(t.shapes),
                0 < n.length && (r.geometries = n),
                0 < s.length && (r.materials = s),
                0 < c.length && (r.textures = c),
                0 < h.length && (r.images = h),
                0 < o.length && (r.shapes = o)
            }
            return r.object = a,
            r
        },
        clone: function(t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function(t, e) {
            if (void 0 === e && (e = !0),
            this.name = t.name,
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
            this.layers.mask = t.layers.mask,
            this.visible = t.visible,
            this.castShadow = t.castShadow,
            this.receiveShadow = t.receiveShadow,
            this.frustumCulled = t.frustumCulled,
            this.renderOrder = t.renderOrder,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            !0 === e)
                for (e = 0; e < t.children.length; e++)
                    this.add(t.children[e].clone());
            return this
        }
    });
    var Kr = 0;
    E.prototype = Object.assign(Object.create(e.prototype), {
        constructor: E,
        isGeometry: !0,
        applyMatrix: function(t) {
            for (var e = (new a).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++)
                this.vertices[i].applyMatrix4(t);
            for (i = 0,
            n = this.faces.length; i < n; i++) {
                (t = this.faces[i]).normal.applyMatrix3(e).normalize();
                for (var r = 0, o = t.vertexNormals.length; r < o; r++)
                    t.vertexNormals[r].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.normalsNeedUpdate = this.verticesNeedUpdate = !0,
            this
        },
        rotateX: function() {
            var t = new g;
            return function(e) {
                return t.makeRotationX(e),
                this.applyMatrix(t),
                this
            }
        }(),
        rotateY: function() {
            var t = new g;
            return function(e) {
                return t.makeRotationY(e),
                this.applyMatrix(t),
                this
            }
        }(),
        rotateZ: function() {
            var t = new g;
            return function(e) {
                return t.makeRotationZ(e),
                this.applyMatrix(t),
                this
            }
        }(),
        translate: function() {
            var t = new g;
            return function(e, i, n) {
                return t.makeTranslation(e, i, n),
                this.applyMatrix(t),
                this
            }
        }(),
        scale: function() {
            var t = new g;
            return function(e, i, n) {
                return t.makeScale(e, i, n),
                this.applyMatrix(t),
                this
            }
        }(),
        lookAt: function() {
            var t = new T;
            return function(e) {
                t.lookAt(e),
                t.updateMatrix(),
                this.applyMatrix(t.matrix)
            }
        }(),
        fromBufferGeometry: function(t) {
            function e(t, e, a, o) {
                var s = void 0 === h ? [] : [n.colors[t].clone(), n.colors[e].clone(), n.colors[a].clone()];
                o = new M(t,e,a,void 0 === c ? [] : [(new r).fromArray(c, 3 * t), (new r).fromArray(c, 3 * e), (new r).fromArray(c, 3 * a)],s,o),
                n.faces.push(o),
                void 0 !== l && n.faceVertexUvs[0].push([(new i).fromArray(l, 2 * t), (new i).fromArray(l, 2 * e), (new i).fromArray(l, 2 * a)]),
                void 0 !== u && n.faceVertexUvs[1].push([(new i).fromArray(u, 2 * t), (new i).fromArray(u, 2 * e), (new i).fromArray(u, 2 * a)])
            }
            var n = this
              , a = null !== t.index ? t.index.array : void 0
              , o = t.attributes
              , s = o.position.array
              , c = void 0 !== o.normal ? o.normal.array : void 0
              , h = void 0 !== o.color ? o.color.array : void 0
              , l = void 0 !== o.uv ? o.uv.array : void 0
              , u = void 0 !== o.uv2 ? o.uv2.array : void 0;
            void 0 !== u && (this.faceVertexUvs[1] = []);
            for (var p = o = 0; o < s.length; o += 3,
            p += 2)
                n.vertices.push((new r).fromArray(s, o)),
                void 0 !== h && n.colors.push((new x).fromArray(h, o));
            var d = t.groups;
            if (0 < d.length)
                for (o = 0; o < d.length; o++) {
                    var f = (s = d[o]).start;
                    for (p = f,
                    f += s.count; p < f; p += 3)
                        void 0 !== a ? e(a[p], a[p + 1], a[p + 2], s.materialIndex) : e(p, p + 1, p + 2, s.materialIndex)
                }
            else if (void 0 !== a)
                for (o = 0; o < a.length; o += 3)
                    e(a[o], a[o + 1], a[o + 2]);
            else
                for (o = 0; o < s.length / 3; o += 3)
                    e(o, o + 1, o + 2);
            return this.computeFaceNormals(),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            this
        },
        center: function() {
            var t = new r;
            return function() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(t).negate(),
                this.translate(t.x, t.y, t.z),
                this
            }
        }(),
        normalize: function() {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center
              , e = this.boundingSphere.radius;
            e = 0 === e ? 1 : 1 / e;
            var i = new g;
            return i.set(e, 0, 0, -e * t.x, 0, e, 0, -e * t.y, 0, 0, e, -e * t.z, 0, 0, 0, 1),
            this.applyMatrix(i),
            this
        },
        computeFaceNormals: function() {
            for (var t = new r, e = new r, i = 0, n = this.faces.length; i < n; i++) {
                var a = this.faces[i]
                  , o = this.vertices[a.a]
                  , s = this.vertices[a.b];
                t.subVectors(this.vertices[a.c], s),
                e.subVectors(o, s),
                t.cross(e),
                t.normalize(),
                a.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            var e;
            void 0 === t && (t = !0);
            var i = Array(this.vertices.length)
              , n = 0;
            for (e = this.vertices.length; n < e; n++)
                i[n] = new r;
            if (t) {
                var a = new r
                  , o = new r;
                for (t = 0,
                n = this.faces.length; t < n; t++) {
                    e = this.faces[t];
                    var s = this.vertices[e.a]
                      , c = this.vertices[e.b]
                      , h = this.vertices[e.c];
                    a.subVectors(h, c),
                    o.subVectors(s, c),
                    a.cross(o),
                    i[e.a].add(a),
                    i[e.b].add(a),
                    i[e.c].add(a)
                }
            } else
                for (this.computeFaceNormals(),
                t = 0,
                n = this.faces.length; t < n; t++)
                    i[(e = this.faces[t]).a].add(e.normal),
                    i[e.b].add(e.normal),
                    i[e.c].add(e.normal);
            for (n = 0,
            e = this.vertices.length; n < e; n++)
                i[n].normalize();
            for (t = 0,
            n = this.faces.length; t < n; t++)
                3 === (s = (e = this.faces[t]).vertexNormals).length ? (s[0].copy(i[e.a]),
                s[1].copy(i[e.b]),
                s[2].copy(i[e.c])) : (s[0] = i[e.a].clone(),
                s[1] = i[e.b].clone(),
                s[2] = i[e.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var t;
            this.computeFaceNormals();
            var e = 0;
            for (t = this.faces.length; e < t; e++) {
                var i = this.faces[e]
                  , n = i.vertexNormals;
                3 === n.length ? (n[0].copy(i.normal),
                n[1].copy(i.normal),
                n[2].copy(i.normal)) : (n[0] = i.normal.clone(),
                n[1] = i.normal.clone(),
                n[2] = i.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var t, e, i = 0;
            for (e = this.faces.length; i < e; i++) {
                var n = this.faces[i];
                n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(),
                n.__originalVertexNormals || (n.__originalVertexNormals = []);
                var a = 0;
                for (t = n.vertexNormals.length; a < t; a++)
                    n.__originalVertexNormals[a] ? n.__originalVertexNormals[a].copy(n.vertexNormals[a]) : n.__originalVertexNormals[a] = n.vertexNormals[a].clone()
            }
            var o = new E;
            for (o.faces = this.faces,
            a = 0,
            t = this.morphTargets.length; a < t; a++) {
                if (!this.morphNormals[a]) {
                    this.morphNormals[a] = {},
                    this.morphNormals[a].faceNormals = [],
                    this.morphNormals[a].vertexNormals = [],
                    n = this.morphNormals[a].faceNormals;
                    var s = this.morphNormals[a].vertexNormals;
                    for (i = 0,
                    e = this.faces.length; i < e; i++) {
                        var c = new r
                          , h = {
                            a: new r,
                            b: new r,
                            c: new r
                        };
                        n.push(c),
                        s.push(h)
                    }
                }
                for (s = this.morphNormals[a],
                o.vertices = this.morphTargets[a].vertices,
                o.computeFaceNormals(),
                o.computeVertexNormals(),
                i = 0,
                e = this.faces.length; i < e; i++)
                    n = this.faces[i],
                    c = s.faceNormals[i],
                    h = s.vertexNormals[i],
                    c.copy(n.normal),
                    h.a.copy(n.vertexNormals[0]),
                    h.b.copy(n.vertexNormals[1]),
                    h.c.copy(n.vertexNormals[2])
            }
            for (i = 0,
            e = this.faces.length; i < e; i++)
                (n = this.faces[i]).normal = n.__originalFaceNormal,
                n.vertexNormals = n.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new p),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new d),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, i) {
            if (t && t.isGeometry) {
                var n, r = this.vertices.length, o = this.vertices, s = t.vertices, c = this.faces, h = t.faces, l = this.faceVertexUvs[0], u = t.faceVertexUvs[0], p = this.colors, d = t.colors;
                void 0 === i && (i = 0),
                void 0 !== e && (n = (new a).getNormalMatrix(e)),
                t = 0;
                for (var f = s.length; t < f; t++) {
                    var m = s[t].clone();
                    void 0 !== e && m.applyMatrix4(e),
                    o.push(m)
                }
                for (t = 0,
                f = d.length; t < f; t++)
                    p.push(d[t].clone());
                for (t = 0,
                f = h.length; t < f; t++) {
                    var g = (s = h[t]).vertexNormals;
                    for (d = s.vertexColors,
                    (p = new M(s.a + r,s.b + r,s.c + r)).normal.copy(s.normal),
                    void 0 !== n && p.normal.applyMatrix3(n).normalize(),
                    e = 0,
                    o = g.length; e < o; e++)
                        m = g[e].clone(),
                        void 0 !== n && m.applyMatrix3(n).normalize(),
                        p.vertexNormals.push(m);
                    for (p.color.copy(s.color),
                    e = 0,
                    o = d.length; e < o; e++)
                        m = d[e],
                        p.vertexColors.push(m.clone());
                    p.materialIndex = s.materialIndex + i,
                    c.push(p)
                }
                for (t = 0,
                f = u.length; t < f; t++)
                    if (n = [],
                    void 0 !== (i = u[t])) {
                        for (e = 0,
                        o = i.length; e < o; e++)
                            n.push(i[e].clone());
                        l.push(n)
                    }
            }
        },
        mergeMesh: function(t) {
            t && t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(),
            this.merge(t.geometry, t.matrix))
        },
        mergeVertices: function() {
            var t, e = {}, i = [], n = [], r = Math.pow(10, 4), a = 0;
            for (t = this.vertices.length; a < t; a++) {
                var o = this.vertices[a];
                void 0 === e[o = Math.round(o.x * r) + "_" + Math.round(o.y * r) + "_" + Math.round(o.z * r)] ? (e[o] = a,
                i.push(this.vertices[a]),
                n[a] = i.length - 1) : n[a] = n[e[o]]
            }
            for (e = [],
            a = 0,
            t = this.faces.length; a < t; a++)
                for ((r = this.faces[a]).a = n[r.a],
                r.b = n[r.b],
                r.c = n[r.c],
                r = [r.a, r.b, r.c],
                o = 0; 3 > o; o++)
                    if (r[o] === r[(o + 1) % 3]) {
                        e.push(a);
                        break
                    }
            for (a = e.length - 1; 0 <= a; a--)
                for (r = e[a],
                this.faces.splice(r, 1),
                n = 0,
                t = this.faceVertexUvs.length; n < t; n++)
                    this.faceVertexUvs[n].splice(r, 1);
            return a = this.vertices.length - i.length,
            this.vertices = i,
            a
        },
        setFromPoints: function(t) {
            this.vertices = [];
            for (var e = 0, i = t.length; e < i; e++) {
                var n = t[e];
                this.vertices.push(new r(n.x,n.y,n.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var t = this.faces, e = t.length, i = 0; i < e; i++)
                t[i]._id = i;
            t.sort(function(t, e) {
                return t.materialIndex - e.materialIndex
            });
            var n, r, a = this.faceVertexUvs[0], o = this.faceVertexUvs[1];
            for (a && a.length === e && (n = []),
            o && o.length === e && (r = []),
            i = 0; i < e; i++) {
                var s = t[i]._id;
                n && n.push(a[s]),
                r && r.push(o[s])
            }
            n && (this.faceVertexUvs[0] = n),
            r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function() {
            function t(t, e, i) {
                return i ? t | 1 << e : t & ~(1 << e)
            }
            function e(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== h[e] ? h[e] : (h[e] = c.length / 3,
                c.push(t.x, t.y, t.z),
                h[e])
            }
            function i(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== u[e] ? u[e] : (u[e] = l.length,
                l.push(t.getHex()),
                u[e])
            }
            function n(t) {
                var e = t.x.toString() + t.y.toString();
                return void 0 !== d[e] ? d[e] : (d[e] = p.length / 2,
                p.push(t.x, t.y),
                d[e])
            }
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (r.uuid = this.uuid,
            r.type = this.type,
            "" !== this.name && (r.name = this.name),
            void 0 !== this.parameters) {
                var a, o = this.parameters;
                for (a in o)
                    void 0 !== o[a] && (r[a] = o[a]);
                return r
            }
            for (o = [],
            a = 0; a < this.vertices.length; a++) {
                var s = this.vertices[a];
                o.push(s.x, s.y, s.z)
            }
            s = [];
            var c = []
              , h = {}
              , l = []
              , u = {}
              , p = []
              , d = {};
            for (a = 0; a < this.faces.length; a++) {
                var f = this.faces[a]
                  , m = void 0 !== this.faceVertexUvs[0][a]
                  , g = 0 < f.normal.length()
                  , v = 0 < f.vertexNormals.length
                  , y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b
                  , x = 0 < f.vertexColors.length
                  , b = 0;
                b = t(b = t(b = t(b = t(b = t(b = t(b = t(b = t(b, 0, 0), 1, !0), 2, !1), 3, m), 4, g), 5, v), 6, y), 7, x),
                s.push(b),
                s.push(f.a, f.b, f.c),
                s.push(f.materialIndex),
                m && (m = this.faceVertexUvs[0][a],
                s.push(n(m[0]), n(m[1]), n(m[2]))),
                g && s.push(e(f.normal)),
                v && (g = f.vertexNormals,
                s.push(e(g[0]), e(g[1]), e(g[2]))),
                y && s.push(i(f.color)),
                x && (f = f.vertexColors,
                s.push(i(f[0]), i(f[1]), i(f[2])))
            }
            return r.data = {},
            r.data.vertices = o,
            r.data.normals = c,
            0 < l.length && (r.data.colors = l),
            0 < p.length && (r.data.uvs = [p]),
            r.data.faces = s,
            r
        },
        clone: function() {
            return (new E).copy(this)
        },
        copy: function(t) {
            var e, i, n;
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingSphere = this.boundingBox = null,
            this.name = t.name;
            var r = t.vertices
              , a = 0;
            for (e = r.length; a < e; a++)
                this.vertices.push(r[a].clone());
            for (a = 0,
            e = (r = t.colors).length; a < e; a++)
                this.colors.push(r[a].clone());
            for (a = 0,
            e = (r = t.faces).length; a < e; a++)
                this.faces.push(r[a].clone());
            for (a = 0,
            e = t.faceVertexUvs.length; a < e; a++) {
                var o = t.faceVertexUvs[a];
                for (void 0 === this.faceVertexUvs[a] && (this.faceVertexUvs[a] = []),
                r = 0,
                i = o.length; r < i; r++) {
                    var s = o[r]
                      , c = []
                      , h = 0;
                    for (n = s.length; h < n; h++)
                        c.push(s[h].clone());
                    this.faceVertexUvs[a].push(c)
                }
            }
            for (a = 0,
            e = (h = t.morphTargets).length; a < e; a++) {
                if ((n = {}).name = h[a].name,
                void 0 !== h[a].vertices)
                    for (n.vertices = [],
                    r = 0,
                    i = h[a].vertices.length; r < i; r++)
                        n.vertices.push(h[a].vertices[r].clone());
                if (void 0 !== h[a].normals)
                    for (n.normals = [],
                    r = 0,
                    i = h[a].normals.length; r < i; r++)
                        n.normals.push(h[a].normals[r].clone());
                this.morphTargets.push(n)
            }
            for (a = 0,
            e = (h = t.morphNormals).length; a < e; a++) {
                if (n = {},
                void 0 !== h[a].vertexNormals)
                    for (n.vertexNormals = [],
                    r = 0,
                    i = h[a].vertexNormals.length; r < i; r++)
                        o = h[a].vertexNormals[r],
                        (s = {}).a = o.a.clone(),
                        s.b = o.b.clone(),
                        s.c = o.c.clone(),
                        n.vertexNormals.push(s);
                if (void 0 !== h[a].faceNormals)
                    for (n.faceNormals = [],
                    r = 0,
                    i = h[a].faceNormals.length; r < i; r++)
                        n.faceNormals.push(h[a].faceNormals[r].clone());
                this.morphNormals.push(n)
            }
            for (a = 0,
            e = (r = t.skinWeights).length; a < e; a++)
                this.skinWeights.push(r[a].clone());
            for (a = 0,
            e = (r = t.skinIndices).length; a < e; a++)
                this.skinIndices.push(r[a].clone());
            for (a = 0,
            e = (r = t.lineDistances).length; a < e; a++)
                this.lineDistances.push(r[a]);
            return null !== (a = t.boundingBox) && (this.boundingBox = a.clone()),
            null !== (a = t.boundingSphere) && (this.boundingSphere = a.clone()),
            this.elementsNeedUpdate = t.elementsNeedUpdate,
            this.verticesNeedUpdate = t.verticesNeedUpdate,
            this.uvsNeedUpdate = t.uvsNeedUpdate,
            this.normalsNeedUpdate = t.normalsNeedUpdate,
            this.colorsNeedUpdate = t.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = t.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(A.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(A.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(t) {
            if (Array.isArray(t))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== t ? t.length / this.itemSize : 0,
            this.array = t,
            this
        },
        setDynamic: function(t) {
            return this.dynamic = t,
            this
        },
        copy: function(t) {
            return this.name = t.name,
            this.array = new t.array.constructor(t.array),
            this.itemSize = t.itemSize,
            this.count = t.count,
            this.normalized = t.normalized,
            this.dynamic = t.dynamic,
            this
        },
        copyAt: function(t, e, i) {
            t *= this.itemSize,
            i *= e.itemSize;
            for (var n = 0, r = this.itemSize; n < r; n++)
                this.array[t + n] = e.array[i + n];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t),
            this
        },
        copyColorsArray: function(t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var a = t[n];
                void 0 === a && (a = new x),
                e[i++] = a.r,
                e[i++] = a.g,
                e[i++] = a.b
            }
            return this
        },
        copyVector2sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, a = t.length; r < a; r++) {
                var o = t[r];
                void 0 === o && (o = new i),
                e[n++] = o.x,
                e[n++] = o.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            for (var e = this.array, i = 0, n = 0, a = t.length; n < a; n++) {
                var o = t[n];
                void 0 === o && (o = new r),
                e[i++] = o.x,
                e[i++] = o.y,
                e[i++] = o.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var a = t[n];
                void 0 === a && (a = new s),
                e[i++] = a.x,
                e[i++] = a.y,
                e[i++] = a.z,
                e[i++] = a.w
            }
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0),
            this.array.set(t, e),
            this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e,
            this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e,
            this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e,
            this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e,
            this
        },
        setXY: function(t, e, i) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = i,
            this
        },
        setXYZ: function(t, e, i, n) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = i,
            this.array[t + 2] = n,
            this
        },
        setXYZW: function(t, e, i, n, r) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = i,
            this.array[t + 2] = n,
            this.array[t + 3] = r,
            this
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        }
    }),
    L.prototype = Object.create(A.prototype),
    L.prototype.constructor = L,
    P.prototype = Object.create(A.prototype),
    P.prototype.constructor = P,
    C.prototype = Object.create(A.prototype),
    C.prototype.constructor = C,
    I.prototype = Object.create(A.prototype),
    I.prototype.constructor = I,
    R.prototype = Object.create(A.prototype),
    R.prototype.constructor = R,
    O.prototype = Object.create(A.prototype),
    O.prototype.constructor = O,
    D.prototype = Object.create(A.prototype),
    D.prototype.constructor = D,
    z.prototype = Object.create(A.prototype),
    z.prototype.constructor = z,
    B.prototype = Object.create(A.prototype),
    B.prototype.constructor = B,
    Object.assign(N.prototype, {
        computeGroups: function(t) {
            var e = []
              , i = void 0;
            t = t.faces;
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                if (r.materialIndex !== i) {
                    i = r.materialIndex,
                    void 0 !== a && (a.count = 3 * n - a.start,
                    e.push(a));
                    var a = {
                        start: 3 * n,
                        materialIndex: i
                    }
                }
            }
            void 0 !== a && (a.count = 3 * n - a.start,
            e.push(a)),
            this.groups = e
        },
        fromGeometry: function(t) {
            var e = t.faces
              , n = t.vertices
              , r = t.faceVertexUvs
              , a = r[0] && 0 < r[0].length
              , o = r[1] && 0 < r[1].length
              , s = t.morphTargets
              , c = s.length;
            if (0 < c) {
                for (var h = [], l = 0; l < c; l++)
                    h[l] = {
                        name: s[l].name,
                        data: []
                    };
                this.morphTargets.position = h
            }
            var u = t.morphNormals
              , p = u.length;
            if (0 < p) {
                var d = [];
                for (l = 0; l < p; l++)
                    d[l] = {
                        name: u[l].name,
                        data: []
                    };
                this.morphTargets.normal = d
            }
            var f = t.skinIndices
              , m = t.skinWeights
              , g = f.length === n.length
              , v = m.length === n.length;
            for (0 < n.length && e.length,
            l = 0; l < e.length; l++) {
                var y = e[l];
                this.vertices.push(n[y.a], n[y.b], n[y.c]);
                var x = y.vertexNormals;
                for (3 === x.length ? this.normals.push(x[0], x[1], x[2]) : (x = y.normal,
                this.normals.push(x, x, x)),
                3 === (x = y.vertexColors).length ? this.colors.push(x[0], x[1], x[2]) : (x = y.color,
                this.colors.push(x, x, x)),
                !0 === a && (void 0 !== (x = r[0][l]) ? this.uvs.push(x[0], x[1], x[2]) : this.uvs.push(new i, new i, new i)),
                !0 === o && (void 0 !== (x = r[1][l]) ? this.uvs2.push(x[0], x[1], x[2]) : this.uvs2.push(new i, new i, new i)),
                x = 0; x < c; x++) {
                    var b = s[x].vertices;
                    h[x].data.push(b[y.a], b[y.b], b[y.c])
                }
                for (x = 0; x < p; x++)
                    b = u[x].vertexNormals[l],
                    d[x].data.push(b.a, b.b, b.c);
                g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]),
                v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
            }
            return this.computeGroups(t),
            this.verticesNeedUpdate = t.verticesNeedUpdate,
            this.normalsNeedUpdate = t.normalsNeedUpdate,
            this.colorsNeedUpdate = t.colorsNeedUpdate,
            this.uvsNeedUpdate = t.uvsNeedUpdate,
            this.groupsNeedUpdate = t.groupsNeedUpdate,
            this
        }
    });
    var $r = 1;
    U.prototype = Object.assign(Object.create(e.prototype), {
        constructor: U,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(t) {
            Array.isArray(t) ? this.index = new (65535 < k(t) ? D : R)(t,1) : this.index = t
        },
        addAttribute: function(t, e, i) {
            return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (this.setIndex(e),
            this) : (this.attributes[t] = e,
            this) : this.addAttribute(t, new A(e,i))
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        removeAttribute: function(t) {
            return delete this.attributes[t],
            this
        },
        addGroup: function(t, e, i) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== i ? i : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(t, e) {
            this.drawRange.start = t,
            this.drawRange.count = e
        },
        applyMatrix: function(t) {
            var e = this.attributes.position;
            void 0 !== e && (t.applyToBufferAttribute(e),
            e.needsUpdate = !0);
            var i = this.attributes.normal;
            return void 0 !== i && ((e = (new a).getNormalMatrix(t)).applyToBufferAttribute(i),
            i.needsUpdate = !0),
            void 0 !== (i = this.attributes.tangent) && ((e = (new a).getNormalMatrix(t)).applyToBufferAttribute(i),
            i.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: function() {
            var t = new g;
            return function(e) {
                return t.makeRotationX(e),
                this.applyMatrix(t),
                this
            }
        }(),
        rotateY: function() {
            var t = new g;
            return function(e) {
                return t.makeRotationY(e),
                this.applyMatrix(t),
                this
            }
        }(),
        rotateZ: function() {
            var t = new g;
            return function(e) {
                return t.makeRotationZ(e),
                this.applyMatrix(t),
                this
            }
        }(),
        translate: function() {
            var t = new g;
            return function(e, i, n) {
                return t.makeTranslation(e, i, n),
                this.applyMatrix(t),
                this
            }
        }(),
        scale: function() {
            var t = new g;
            return function(e, i, n) {
                return t.makeScale(e, i, n),
                this.applyMatrix(t),
                this
            }
        }(),
        lookAt: function() {
            var t = new T;
            return function(e) {
                t.lookAt(e),
                t.updateMatrix(),
                this.applyMatrix(t.matrix)
            }
        }(),
        center: function() {
            var t = new r;
            return function() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(t).negate(),
                this.translate(t.x, t.y, t.z),
                this
            }
        }(),
        setFromObject: function(t) {
            var e = t.geometry;
            if (t.isPoints || t.isLine) {
                t = new z(3 * e.vertices.length,3);
                var i = new z(3 * e.colors.length,3);
                this.addAttribute("position", t.copyVector3sArray(e.vertices)),
                this.addAttribute("color", i.copyColorsArray(e.colors)),
                e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new z(e.lineDistances.length,1),
                this.addAttribute("lineDistance", t.copyArray(e.lineDistances))),
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else
                t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        },
        setFromPoints: function(t) {
            for (var e = [], i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.push(r.x, r.y, r.z || 0)
            }
            return this.addAttribute("position", new z(e,3)),
            this
        },
        updateFromObject: function(t) {
            var e = t.geometry;
            if (t.isMesh) {
                var i = e.__directGeometry;
                if (!0 === e.elementsNeedUpdate && (i = void 0,
                e.elementsNeedUpdate = !1),
                void 0 === i)
                    return this.fromGeometry(e);
                i.verticesNeedUpdate = e.verticesNeedUpdate,
                i.normalsNeedUpdate = e.normalsNeedUpdate,
                i.colorsNeedUpdate = e.colorsNeedUpdate,
                i.uvsNeedUpdate = e.uvsNeedUpdate,
                i.groupsNeedUpdate = e.groupsNeedUpdate,
                e.verticesNeedUpdate = !1,
                e.normalsNeedUpdate = !1,
                e.colorsNeedUpdate = !1,
                e.uvsNeedUpdate = !1,
                e.groupsNeedUpdate = !1,
                e = i
            }
            return !0 === e.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(e.vertices),
            i.needsUpdate = !0),
            e.verticesNeedUpdate = !1),
            !0 === e.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(e.normals),
            i.needsUpdate = !0),
            e.normalsNeedUpdate = !1),
            !0 === e.colorsNeedUpdate && (void 0 !== (i = this.attributes.color) && (i.copyColorsArray(e.colors),
            i.needsUpdate = !0),
            e.colorsNeedUpdate = !1),
            e.uvsNeedUpdate && (void 0 !== (i = this.attributes.uv) && (i.copyVector2sArray(e.uvs),
            i.needsUpdate = !0),
            e.uvsNeedUpdate = !1),
            e.lineDistancesNeedUpdate && (void 0 !== (i = this.attributes.lineDistance) && (i.copyArray(e.lineDistances),
            i.needsUpdate = !0),
            e.lineDistancesNeedUpdate = !1),
            e.groupsNeedUpdate && (e.computeGroups(t.geometry),
            this.groups = e.groups,
            e.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(t) {
            return t.__directGeometry = (new N).fromGeometry(t),
            this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function(t) {
            var e = new Float32Array(3 * t.vertices.length);
            for (var i in this.addAttribute("position", new A(e,3).copyVector3sArray(t.vertices)),
            0 < t.normals.length && (e = new Float32Array(3 * t.normals.length),
            this.addAttribute("normal", new A(e,3).copyVector3sArray(t.normals))),
            0 < t.colors.length && (e = new Float32Array(3 * t.colors.length),
            this.addAttribute("color", new A(e,3).copyColorsArray(t.colors))),
            0 < t.uvs.length && (e = new Float32Array(2 * t.uvs.length),
            this.addAttribute("uv", new A(e,2).copyVector2sArray(t.uvs))),
            0 < t.uvs2.length && (e = new Float32Array(2 * t.uvs2.length),
            this.addAttribute("uv2", new A(e,2).copyVector2sArray(t.uvs2))),
            this.groups = t.groups,
            t.morphTargets) {
                e = [];
                for (var n = t.morphTargets[i], r = 0, a = n.length; r < a; r++) {
                    var o = n[r]
                      , s = new z(3 * o.data.length,3);
                    s.name = o.name,
                    e.push(s.copyVector3sArray(o.data))
                }
                this.morphAttributes[i] = e
            }
            return 0 < t.skinIndices.length && (i = new z(4 * t.skinIndices.length,4),
            this.addAttribute("skinIndex", i.copyVector4sArray(t.skinIndices))),
            0 < t.skinWeights.length && (i = new z(4 * t.skinWeights.length,4),
            this.addAttribute("skinWeight", i.copyVector4sArray(t.skinWeights))),
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            var t = new p;
            return function() {
                null === this.boundingBox && (this.boundingBox = new p);
                var e = this.attributes.position
                  , i = this.morphAttributes.position;
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e),
                    i) {
                        e = 0;
                        for (var n = i.length; e < n; e++)
                            t.setFromBufferAttribute(i[e]),
                            this.boundingBox.expandByPoint(t.min),
                            this.boundingBox.expandByPoint(t.max)
                    }
                } else
                    this.boundingBox.makeEmpty();
                isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
            }
        }(),
        computeBoundingSphere: function() {
            var t = new p
              , e = new p
              , i = new r;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new d);
                var n = this.attributes.position
                  , r = this.morphAttributes.position;
                if (n) {
                    var a = this.boundingSphere.center;
                    if (t.setFromBufferAttribute(n),
                    r)
                        for (var o = 0, s = r.length; o < s; o++) {
                            var c = r[o];
                            e.setFromBufferAttribute(c),
                            t.expandByPoint(e.min),
                            t.expandByPoint(e.max)
                        }
                    t.getCenter(a);
                    var h = 0;
                    for (o = 0,
                    s = n.count; o < s; o++)
                        i.fromBufferAttribute(n, o),
                        h = Math.max(h, a.distanceToSquared(i));
                    if (r)
                        for (o = 0,
                        s = r.length; o < s; o++) {
                            n = 0;
                            for (var l = (c = r[o]).count; n < l; n++)
                                i.fromBufferAttribute(c, o),
                                h = Math.max(h, a.distanceToSquared(i))
                        }
                    this.boundingSphere.radius = Math.sqrt(h),
                    isNaN(this.boundingSphere.radius)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var t = this.index
              , e = this.attributes;
            if (e.position) {
                var i = e.position.array;
                if (void 0 === e.normal)
                    this.addAttribute("normal", new A(new Float32Array(i.length),3));
                else
                    for (var n = e.normal.array, a = 0, o = n.length; a < o; a++)
                        n[a] = 0;
                n = e.normal.array;
                var s = new r
                  , c = new r
                  , h = new r
                  , l = new r
                  , u = new r;
                if (t) {
                    var p = t.array;
                    for (a = 0,
                    o = t.count; a < o; a += 3) {
                        t = 3 * p[a + 0];
                        var d = 3 * p[a + 1]
                          , f = 3 * p[a + 2];
                        s.fromArray(i, t),
                        c.fromArray(i, d),
                        h.fromArray(i, f),
                        l.subVectors(h, c),
                        u.subVectors(s, c),
                        l.cross(u),
                        n[t] += l.x,
                        n[t + 1] += l.y,
                        n[t + 2] += l.z,
                        n[d] += l.x,
                        n[d + 1] += l.y,
                        n[d + 2] += l.z,
                        n[f] += l.x,
                        n[f + 1] += l.y,
                        n[f + 2] += l.z
                    }
                } else
                    for (a = 0,
                    o = i.length; a < o; a += 9)
                        s.fromArray(i, a),
                        c.fromArray(i, a + 3),
                        h.fromArray(i, a + 6),
                        l.subVectors(h, c),
                        u.subVectors(s, c),
                        l.cross(u),
                        n[a] = l.x,
                        n[a + 1] = l.y,
                        n[a + 2] = l.z,
                        n[a + 3] = l.x,
                        n[a + 4] = l.y,
                        n[a + 5] = l.z,
                        n[a + 6] = l.x,
                        n[a + 7] = l.y,
                        n[a + 8] = l.z;
                this.normalizeNormals(),
                e.normal.needsUpdate = !0
            }
        },
        merge: function(t, e) {
            if (t && t.isBufferGeometry) {
                void 0 === e && (e = 0);
                var i, n = this.attributes;
                for (i in n)
                    if (void 0 !== t.attributes[i]) {
                        var r = n[i].array
                          , a = t.attributes[i]
                          , o = a.array
                          , s = 0;
                        for (a = a.itemSize * e; s < o.length; s++,
                        a++)
                            r[a] = o[s]
                    }
                return this
            }
        },
        normalizeNormals: function() {
            var t = new r;
            return function() {
                for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++)
                    t.x = e.getX(i),
                    t.y = e.getY(i),
                    t.z = e.getZ(i),
                    t.normalize(),
                    e.setXYZ(i, t.x, t.y, t.z)
            }
        }(),
        toNonIndexed: function() {
            function t(t, e) {
                var i = t.array;
                t = t.itemSize;
                for (var n, r = new i.constructor(e.length * t), a = 0, o = 0, s = e.length; o < s; o++) {
                    n = e[o] * t;
                    for (var c = 0; c < t; c++)
                        r[a++] = i[n++]
                }
                return new A(r,t)
            }
            if (null === this.index)
                return this;
            var e, i = new U, n = this.index.array, r = this.attributes;
            for (e in r) {
                var a = r[e];
                a = t(a, n),
                i.addAttribute(e, a)
            }
            var o = this.morphAttributes;
            for (e in o) {
                var s = []
                  , c = o[e];
                r = 0;
                for (var h = c.length; r < h; r++)
                    a = t(a = c[r], n),
                    s.push(a);
                i.morphAttributes[e] = s
            }
            for (r = 0,
            e = (n = this.groups).length; r < e; r++)
                a = n[r],
                i.addGroup(a.start, a.count, a.materialIndex);
            return i
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid,
            t.type = this.type,
            "" !== this.name && (t.name = this.name),
            0 < Object.keys(this.userData).length && (t.userData = this.userData),
            void 0 !== this.parameters) {
                var e = this.parameters;
                for (h in e)
                    void 0 !== e[h] && (t[h] = e[h]);
                return t
            }
            t.data = {
                attributes: {}
            },
            null !== (e = this.index) && (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array)
            });
            var i = this.attributes;
            for (h in i) {
                var n = {
                    itemSize: (e = i[h]).itemSize,
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array),
                    normalized: e.normalized
                };
                "" !== e.name && (n.name = e.name),
                t.data.attributes[h] = n
            }
            i = {};
            var r = !1;
            for (h in this.morphAttributes) {
                for (var a = this.morphAttributes[h], o = [], s = 0, c = a.length; s < c; s++)
                    n = {
                        itemSize: (e = a[s]).itemSize,
                        type: e.array.constructor.name,
                        array: Array.prototype.slice.call(e.array),
                        normalized: e.normalized
                    },
                    "" !== e.name && (n.name = e.name),
                    o.push(n);
                0 < o.length && (i[h] = o,
                r = !0)
            }
            r && (t.data.morphAttributes = i);
            var h = this.groups;
            return 0 < h.length && (t.data.groups = JSON.parse(JSON.stringify(h))),
            null !== (h = this.boundingSphere) && (t.data.boundingSphere = {
                center: h.center.toArray(),
                radius: h.radius
            }),
            t
        },
        clone: function() {
            return (new U).copy(this)
        },
        copy: function(t) {
            var e;
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingSphere = this.boundingBox = null,
            this.name = t.name;
            var i = t.index;
            for (o in null !== i && this.setIndex(i.clone()),
            i = t.attributes)
                this.addAttribute(o, i[o].clone());
            var n = t.morphAttributes;
            for (o in n) {
                var r = []
                  , a = n[o];
                for (i = 0,
                e = a.length; i < e; i++)
                    r.push(a[i].clone());
                this.morphAttributes[o] = r
            }
            var o = t.groups;
            for (i = 0,
            e = o.length; i < e; i++)
                n = o[i],
                this.addGroup(n.start, n.count, n.materialIndex);
            return null !== (o = t.boundingBox) && (this.boundingBox = o.clone()),
            null !== (o = t.boundingSphere) && (this.boundingSphere = o.clone()),
            this.drawRange.start = t.drawRange.start,
            this.drawRange.count = t.drawRange.count,
            this.userData = t.userData,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    F.prototype = Object.create(E.prototype),
    F.prototype.constructor = F,
    G.prototype = Object.create(U.prototype),
    G.prototype.constructor = G,
    V.prototype = Object.create(E.prototype),
    V.prototype.constructor = V,
    j.prototype = Object.create(U.prototype),
    j.prototype.constructor = j;
    var ta = 0;
    H.prototype = Object.assign(Object.create(e.prototype), {
        constructor: H,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(t) {
            if (void 0 !== t)
                for (var e in t) {
                    var i = t[e];
                    if (void 0 === i)
                        ;
                    else if ("shading" === e)
                        this.flatShading = 1 === i;
                    else {
                        var n = this[e];
                        void 0 === n || (n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i)
                    }
                }
        },
        toJSON: function(t) {
            function e(t) {
                var e, i = [];
                for (e in t) {
                    var n = t[e];
                    delete n.metadata,
                    i.push(n)
                }
                return i
            }
            var i = void 0 === t || "string" == typeof t;
            i && (t = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            return n.uuid = this.uuid,
            n.type = this.type,
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
            1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat),
            void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid),
            this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
            n.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
            n.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
            n.normalMapType = this.normalMapType,
            n.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
            n.displacementScale = this.displacementScale,
            n.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
            n.reflectivity = this.reflectivity,
            void 0 !== this.combine && (n.combine = this.combine),
            void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)),
            this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.size && (n.size = this.size),
            void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            0 !== this.side && (n.side = this.side),
            0 !== this.vertexColors && (n.vertexColors = this.vertexColors),
            1 > this.opacity && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            n.depthFunc = this.depthFunc,
            n.depthTest = this.depthTest,
            n.depthWrite = this.depthWrite,
            0 !== this.rotation && (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
            1 !== this.linewidth && (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            0 < this.alphaTest && (n.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (n.morphTargets = !0),
            !0 === this.skinning && (n.skinning = !0),
            !1 === this.visible && (n.visible = !1),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            i && (i = e(t.textures),
            t = e(t.images),
            0 < i.length && (n.textures = i),
            0 < t.length && (n.images = t)),
            n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name,
            this.fog = t.fog,
            this.lights = t.lights,
            this.blending = t.blending,
            this.side = t.side,
            this.flatShading = t.flatShading,
            this.vertexColors = t.vertexColors,
            this.opacity = t.opacity,
            this.transparent = t.transparent,
            this.blendSrc = t.blendSrc,
            this.blendDst = t.blendDst,
            this.blendEquation = t.blendEquation,
            this.blendSrcAlpha = t.blendSrcAlpha,
            this.blendDstAlpha = t.blendDstAlpha,
            this.blendEquationAlpha = t.blendEquationAlpha,
            this.depthFunc = t.depthFunc,
            this.depthTest = t.depthTest,
            this.depthWrite = t.depthWrite,
            this.colorWrite = t.colorWrite,
            this.precision = t.precision,
            this.polygonOffset = t.polygonOffset,
            this.polygonOffsetFactor = t.polygonOffsetFactor,
            this.polygonOffsetUnits = t.polygonOffsetUnits,
            this.dithering = t.dithering,
            this.alphaTest = t.alphaTest,
            this.premultipliedAlpha = t.premultipliedAlpha,
            this.visible = t.visible,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            this.clipShadows = t.clipShadows,
            this.clipIntersection = t.clipIntersection;
            var e = t.clippingPlanes
              , i = null;
            if (null !== e) {
                var n = e.length;
                i = Array(n);
                for (var r = 0; r !== n; ++r)
                    i[r] = e[r].clone()
            }
            return this.clippingPlanes = i,
            this.shadowSide = t.shadowSide,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    W.prototype = Object.create(H.prototype),
    W.prototype.constructor = W,
    W.prototype.isShaderMaterial = !0,
    W.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.fragmentShader = t.fragmentShader,
        this.vertexShader = t.vertexShader,
        this.uniforms = v(t.uniforms),
        this.defines = Object.assign({}, t.defines),
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.lights = t.lights,
        this.clipping = t.clipping,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this.extensions = t.extensions,
        this
    }
    ,
    W.prototype.toJSON = function(t) {
        var e = H.prototype.toJSON.call(this, t);
        for (var i in e.uniforms = {},
        this.uniforms) {
            var n = this.uniforms[i].value;
            e.uniforms[i] = n && n.isTexture ? {
                type: "t",
                value: n.toJSON(t).uuid
            } : n && n.isColor ? {
                type: "c",
                value: n.getHex()
            } : n && n.isVector2 ? {
                type: "v2",
                value: n.toArray()
            } : n && n.isVector3 ? {
                type: "v3",
                value: n.toArray()
            } : n && n.isVector4 ? {
                type: "v4",
                value: n.toArray()
            } : n && n.isMatrix3 ? {
                type: "m3",
                value: n.toArray()
            } : n && n.isMatrix4 ? {
                type: "m4",
                value: n.toArray()
            } : {
                value: n
            }
        }
        for (var r in 0 < Object.keys(this.defines).length && (e.defines = this.defines),
        e.vertexShader = this.vertexShader,
        e.fragmentShader = this.fragmentShader,
        t = {},
        this.extensions)
            !0 === this.extensions[r] && (t[r] = !0);
        return 0 < Object.keys(t).length && (e.extensions = t),
        e
    }
    ,
    Object.assign(X.prototype, {
        set: function(t, e) {
            return this.origin.copy(t),
            this.direction.copy(e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.origin.copy(t.origin),
            this.direction.copy(t.direction),
            this
        },
        at: function(t, e) {
            return void 0 === e && (e = new r),
            e.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        lookAt: function(t) {
            return this.direction.copy(t).sub(this.origin).normalize(),
            this
        },
        recast: function() {
            var t = new r;
            return function(e) {
                return this.origin.copy(this.at(e, t)),
                this
            }
        }(),
        closestPointToPoint: function(t, e) {
            return void 0 === e && (e = new r),
            e.subVectors(t, this.origin),
            0 > (t = e.dot(this.direction)) ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        distanceToPoint: function(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: function() {
            var t = new r;
            return function(e) {
                var i = t.subVectors(e, this.origin).dot(this.direction);
                return 0 > i ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin),
                t.distanceToSquared(e))
            }
        }(),
        distanceSqToSegment: function() {
            var t = new r
              , e = new r
              , i = new r;
            return function(n, r, a, o) {
                t.copy(n).add(r).multiplyScalar(.5),
                e.copy(r).sub(n).normalize(),
                i.copy(this.origin).sub(t);
                var s = .5 * n.distanceTo(r)
                  , c = -this.direction.dot(e)
                  , h = i.dot(this.direction)
                  , l = -i.dot(e)
                  , u = i.lengthSq()
                  , p = Math.abs(1 - c * c);
                if (0 < p) {
                    r = c * h - l;
                    var d = s * p;
                    0 <= (n = c * l - h) ? r >= -d ? r <= d ? c = (n *= s = 1 / p) * (n + c * (r *= s) + 2 * h) + r * (c * n + r + 2 * l) + u : (r = s,
                    c = -(n = Math.max(0, -(c * r + h))) * n + r * (r + 2 * l) + u) : (r = -s,
                    c = -(n = Math.max(0, -(c * r + h))) * n + r * (r + 2 * l) + u) : r <= -d ? c = -(n = Math.max(0, -(-c * s + h))) * n + (r = 0 < n ? -s : Math.min(Math.max(-s, -l), s)) * (r + 2 * l) + u : r <= d ? (n = 0,
                    c = (r = Math.min(Math.max(-s, -l), s)) * (r + 2 * l) + u) : c = -(n = Math.max(0, -(c * s + h))) * n + (r = 0 < n ? s : Math.min(Math.max(-s, -l), s)) * (r + 2 * l) + u
                } else
                    r = 0 < c ? -s : s,
                    c = -(n = Math.max(0, -(c * r + h))) * n + r * (r + 2 * l) + u;
                return a && a.copy(this.direction).multiplyScalar(n).add(this.origin),
                o && o.copy(e).multiplyScalar(r).add(t),
                c
            }
        }(),
        intersectSphere: function() {
            var t = new r;
            return function(e, i) {
                t.subVectors(e.center, this.origin);
                var n = t.dot(this.direction)
                  , r = t.dot(t) - n * n;
                return r > (e = e.radius * e.radius) ? null : (r = n - (e = Math.sqrt(e - r)),
                n += e,
                0 > r && 0 > n ? null : 0 > r ? this.at(n, i) : this.at(r, i))
            }
        }(),
        intersectsSphere: function(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        },
        distanceToPlane: function(t) {
            var e = t.normal.dot(this.direction);
            return 0 === e ? 0 === t.distanceToPoint(this.origin) ? 0 : null : 0 <= (t = -(this.origin.dot(t.normal) + t.constant) / e) ? t : null
        },
        intersectPlane: function(t, e) {
            return null === (t = this.distanceToPlane(t)) ? null : this.at(t, e)
        },
        intersectsPlane: function(t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || 0 > t.normal.dot(this.direction) * e
        },
        intersectBox: function(t, e) {
            var i = 1 / this.direction.x
              , n = 1 / this.direction.y
              , r = 1 / this.direction.z
              , a = this.origin;
            if (0 <= i) {
                var o = (t.min.x - a.x) * i;
                i *= t.max.x - a.x
            } else
                o = (t.max.x - a.x) * i,
                i *= t.min.x - a.x;
            if (0 <= n) {
                var s = (t.min.y - a.y) * n;
                n *= t.max.y - a.y
            } else
                s = (t.max.y - a.y) * n,
                n *= t.min.y - a.y;
            return o > n || s > i ? null : ((s > o || o != o) && (o = s),
            (n < i || i != i) && (i = n),
            0 <= r ? (s = (t.min.z - a.z) * r,
            t = (t.max.z - a.z) * r) : (s = (t.max.z - a.z) * r,
            t = (t.min.z - a.z) * r),
            o > t || s > i ? null : ((s > o || o != o) && (o = s),
            (t < i || i != i) && (i = t),
            0 > i ? null : this.at(0 <= o ? o : i, e)))
        },
        intersectsBox: function() {
            var t = new r;
            return function(e) {
                return null !== this.intersectBox(e, t)
            }
        }(),
        intersectTriangle: function() {
            var t = new r
              , e = new r
              , i = new r
              , n = new r;
            return function(r, a, o, s, c) {
                if (e.subVectors(a, r),
                i.subVectors(o, r),
                n.crossVectors(e, i),
                0 < (a = this.direction.dot(n))) {
                    if (s)
                        return null;
                    s = 1
                } else {
                    if (!(0 > a))
                        return null;
                    s = -1,
                    a = -a
                }
                return t.subVectors(this.origin, r),
                0 > (r = s * this.direction.dot(i.crossVectors(t, i))) ? null : 0 > (o = s * this.direction.dot(e.cross(t))) || r + o > a ? null : 0 > (r = -s * t.dot(n)) ? null : this.at(r / a, c)
            }
        }(),
        applyMatrix4: function(t) {
            return this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
        },
        equals: function(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    }),
    Object.assign(q, {
        getNormal: function() {
            var t = new r;
            return function(e, i, n, a) {
                return void 0 === a && (a = new r),
                a.subVectors(n, i),
                t.subVectors(e, i),
                a.cross(t),
                0 < (e = a.lengthSq()) ? a.multiplyScalar(1 / Math.sqrt(e)) : a.set(0, 0, 0)
            }
        }(),
        getBarycoord: function() {
            var t = new r
              , e = new r
              , i = new r;
            return function(n, a, o, s, c) {
                t.subVectors(s, a),
                e.subVectors(o, a),
                i.subVectors(n, a),
                n = t.dot(t),
                a = t.dot(e),
                o = t.dot(i);
                var h = e.dot(e);
                s = e.dot(i);
                var l = n * h - a * a;
                return void 0 === c && (c = new r),
                0 === l ? c.set(-2, -1, -1) : (h = (h * o - a * s) * (l = 1 / l),
                n = (n * s - a * o) * l,
                c.set(1 - h - n, n, h))
            }
        }(),
        containsPoint: function() {
            var t = new r;
            return function(e, i, n, r) {
                return q.getBarycoord(e, i, n, r, t),
                0 <= t.x && 0 <= t.y && 1 >= t.x + t.y
            }
        }(),
        getUV: function() {
            var t = new r;
            return function(e, i, n, r, a, o, s, c) {
                return this.getBarycoord(e, i, n, r, t),
                c.set(0, 0),
                c.addScaledVector(a, t.x),
                c.addScaledVector(o, t.y),
                c.addScaledVector(s, t.z),
                c
            }
        }()
    }),
    Object.assign(q.prototype, {
        set: function(t, e, i) {
            return this.a.copy(t),
            this.b.copy(e),
            this.c.copy(i),
            this
        },
        setFromPointsAndIndices: function(t, e, i, n) {
            return this.a.copy(t[e]),
            this.b.copy(t[i]),
            this.c.copy(t[n]),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.a.copy(t.a),
            this.b.copy(t.b),
            this.c.copy(t.c),
            this
        },
        getArea: function() {
            var t = new r
              , e = new r;
            return function() {
                return t.subVectors(this.c, this.b),
                e.subVectors(this.a, this.b),
                .5 * t.cross(e).length()
            }
        }(),
        getMidpoint: function(t) {
            return void 0 === t && (t = new r),
            t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(t) {
            return q.getNormal(this.a, this.b, this.c, t)
        },
        getPlane: function(t) {
            return void 0 === t && (t = new r),
            t.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(t, e) {
            return q.getBarycoord(t, this.a, this.b, this.c, e)
        },
        containsPoint: function(t) {
            return q.containsPoint(t, this.a, this.b, this.c)
        },
        getUV: function(t, e, i, n, r) {
            return q.getUV(t, this.a, this.b, this.c, e, i, n, r)
        },
        intersectsBox: function(t) {
            return t.intersectsTriangle(this)
        },
        closestPointToPoint: function() {
            var t = new r
              , e = new r
              , i = new r
              , n = new r
              , a = new r
              , o = new r;
            return function(s, c) {
                void 0 === c && (c = new r);
                var h = this.a
                  , l = this.b
                  , u = this.c;
                t.subVectors(l, h),
                e.subVectors(u, h),
                n.subVectors(s, h);
                var p = t.dot(n)
                  , d = e.dot(n);
                if (0 >= p && 0 >= d)
                    return c.copy(h);
                a.subVectors(s, l);
                var f = t.dot(a)
                  , m = e.dot(a);
                if (0 <= f && m <= f)
                    return c.copy(l);
                var g = p * m - f * d;
                if (0 >= g && 0 <= p && 0 >= f)
                    return l = p / (p - f),
                    c.copy(h).addScaledVector(t, l);
                o.subVectors(s, u),
                s = t.dot(o);
                var v = e.dot(o);
                return 0 <= v && s <= v ? c.copy(u) : 0 >= (p = s * d - p * v) && 0 <= d && 0 >= v ? (g = d / (d - v),
                c.copy(h).addScaledVector(e, g)) : 0 >= (d = f * v - s * m) && 0 <= m - f && 0 <= s - v ? (i.subVectors(u, l),
                g = (m - f) / (m - f + (s - v)),
                c.copy(l).addScaledVector(i, g)) : (l = p * (u = 1 / (d + p + g)),
                g *= u,
                c.copy(h).addScaledVector(t, l).addScaledVector(e, g))
            }
        }(),
        equals: function(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }),
    Y.prototype = Object.create(H.prototype),
    Y.prototype.constructor = Y,
    Y.prototype.isMeshBasicMaterial = !0,
    Y.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this
    }
    ,
    J.prototype = Object.assign(Object.create(T.prototype), {
        constructor: J,
        isMesh: !0,
        setDrawMode: function(t) {
            this.drawMode = t
        },
        copy: function(t) {
            return T.prototype.copy.call(this, t),
            this.drawMode = t.drawMode,
            void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
            this
        },
        updateMorphTargets: function() {
            var t = this.geometry;
            if (t.isBufferGeometry) {
                t = t.morphAttributes;
                var e = Object.keys(t);
                if (0 < e.length) {
                    var i = t[e[0]];
                    if (void 0 !== i)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        t = 0,
                        e = i.length; t < e; t++) {
                            var n = i[t].name || String(t);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = t
                        }
                }
            } else
                void 0 !== (t = t.morphTargets) && t.length
        },
        raycast: function() {
            function t(t, e, i, n, r, a, o, s) {
                return null === (1 === e.side ? n.intersectTriangle(o, a, r, !0, s) : n.intersectTriangle(r, a, o, 2 !== e.side, s)) ? null : (_.copy(s),
                _.applyMatrix4(t.matrixWorld),
                (e = i.ray.origin.distanceTo(_)) < i.near || e > i.far ? null : {
                    distance: e,
                    point: _.clone(),
                    object: t
                })
            }
            function e(e, n, r, a, o, d, g, _, S, T) {
                if (s.fromBufferAttribute(o, _),
                c.fromBufferAttribute(o, S),
                h.fromBufferAttribute(o, T),
                o = e.morphTargetInfluences,
                n.morphTargets && d && o) {
                    f.set(0, 0, 0),
                    m.set(0, 0, 0),
                    v.set(0, 0, 0);
                    for (var E = 0, A = d.length; E < A; E++) {
                        var L = o[E]
                          , P = d[E];
                        0 !== L && (l.fromBufferAttribute(P, _),
                        u.fromBufferAttribute(P, S),
                        p.fromBufferAttribute(P, T),
                        f.addScaledVector(l.sub(s), L),
                        m.addScaledVector(u.sub(c), L),
                        v.addScaledVector(p.sub(h), L))
                    }
                    s.add(f),
                    c.add(m),
                    h.add(v)
                }
                return (e = t(e, n, r, a, s, c, h, w)) && (g && (y.fromBufferAttribute(g, _),
                x.fromBufferAttribute(g, S),
                b.fromBufferAttribute(g, T),
                e.uv = q.getUV(w, s, c, h, y, x, b, new i)),
                g = new M(_,S,T),
                q.getNormal(s, c, h, g.normal),
                e.face = g),
                e
            }
            var n = new g
              , a = new X
              , o = new d
              , s = new r
              , c = new r
              , h = new r
              , l = new r
              , u = new r
              , p = new r
              , f = new r
              , m = new r
              , v = new r
              , y = new i
              , x = new i
              , b = new i
              , w = new r
              , _ = new r;
            return function(r, s) {
                var c = this.geometry
                  , h = this.material
                  , l = this.matrixWorld;
                if (void 0 !== h && (null === c.boundingSphere && c.computeBoundingSphere(),
                o.copy(c.boundingSphere),
                o.applyMatrix4(l),
                !1 !== r.ray.intersectsSphere(o) && (n.getInverse(l),
                a.copy(r.ray).applyMatrix4(n),
                null === c.boundingBox || !1 !== a.intersectsBox(c.boundingBox))))
                    if (c.isBufferGeometry) {
                        var u = c.index;
                        l = c.attributes.position;
                        var p, d, f = c.morphAttributes.position, m = c.attributes.uv, g = c.groups, v = c.drawRange;
                        if (null !== u)
                            if (Array.isArray(h)) {
                                var M = 0;
                                for (p = g.length; M < p; M++) {
                                    var _ = g[M]
                                      , S = h[_.materialIndex]
                                      , T = Math.max(_.start, v.start);
                                    for (d = c = Math.min(_.start + _.count, v.start + v.count); T < d; T += 3) {
                                        c = u.getX(T);
                                        var E = u.getX(T + 1)
                                          , A = u.getX(T + 2);
                                        (c = e(this, S, r, a, l, f, m, c, E, A)) && (c.faceIndex = Math.floor(T / 3),
                                        c.face.materialIndex = _.materialIndex,
                                        s.push(c))
                                    }
                                }
                            } else
                                for (M = T = Math.max(0, v.start),
                                p = c = Math.min(u.count, v.start + v.count); M < p; M += 3)
                                    c = u.getX(M),
                                    E = u.getX(M + 1),
                                    A = u.getX(M + 2),
                                    (c = e(this, h, r, a, l, f, m, c, E, A)) && (c.faceIndex = Math.floor(M / 3),
                                    s.push(c));
                        else if (void 0 !== l)
                            if (Array.isArray(h))
                                for (M = 0,
                                p = g.length; M < p; M++)
                                    for (S = h[(_ = g[M]).materialIndex],
                                    T = Math.max(_.start, v.start),
                                    d = c = Math.min(_.start + _.count, v.start + v.count); T < d; T += 3)
                                        (c = e(this, S, r, a, l, f, m, c = T, E = T + 1, A = T + 2)) && (c.faceIndex = Math.floor(T / 3),
                                        c.face.materialIndex = _.materialIndex,
                                        s.push(c));
                            else
                                for (M = T = Math.max(0, v.start),
                                p = c = Math.min(l.count, v.start + v.count); M < p; M += 3)
                                    (c = e(this, h, r, a, l, f, m, c = M, E = M + 1, A = M + 2)) && (c.faceIndex = Math.floor(M / 3),
                                    s.push(c))
                    } else if (c.isGeometry)
                        for (l = Array.isArray(h),
                        f = c.vertices,
                        m = c.faces,
                        0 < (c = c.faceVertexUvs[0]).length && (u = c),
                        p = 0,
                        _ = m.length; p < _; p++)
                            S = m[p],
                            void 0 !== (c = l ? h[S.materialIndex] : h) && (g = f[S.a],
                            v = f[S.b],
                            M = f[S.c],
                            c = t(this, c, r, a, g, v, M, w)) && (u && u[p] && (T = u[p],
                            y.copy(T[0]),
                            x.copy(T[1]),
                            b.copy(T[2]),
                            c.uv = q.getUV(w, g, v, M, y, x, b, new i)),
                            c.face = S,
                            c.faceIndex = p,
                            s.push(c))
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    tt.prototype = Object.create(o.prototype),
    tt.prototype.constructor = tt,
    tt.prototype.isCubeTexture = !0,
    Object.defineProperty(tt.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(t) {
            this.image = t
        }
    }),
    et.prototype = Object.create(o.prototype),
    et.prototype.constructor = et,
    et.prototype.isDataTexture2DArray = !0,
    it.prototype = Object.create(o.prototype),
    it.prototype.constructor = it,
    it.prototype.isDataTexture3D = !0;
    var ea = new o
      , ia = new et
      , na = new it
      , ra = new tt
      , aa = []
      , oa = []
      , sa = new Float32Array(16)
      , ca = new Float32Array(9)
      , ha = new Float32Array(4);
    Ot.prototype.updateCache = function(t) {
        var e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
        at(e, t)
    }
    ,
    Dt.prototype.setValue = function(t, e, i) {
        for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
            var o = n[r];
            o.setValue(t, e[o.id], i)
        }
    }
    ;
    var la = /([\w\d_]+)(\])?(\[|\.)?/g;
    zt.prototype.setValue = function(t, e, i, n) {
        void 0 !== (e = this.map[e]) && e.setValue(t, i, n)
    }
    ,
    zt.prototype.setOptional = function(t, e, i) {
        void 0 !== (e = e[i]) && this.setValue(t, i, e)
    }
    ,
    zt.upload = function(t, e, i, n) {
        for (var r = 0, a = e.length; r !== a; ++r) {
            var o = e[r]
              , s = i[o.id];
            !1 !== s.needsUpdate && o.setValue(t, s.value, n)
        }
    }
    ,
    zt.seqWithValue = function(t, e) {
        for (var i = [], n = 0, r = t.length; n !== r; ++n) {
            var a = t[n];
            a.id in e && i.push(a)
        }
        return i
    }
    ;
    var ua = 0
      , pa = 0;
    Zt.prototype = Object.create(H.prototype),
    Zt.prototype.constructor = Zt,
    Zt.prototype.isMeshDepthMaterial = !0,
    Zt.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.depthPacking = t.depthPacking,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this
    }
    ,
    Qt.prototype = Object.create(H.prototype),
    Qt.prototype.constructor = Qt,
    Qt.prototype.isMeshDistanceMaterial = !0,
    Qt.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.referencePosition.copy(t.referencePosition),
        this.nearDistance = t.nearDistance,
        this.farDistance = t.farDistance,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this
    }
    ,
    te.prototype = Object.assign(Object.create(T.prototype), {
        constructor: te,
        isGroup: !0
    }),
    ee.prototype = Object.assign(Object.create(T.prototype), {
        constructor: ee,
        isCamera: !0,
        copy: function(t, e) {
            return T.prototype.copy.call(this, t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
        },
        getWorldDirection: function(t) {
            void 0 === t && (t = new r),
            this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        },
        updateMatrixWorld: function(t) {
            T.prototype.updateMatrixWorld.call(this, t),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    ie.prototype = Object.assign(Object.create(ee.prototype), {
        constructor: ie,
        isPerspectiveCamera: !0,
        copy: function(t, e) {
            return ee.prototype.copy.call(this, t, e),
            this.fov = t.fov,
            this.zoom = t.zoom,
            this.near = t.near,
            this.far = t.far,
            this.focus = t.focus,
            this.aspect = t.aspect,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this.filmGauge = t.filmGauge,
            this.filmOffset = t.filmOffset,
            this
        },
        setFocalLength: function(t) {
            t = .5 * this.getFilmHeight() / t,
            this.fov = 2 * Vr.RAD2DEG * Math.atan(t),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var t = Math.tan(.5 * Vr.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function() {
            return 2 * Vr.RAD2DEG * Math.atan(Math.tan(.5 * Vr.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(t, e, i, n, r, a) {
            this.aspect = t / e,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = i,
            this.view.offsetY = n,
            this.view.width = r,
            this.view.height = a,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = this.near
              , e = t * Math.tan(.5 * Vr.DEG2RAD * this.fov) / this.zoom
              , i = 2 * e
              , n = this.aspect * i
              , r = -.5 * n
              , a = this.view;
            if (null !== this.view && this.view.enabled) {
                var o = a.fullWidth
                  , s = a.fullHeight;
                r += a.offsetX * n / o,
                e -= a.offsetY * i / s,
                n *= a.width / o,
                i *= a.height / s
            }
            0 !== (a = this.filmOffset) && (r += t * a / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(t) {
            return (t = T.prototype.toJSON.call(this, t)).object.fov = this.fov,
            t.object.zoom = this.zoom,
            t.object.near = this.near,
            t.object.far = this.far,
            t.object.focus = this.focus,
            t.object.aspect = this.aspect,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t.object.filmGauge = this.filmGauge,
            t.object.filmOffset = this.filmOffset,
            t
        }
    }),
    ne.prototype = Object.assign(Object.create(ie.prototype), {
        constructor: ne,
        isArrayCamera: !0
    });
    var da, fa = new r, ma = new r;
    Object.assign(ce.prototype, {
        isFogExp2: !0,
        clone: function() {
            return new ce(this.color,this.density)
        },
        toJSON: function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }),
    Object.assign(he.prototype, {
        isFog: !0,
        clone: function() {
            return new he(this.color,this.near,this.far)
        },
        toJSON: function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }),
    le.prototype = Object.assign(Object.create(T.prototype), {
        constructor: le,
        isScene: !0,
        copy: function(t, e) {
            return T.prototype.copy.call(this, t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
            this.autoUpdate = t.autoUpdate,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this
        },
        toJSON: function(t) {
            var e = T.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(ue.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(ue.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(t) {
            if (Array.isArray(t))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== t ? t.length / this.stride : 0,
            this.array = t,
            this
        },
        setDynamic: function(t) {
            return this.dynamic = t,
            this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array),
            this.count = t.count,
            this.stride = t.stride,
            this.dynamic = t.dynamic,
            this
        },
        copyAt: function(t, e, i) {
            t *= this.stride,
            i *= e.stride;
            for (var n = 0, r = this.stride; n < r; n++)
                this.array[t + n] = e.array[i + n];
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0),
            this.array.set(t, e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        }
    }),
    Object.defineProperties(pe.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(pe.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e,
            this
        },
        setY: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e,
            this
        },
        setZ: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e,
            this
        },
        setW: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e,
            this
        },
        getX: function(t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function(t, e, i) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = i,
            this
        },
        setXYZ: function(t, e, i, n) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = i,
            this.data.array[t + 2] = n,
            this
        },
        setXYZW: function(t, e, i, n, r) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = i,
            this.data.array[t + 2] = n,
            this.data.array[t + 3] = r,
            this
        }
    }),
    de.prototype = Object.create(H.prototype),
    de.prototype.constructor = de,
    de.prototype.isSpriteMaterial = !0,
    de.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.rotation = t.rotation,
        this.sizeAttenuation = t.sizeAttenuation,
        this
    }
    ,
    fe.prototype = Object.assign(Object.create(T.prototype), {
        constructor: fe,
        isSprite: !0,
        raycast: function() {
            function t(t, e, i, n, r, a) {
                o.subVectors(t, i).addScalar(.5).multiply(n),
                void 0 !== r ? (s.x = a * o.x - r * o.y,
                s.y = r * o.x + a * o.y) : s.copy(o),
                t.copy(e),
                t.x += s.x,
                t.y += s.y,
                t.applyMatrix4(c)
            }
            var e = new r
              , n = new r
              , a = new r
              , o = new i
              , s = new i
              , c = new g
              , h = new r
              , l = new r
              , u = new r
              , p = new i
              , d = new i
              , f = new i;
            return function(r, o) {
                n.setFromMatrixScale(this.matrixWorld),
                c.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld),
                a.setFromMatrixPosition(this.modelViewMatrix);
                var s = this.material.rotation;
                if (0 !== s)
                    var m = Math.cos(s)
                      , g = Math.sin(s);
                s = this.center,
                t(h.set(-.5, -.5, 0), a, s, n, g, m),
                t(l.set(.5, -.5, 0), a, s, n, g, m),
                t(u.set(.5, .5, 0), a, s, n, g, m),
                p.set(0, 0),
                d.set(1, 0),
                f.set(1, 1);
                var v = r.ray.intersectTriangle(h, l, u, !1, e);
                null === v && (t(l.set(-.5, .5, 0), a, s, n, g, m),
                d.set(0, 1),
                null === (v = r.ray.intersectTriangle(h, u, l, !1, e))) || (g = r.ray.origin.distanceTo(e)) < r.near || g > r.far || o.push({
                    distance: g,
                    point: e.clone(),
                    uv: q.getUV(e, h, l, u, p, d, f, new i),
                    face: null,
                    object: this
                })
            }
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(t) {
            return T.prototype.copy.call(this, t),
            void 0 !== t.center && this.center.copy(t.center),
            this
        }
    }),
    me.prototype = Object.assign(Object.create(T.prototype), {
        constructor: me,
        copy: function(t) {
            T.prototype.copy.call(this, t, !1);
            for (var e = 0, i = (t = t.levels).length; e < i; e++) {
                var n = t[e];
                this.addLevel(n.object.clone(), n.distance)
            }
            return this
        },
        addLevel: function(t, e) {
            void 0 === e && (e = 0),
            e = Math.abs(e);
            for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++)
                ;
            i.splice(n, 0, {
                distance: e,
                object: t
            }),
            this.add(t)
        },
        getObjectForDistance: function(t) {
            for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++)
                ;
            return e[i - 1].object
        },
        raycast: function() {
            var t = new r;
            return function(e, i) {
                t.setFromMatrixPosition(this.matrixWorld);
                var n = e.ray.origin.distanceTo(t);
                this.getObjectForDistance(n).raycast(e, i)
            }
        }(),
        update: function() {
            var t = new r
              , e = new r;
            return function(i) {
                var n = this.levels;
                if (1 < n.length) {
                    t.setFromMatrixPosition(i.matrixWorld),
                    e.setFromMatrixPosition(this.matrixWorld),
                    i = t.distanceTo(e),
                    n[0].object.visible = !0;
                    for (var r = 1, a = n.length; r < a && i >= n[r].distance; r++)
                        n[r - 1].object.visible = !1,
                        n[r].object.visible = !0;
                    for (; r < a; r++)
                        n[r].object.visible = !1
                }
            }
        }(),
        toJSON: function(t) {
            (t = T.prototype.toJSON.call(this, t)).object.levels = [];
            for (var e = this.levels, i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.object.levels.push({
                    object: r.object.uuid,
                    distance: r.distance
                })
            }
            return t
        }
    }),
    ge.prototype = Object.assign(Object.create(J.prototype), {
        constructor: ge,
        isSkinnedMesh: !0,
        bind: function(t, e) {
            this.skeleton = t,
            void 0 === e && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            e = this.matrixWorld),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.getInverse(e)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var t = new s, e = this.geometry.attributes.skinWeight, i = 0, n = e.count; i < n; i++) {
                t.x = e.getX(i),
                t.y = e.getY(i),
                t.z = e.getZ(i),
                t.w = e.getW(i);
                var r = 1 / t.manhattanLength();
                1 / 0 !== r ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
                e.setXYZW(i, t.x, t.y, t.z, t.w)
            }
        },
        updateMatrixWorld: function(t) {
            J.prototype.updateMatrixWorld.call(this, t),
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode && this.bindMatrixInverse.getInverse(this.bindMatrix)
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Object.assign(ve.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var i = new g;
                this.bones[t] && i.getInverse(this.bones[t].matrixWorld),
                this.boneInverses.push(i)
            }
        },
        pose: function() {
            var t, e, i = 0;
            for (e = this.bones.length; i < e; i++)
                (t = this.bones[i]) && t.matrixWorld.getInverse(this.boneInverses[i]);
            for (i = 0,
            e = this.bones.length; i < e; i++)
                (t = this.bones[i]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld),
                t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                t.matrix.decompose(t.position, t.quaternion, t.scale))
        },
        update: function() {
            var t = new g
              , e = new g;
            return function() {
                for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, a = this.boneTexture, o = 0, s = i.length; o < s; o++)
                    t.multiplyMatrices(i[o] ? i[o].matrixWorld : e, n[o]),
                    t.toArray(r, 16 * o);
                void 0 !== a && (a.needsUpdate = !0)
            }
        }(),
        clone: function() {
            return new ve(this.bones,this.boneInverses)
        },
        getBoneByName: function(t) {
            for (var e = 0, i = this.bones.length; e < i; e++) {
                var n = this.bones[e];
                if (n.name === t)
                    return n
            }
        }
    }),
    ye.prototype = Object.assign(Object.create(T.prototype), {
        constructor: ye,
        isBone: !0
    }),
    xe.prototype = Object.create(H.prototype),
    xe.prototype.constructor = xe,
    xe.prototype.isLineBasicMaterial = !0,
    xe.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.linewidth = t.linewidth,
        this.linecap = t.linecap,
        this.linejoin = t.linejoin,
        this
    }
    ,
    be.prototype = Object.assign(Object.create(T.prototype), {
        constructor: be,
        isLine: !0,
        computeLineDistances: function() {
            var t = new r
              , e = new r;
            return function() {
                var i = this.geometry;
                if (i.isBufferGeometry) {
                    if (null === i.index) {
                        for (var n = i.attributes.position, r = [0], a = 1, o = n.count; a < o; a++)
                            t.fromBufferAttribute(n, a - 1),
                            e.fromBufferAttribute(n, a),
                            r[a] = r[a - 1],
                            r[a] += t.distanceTo(e);
                        i.addAttribute("lineDistance", new z(r,1))
                    }
                } else if (i.isGeometry)
                    for (n = i.vertices,
                    (r = i.lineDistances)[0] = 0,
                    a = 1,
                    o = n.length; a < o; a++)
                        r[a] = r[a - 1],
                        r[a] += n[a - 1].distanceTo(n[a]);
                return this
            }
        }(),
        raycast: function() {
            var t = new g
              , e = new X
              , i = new d;
            return function(n, a) {
                var o = n.linePrecision
                  , s = this.geometry
                  , c = this.matrixWorld;
                if (null === s.boundingSphere && s.computeBoundingSphere(),
                i.copy(s.boundingSphere),
                i.applyMatrix4(c),
                i.radius += o,
                !1 !== n.ray.intersectsSphere(i)) {
                    t.getInverse(c),
                    e.copy(n.ray).applyMatrix4(t),
                    o /= (this.scale.x + this.scale.y + this.scale.z) / 3,
                    o *= o;
                    var h = new r
                      , l = new r;
                    c = new r;
                    var u = new r
                      , p = this && this.isLineSegments ? 2 : 1;
                    if (s.isBufferGeometry) {
                        var d = s.index
                          , f = s.attributes.position.array;
                        if (null !== d) {
                            s = 0;
                            for (var m = (d = d.array).length - 1; s < m; s += p) {
                                var g = d[s + 1];
                                h.fromArray(f, 3 * d[s]),
                                l.fromArray(f, 3 * g),
                                (g = e.distanceSqToSegment(h, l, u, c)) > o || (u.applyMatrix4(this.matrixWorld),
                                (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || a.push({
                                    distance: g,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: s,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        } else
                            for (s = 0,
                            m = f.length / 3 - 1; s < m; s += p)
                                h.fromArray(f, 3 * s),
                                l.fromArray(f, 3 * s + 3),
                                (g = e.distanceSqToSegment(h, l, u, c)) > o || (u.applyMatrix4(this.matrixWorld),
                                (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || a.push({
                                    distance: g,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: s,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                    } else if (s.isGeometry)
                        for (l = (h = s.vertices).length,
                        s = 0; s < l - 1; s += p)
                            (g = e.distanceSqToSegment(h[s], h[s + 1], u, c)) > o || (u.applyMatrix4(this.matrixWorld),
                            (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || a.push({
                                distance: g,
                                point: c.clone().applyMatrix4(this.matrixWorld),
                                index: s,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    we.prototype = Object.assign(Object.create(be.prototype), {
        constructor: we,
        isLineSegments: !0,
        computeLineDistances: function() {
            var t = new r
              , e = new r;
            return function() {
                var i = this.geometry;
                if (i.isBufferGeometry) {
                    if (null === i.index) {
                        for (var n = i.attributes.position, r = [], a = 0, o = n.count; a < o; a += 2)
                            t.fromBufferAttribute(n, a),
                            e.fromBufferAttribute(n, a + 1),
                            r[a] = 0 === a ? 0 : r[a - 1],
                            r[a + 1] = r[a] + t.distanceTo(e);
                        i.addAttribute("lineDistance", new z(r,1))
                    }
                } else if (i.isGeometry)
                    for (n = i.vertices,
                    r = i.lineDistances,
                    a = 0,
                    o = n.length; a < o; a += 2)
                        t.copy(n[a]),
                        e.copy(n[a + 1]),
                        r[a] = 0 === a ? 0 : r[a - 1],
                        r[a + 1] = r[a] + t.distanceTo(e);
                return this
            }
        }()
    }),
    Me.prototype = Object.assign(Object.create(be.prototype), {
        constructor: Me,
        isLineLoop: !0
    }),
    _e.prototype = Object.create(H.prototype),
    _e.prototype.constructor = _e,
    _e.prototype.isPointsMaterial = !0,
    _e.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.size = t.size,
        this.sizeAttenuation = t.sizeAttenuation,
        this.morphTargets = t.morphTargets,
        this
    }
    ,
    Se.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Se,
        isPoints: !0,
        raycast: function() {
            var t = new g
              , e = new X
              , i = new d;
            return function(n, a) {
                function o(t, i) {
                    var r = e.distanceSqToPoint(t);
                    r < u && (e.closestPointToPoint(t, p),
                    p.applyMatrix4(h),
                    (t = n.ray.origin.distanceTo(p)) < n.near || t > n.far || a.push({
                        distance: t,
                        distanceToRay: Math.sqrt(r),
                        point: p.clone(),
                        index: i,
                        face: null,
                        object: s
                    }))
                }
                var s = this
                  , c = this.geometry
                  , h = this.matrixWorld
                  , l = n.params.Points.threshold;
                if (null === c.boundingSphere && c.computeBoundingSphere(),
                i.copy(c.boundingSphere),
                i.applyMatrix4(h),
                i.radius += l,
                !1 !== n.ray.intersectsSphere(i)) {
                    t.getInverse(h),
                    e.copy(n.ray).applyMatrix4(t);
                    var u = (l /= (this.scale.x + this.scale.y + this.scale.z) / 3) * l;
                    l = new r;
                    var p = new r;
                    if (c.isBufferGeometry) {
                        var d = c.index;
                        if (c = c.attributes.position.array,
                        null !== d) {
                            var f = d.array;
                            d = 0;
                            for (var m = f.length; d < m; d++) {
                                var g = f[d];
                                l.fromArray(c, 3 * g),
                                o(l, g)
                            }
                        } else
                            for (d = 0,
                            f = c.length / 3; d < f; d++)
                                l.fromArray(c, 3 * d),
                                o(l, d)
                    } else
                        for (d = 0,
                        f = (l = c.vertices).length; d < f; d++)
                            o(l[d], d)
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Te.prototype = Object.assign(Object.create(o.prototype), {
        constructor: Te,
        isVideoTexture: !0,
        update: function() {
            var t = this.image;
            t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    Ee.prototype = Object.create(o.prototype),
    Ee.prototype.constructor = Ee,
    Ee.prototype.isCompressedTexture = !0,
    Ae.prototype = Object.create(o.prototype),
    Ae.prototype.constructor = Ae,
    Ae.prototype.isCanvasTexture = !0,
    Le.prototype = Object.create(o.prototype),
    Le.prototype.constructor = Le,
    Le.prototype.isDepthTexture = !0,
    Pe.prototype = Object.create(U.prototype),
    Pe.prototype.constructor = Pe,
    Ce.prototype = Object.create(E.prototype),
    Ce.prototype.constructor = Ce,
    Ie.prototype = Object.create(U.prototype),
    Ie.prototype.constructor = Ie,
    Re.prototype = Object.create(E.prototype),
    Re.prototype.constructor = Re,
    Oe.prototype = Object.create(U.prototype),
    Oe.prototype.constructor = Oe,
    De.prototype = Object.create(E.prototype),
    De.prototype.constructor = De,
    ze.prototype = Object.create(Oe.prototype),
    ze.prototype.constructor = ze,
    Be.prototype = Object.create(E.prototype),
    Be.prototype.constructor = Be,
    Ne.prototype = Object.create(Oe.prototype),
    Ne.prototype.constructor = Ne,
    ke.prototype = Object.create(E.prototype),
    ke.prototype.constructor = ke,
    Ue.prototype = Object.create(Oe.prototype),
    Ue.prototype.constructor = Ue,
    Fe.prototype = Object.create(E.prototype),
    Fe.prototype.constructor = Fe,
    Ge.prototype = Object.create(Oe.prototype),
    Ge.prototype.constructor = Ge,
    Ve.prototype = Object.create(E.prototype),
    Ve.prototype.constructor = Ve,
    je.prototype = Object.create(U.prototype),
    je.prototype.constructor = je,
    je.prototype.toJSON = function() {
        var t = U.prototype.toJSON.call(this);
        return t.path = this.parameters.path.toJSON(),
        t
    }
    ,
    He.prototype = Object.create(E.prototype),
    He.prototype.constructor = He,
    We.prototype = Object.create(U.prototype),
    We.prototype.constructor = We,
    Xe.prototype = Object.create(E.prototype),
    Xe.prototype.constructor = Xe,
    qe.prototype = Object.create(U.prototype),
    qe.prototype.constructor = qe;
    var ga = function(t, e, i) {
        i = i || 2;
        var n, r = e && e.length, a = r ? e[0] * i : t.length, o = Ye(t, 0, a, i, !0), s = [];
        if (!o)
            return s;
        if (r) {
            var c, h = i;
            r = [];
            var l = 0;
            for (c = e.length; l < c; l++) {
                var u = e[l] * h;
                (u = Ye(t, u, l < c - 1 ? e[l + 1] * h : t.length, h, !1)) === u.next && (u.steiner = !0),
                r.push($e(u))
            }
            for (r.sort(Ze),
            l = 0; l < r.length; l++)
                (h = Qe(e = r[l], h = o)) && Je(e = ai(h, e), e.next),
                o = Je(o, o.next)
        }
        if (t.length > 80 * i) {
            var p = n = t[0]
              , d = r = t[1];
            for (h = i; h < a; h += i)
                l = t[h],
                e = t[h + 1],
                l < p && (p = l),
                e < d && (d = e),
                l > n && (n = l),
                e > r && (r = e);
            n = 0 !== (n = Math.max(n - p, r - d)) ? 1 / n : 0
        }
        return function t(e, i, n, r, a, o, s) {
            if (e) {
                if (!s && o) {
                    var c = e
                      , h = c;
                    do {
                        null === h.z && (h.z = Ke(h.x, h.y, r, a, o)),
                        h.prevZ = h.prev,
                        h = h.nextZ = h.next
                    } while (h !== c);
                    h.prevZ.nextZ = null,
                    h.prevZ = null,
                    c = h;
                    var l, u, p, d, f = 1;
                    do {
                        h = c;
                        var m = c = null;
                        for (u = 0; h; ) {
                            u++;
                            var g = h;
                            for (l = p = 0; l < f && (p++,
                            g = g.nextZ); l++)
                                ;
                            for (d = f; 0 < p || 0 < d && g; )
                                0 !== p && (0 === d || !g || h.z <= g.z) ? (l = h,
                                h = h.nextZ,
                                p--) : (l = g,
                                g = g.nextZ,
                                d--),
                                m ? m.nextZ = l : c = l,
                                l.prevZ = m,
                                m = l;
                            h = g
                        }
                        m.nextZ = null,
                        f *= 2
                    } while (1 < u)
                }
                for (c = e; e.prev !== e.next; ) {
                    if (h = e.prev,
                    g = e.next,
                    o)
                        t: {
                            d = r;
                            var v = a
                              , y = o;
                            if (0 <= ei(u = (m = e).prev, p = m, f = m.next))
                                m = !1;
                            else {
                                var x = u.x > p.x ? u.x > f.x ? u.x : f.x : p.x > f.x ? p.x : f.x
                                  , b = u.y > p.y ? u.y > f.y ? u.y : f.y : p.y > f.y ? p.y : f.y;
                                for (l = Ke(u.x < p.x ? u.x < f.x ? u.x : f.x : p.x < f.x ? p.x : f.x, u.y < p.y ? u.y < f.y ? u.y : f.y : p.y < f.y ? p.y : f.y, d, v, y),
                                d = Ke(x, b, d, v, y),
                                v = m.nextZ; v && v.z <= d; ) {
                                    if (v !== m.prev && v !== m.next && ti(u.x, u.y, p.x, p.y, f.x, f.y, v.x, v.y) && 0 <= ei(v.prev, v, v.next)) {
                                        m = !1;
                                        break t
                                    }
                                    v = v.nextZ
                                }
                                for (v = m.prevZ; v && v.z >= l; ) {
                                    if (v !== m.prev && v !== m.next && ti(u.x, u.y, p.x, p.y, f.x, f.y, v.x, v.y) && 0 <= ei(v.prev, v, v.next)) {
                                        m = !1;
                                        break t
                                    }
                                    v = v.prevZ
                                }
                                m = !0
                            }
                        }
                    else
                        t: if (m = e,
                        u = m.prev,
                        p = m,
                        f = m.next,
                        0 <= ei(u, p, f))
                            m = !1;
                        else {
                            for (l = m.next.next; l !== m.prev; ) {
                                if (ti(u.x, u.y, p.x, p.y, f.x, f.y, l.x, l.y) && 0 <= ei(l.prev, l, l.next)) {
                                    m = !1;
                                    break t
                                }
                                l = l.next
                            }
                            m = !0
                        }
                    if (m)
                        i.push(h.i / n),
                        i.push(e.i / n),
                        i.push(g.i / n),
                        si(e),
                        c = e = g.next;
                    else if ((e = g) === c) {
                        if (s) {
                            if (1 === s) {
                                s = i,
                                c = n,
                                h = e;
                                do {
                                    !ii(g = h.prev, m = h.next.next) && ni(g, h, h.next, m) && ri(g, m) && ri(m, g) && (s.push(g.i / c),
                                    s.push(h.i / c),
                                    s.push(m.i / c),
                                    si(h),
                                    si(h.next),
                                    h = e = m),
                                    h = h.next
                                } while (h !== e);
                                t(e = h, i, n, r, a, o, 2)
                            } else if (2 === s)
                                t: {
                                    s = e;
                                    do {
                                        for (c = s.next.next; c !== s.prev; ) {
                                            if (h = s.i !== c.i) {
                                                if (g = c,
                                                m = (h = s).next.i !== g.i && h.prev.i !== g.i) {
                                                    e: {
                                                        m = h;
                                                        do {
                                                            if (m.i !== h.i && m.next.i !== h.i && m.i !== g.i && m.next.i !== g.i && ni(m, m.next, h, g)) {
                                                                m = !0;
                                                                break e
                                                            }
                                                            m = m.next
                                                        } while (m !== h);
                                                        m = !1
                                                    }
                                                    m = !m
                                                }
                                                if (m = m && ri(h, g) && ri(g, h)) {
                                                    m = h,
                                                    u = !1,
                                                    p = (h.x + g.x) / 2,
                                                    g = (h.y + g.y) / 2;
                                                    do {
                                                        m.y > g != m.next.y > g && m.next.y !== m.y && p < (m.next.x - m.x) * (g - m.y) / (m.next.y - m.y) + m.x && (u = !u),
                                                        m = m.next
                                                    } while (m !== h);
                                                    m = u
                                                }
                                                h = m
                                            }
                                            if (h) {
                                                e = ai(s, c),
                                                s = Je(s, s.next),
                                                e = Je(e, e.next),
                                                t(s, i, n, r, a, o),
                                                t(e, i, n, r, a, o);
                                                break t
                                            }
                                            c = c.next
                                        }
                                        s = s.next
                                    } while (s !== e)
                                }
                        } else
                            t(Je(e), i, n, r, a, o, 1);
                        break
                    }
                }
            }
        }(o, s, i, p, d, n),
        s
    }
      , va = {
        area: function(t) {
            for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++)
                i += t[n].x * t[r].y - t[r].x * t[n].y;
            return .5 * i
        },
        isClockWise: function(t) {
            return 0 > va.area(t)
        },
        triangulateShape: function(t, e) {
            var i = []
              , n = []
              , r = [];
            hi(t),
            li(i, t);
            var a = t.length;
            for (e.forEach(hi),
            t = 0; t < e.length; t++)
                n.push(a),
                a += e[t].length,
                li(i, e[t]);
            for (e = ga(i, n),
            t = 0; t < e.length; t += 3)
                r.push(e.slice(t, t + 3));
            return r
        }
    };
    ui.prototype = Object.create(E.prototype),
    ui.prototype.constructor = ui,
    ui.prototype.toJSON = function() {
        var t = E.prototype.toJSON.call(this);
        return di(this.parameters.shapes, this.parameters.options, t)
    }
    ,
    pi.prototype = Object.create(U.prototype),
    pi.prototype.constructor = pi,
    pi.prototype.toJSON = function() {
        var t = U.prototype.toJSON.call(this);
        return di(this.parameters.shapes, this.parameters.options, t)
    }
    ;
    var ya = {
        generateTopUV: function(t, e, n, r, a) {
            t = e[3 * r],
            r = e[3 * r + 1];
            var o = e[3 * a];
            return a = e[3 * a + 1],
            [new i(e[3 * n],e[3 * n + 1]), new i(t,r), new i(o,a)]
        },
        generateSideWallUV: function(t, e, n, r, a, o) {
            t = e[3 * n];
            var s = e[3 * n + 1];
            n = e[3 * n + 2];
            var c = e[3 * r]
              , h = e[3 * r + 1];
            r = e[3 * r + 2];
            var l = e[3 * a]
              , u = e[3 * a + 1];
            a = e[3 * a + 2];
            var p = e[3 * o]
              , d = e[3 * o + 1];
            return e = e[3 * o + 2],
            .01 > Math.abs(s - h) ? [new i(t,1 - n), new i(c,1 - r), new i(l,1 - a), new i(p,1 - e)] : [new i(s,1 - n), new i(h,1 - r), new i(u,1 - a), new i(d,1 - e)]
        }
    };
    fi.prototype = Object.create(E.prototype),
    fi.prototype.constructor = fi,
    mi.prototype = Object.create(pi.prototype),
    mi.prototype.constructor = mi,
    gi.prototype = Object.create(E.prototype),
    gi.prototype.constructor = gi,
    vi.prototype = Object.create(U.prototype),
    vi.prototype.constructor = vi,
    yi.prototype = Object.create(E.prototype),
    yi.prototype.constructor = yi,
    xi.prototype = Object.create(U.prototype),
    xi.prototype.constructor = xi,
    bi.prototype = Object.create(E.prototype),
    bi.prototype.constructor = bi,
    wi.prototype = Object.create(U.prototype),
    wi.prototype.constructor = wi,
    Mi.prototype = Object.create(E.prototype),
    Mi.prototype.constructor = Mi,
    Mi.prototype.toJSON = function() {
        var t = E.prototype.toJSON.call(this);
        return Si(this.parameters.shapes, t)
    }
    ,
    _i.prototype = Object.create(U.prototype),
    _i.prototype.constructor = _i,
    _i.prototype.toJSON = function() {
        var t = U.prototype.toJSON.call(this);
        return Si(this.parameters.shapes, t)
    }
    ,
    Ti.prototype = Object.create(U.prototype),
    Ti.prototype.constructor = Ti,
    Ei.prototype = Object.create(E.prototype),
    Ei.prototype.constructor = Ei,
    Ai.prototype = Object.create(U.prototype),
    Ai.prototype.constructor = Ai,
    Li.prototype = Object.create(Ei.prototype),
    Li.prototype.constructor = Li,
    Pi.prototype = Object.create(Ai.prototype),
    Pi.prototype.constructor = Pi,
    Ci.prototype = Object.create(E.prototype),
    Ci.prototype.constructor = Ci,
    Ii.prototype = Object.create(U.prototype),
    Ii.prototype.constructor = Ii;
    var xa = Object.freeze({
        WireframeGeometry: Pe,
        ParametricGeometry: Ce,
        ParametricBufferGeometry: Ie,
        TetrahedronGeometry: De,
        TetrahedronBufferGeometry: ze,
        OctahedronGeometry: Be,
        OctahedronBufferGeometry: Ne,
        IcosahedronGeometry: ke,
        IcosahedronBufferGeometry: Ue,
        DodecahedronGeometry: Fe,
        DodecahedronBufferGeometry: Ge,
        PolyhedronGeometry: Re,
        PolyhedronBufferGeometry: Oe,
        TubeGeometry: Ve,
        TubeBufferGeometry: je,
        TorusKnotGeometry: He,
        TorusKnotBufferGeometry: We,
        TorusGeometry: Xe,
        TorusBufferGeometry: qe,
        TextGeometry: fi,
        TextBufferGeometry: mi,
        SphereGeometry: gi,
        SphereBufferGeometry: vi,
        RingGeometry: yi,
        RingBufferGeometry: xi,
        PlaneGeometry: V,
        PlaneBufferGeometry: j,
        LatheGeometry: bi,
        LatheBufferGeometry: wi,
        ShapeGeometry: Mi,
        ShapeBufferGeometry: _i,
        ExtrudeGeometry: ui,
        ExtrudeBufferGeometry: pi,
        EdgesGeometry: Ti,
        ConeGeometry: Li,
        ConeBufferGeometry: Pi,
        CylinderGeometry: Ei,
        CylinderBufferGeometry: Ai,
        CircleGeometry: Ci,
        CircleBufferGeometry: Ii,
        BoxGeometry: F,
        BoxBufferGeometry: G
    });
    Ri.prototype = Object.create(H.prototype),
    Ri.prototype.constructor = Ri,
    Ri.prototype.isShadowMaterial = !0,
    Ri.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this
    }
    ,
    Oi.prototype = Object.create(W.prototype),
    Oi.prototype.constructor = Oi,
    Oi.prototype.isRawShaderMaterial = !0,
    Di.prototype = Object.create(H.prototype),
    Di.prototype.constructor = Di,
    Di.prototype.isMeshStandardMaterial = !0,
    Di.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(t.color),
        this.roughness = t.roughness,
        this.metalness = t.metalness,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.roughnessMap = t.roughnessMap,
        this.metalnessMap = t.metalnessMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.envMapIntensity = t.envMapIntensity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    zi.prototype = Object.create(Di.prototype),
    zi.prototype.constructor = zi,
    zi.prototype.isMeshPhysicalMaterial = !0,
    zi.prototype.copy = function(t) {
        return Di.prototype.copy.call(this, t),
        this.defines = {
            PHYSICAL: ""
        },
        this.reflectivity = t.reflectivity,
        this.clearCoat = t.clearCoat,
        this.clearCoatRoughness = t.clearCoatRoughness,
        this
    }
    ,
    Bi.prototype = Object.create(H.prototype),
    Bi.prototype.constructor = Bi,
    Bi.prototype.isMeshPhongMaterial = !0,
    Bi.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        this.shininess = t.shininess,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Ni.prototype = Object.create(Bi.prototype),
    Ni.prototype.constructor = Ni,
    Ni.prototype.isMeshToonMaterial = !0,
    Ni.prototype.copy = function(t) {
        return Bi.prototype.copy.call(this, t),
        this.gradientMap = t.gradientMap,
        this
    }
    ,
    ki.prototype = Object.create(H.prototype),
    ki.prototype.constructor = ki,
    ki.prototype.isMeshNormalMaterial = !0,
    ki.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Ui.prototype = Object.create(H.prototype),
    Ui.prototype.constructor = Ui,
    Ui.prototype.isMeshLambertMaterial = !0,
    Ui.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Fi.prototype = Object.create(H.prototype),
    Fi.prototype.constructor = Fi,
    Fi.prototype.isMeshMatcapMaterial = !0,
    Fi.prototype.copy = function(t) {
        return H.prototype.copy.call(this, t),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(t.color),
        this.matcap = t.matcap,
        this.map = t.map,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.alphaMap = t.alphaMap,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Gi.prototype = Object.create(xe.prototype),
    Gi.prototype.constructor = Gi,
    Gi.prototype.isLineDashedMaterial = !0,
    Gi.prototype.copy = function(t) {
        return xe.prototype.copy.call(this, t),
        this.scale = t.scale,
        this.dashSize = t.dashSize,
        this.gapSize = t.gapSize,
        this
    }
    ;
    var ba = Object.freeze({
        ShadowMaterial: Ri,
        SpriteMaterial: de,
        RawShaderMaterial: Oi,
        ShaderMaterial: W,
        PointsMaterial: _e,
        MeshPhysicalMaterial: zi,
        MeshStandardMaterial: Di,
        MeshPhongMaterial: Bi,
        MeshToonMaterial: Ni,
        MeshNormalMaterial: ki,
        MeshLambertMaterial: Ui,
        MeshDepthMaterial: Zt,
        MeshDistanceMaterial: Qt,
        MeshBasicMaterial: Y,
        MeshMatcapMaterial: Fi,
        LineDashedMaterial: Gi,
        LineBasicMaterial: xe,
        Material: H
    })
      , wa = {
        arraySlice: function(t, e, i) {
            return wa.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
        },
        convertArray: function(t, e, i) {
            return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(t) {
            for (var e = t.length, i = Array(e), n = 0; n !== e; ++n)
                i[n] = n;
            return i.sort(function(e, i) {
                return t[e] - t[i]
            }),
            i
        },
        sortedArray: function(t, e, i) {
            for (var n = t.length, r = new t.constructor(n), a = 0, o = 0; o !== n; ++a)
                for (var s = i[a] * e, c = 0; c !== e; ++c)
                    r[o++] = t[s + c];
            return r
        },
        flattenJSON: function(t, e, i, n) {
            for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n]; )
                a = t[r++];
            if (void 0 !== a) {
                var o = a[n];
                if (void 0 !== o)
                    if (Array.isArray(o))
                        do {
                            void 0 !== (o = a[n]) && (e.push(a.time),
                            i.push.apply(i, o)),
                            a = t[r++]
                        } while (void 0 !== a);
                    else if (void 0 !== o.toArray)
                        do {
                            void 0 !== (o = a[n]) && (e.push(a.time),
                            o.toArray(i, i.length)),
                            a = t[r++]
                        } while (void 0 !== a);
                    else
                        do {
                            void 0 !== (o = a[n]) && (e.push(a.time),
                            i.push(o)),
                            a = t[r++]
                        } while (void 0 !== a)
            }
        }
    };
    Object.assign(Vi.prototype, {
        evaluate: function(t) {
            var e = this.parameterPositions
              , i = this._cachedIndex
              , n = e[i]
              , r = e[i - 1];
            t: {
                e: {
                    i: {
                        n: if (!(t < n)) {
                            for (var a = i + 2; ; ) {
                                if (void 0 === n) {
                                    if (t < r)
                                        break n;
                                    return this._cachedIndex = i = e.length,
                                    this.afterEnd_(i - 1, t, r)
                                }
                                if (i === a)
                                    break;
                                if (r = n,
                                t < (n = e[++i]))
                                    break e
                            }
                            n = e.length;
                            break i
                        }
                        if (t >= r)
                            break t;
                        for (t < (a = e[1]) && (i = 2,
                        r = a),
                        a = i - 2; ; ) {
                            if (void 0 === r)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, t, n);
                            if (i === a)
                                break;
                            if (n = r,
                            t >= (r = e[--i - 1]))
                                break e
                        }
                        n = i,
                        i = 0
                    }
                    for (; i < n; )
                        t < e[r = i + n >>> 1] ? n = r : i = r + 1;
                    if (n = e[i],
                    void 0 === (r = e[i - 1]))
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, t, n);
                    if (void 0 === n)
                        return this._cachedIndex = i = e.length,
                        this.afterEnd_(i - 1, r, t)
                }
                this._cachedIndex = i,
                this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, t, n)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(t) {
            var e = this.resultBuffer
              , i = this.sampleValues
              , n = this.valueSize;
            t *= n;
            for (var r = 0; r !== n; ++r)
                e[r] = i[t + r];
            return e
        },
        interpolate_: function() {
            throw Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    Object.assign(Vi.prototype, {
        beforeStart_: Vi.prototype.copySampleValue_,
        afterEnd_: Vi.prototype.copySampleValue_
    }),
    ji.prototype = Object.assign(Object.create(Vi.prototype), {
        constructor: ji,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(t, e, i) {
            var n = this.parameterPositions
              , r = t - 2
              , a = t + 1
              , o = n[r]
              , s = n[a];
            if (void 0 === o)
                switch (this.getSettings_().endingStart) {
                case 2401:
                    r = t,
                    o = 2 * e - i;
                    break;
                case 2402:
                    o = e + n[r = n.length - 2] - n[r + 1];
                    break;
                default:
                    r = t,
                    o = i
                }
            if (void 0 === s)
                switch (this.getSettings_().endingEnd) {
                case 2401:
                    a = t,
                    s = 2 * i - e;
                    break;
                case 2402:
                    a = 1,
                    s = i + n[1] - n[0];
                    break;
                default:
                    a = t - 1,
                    s = e
                }
            t = .5 * (i - e),
            n = this.valueSize,
            this._weightPrev = t / (e - o),
            this._weightNext = t / (s - i),
            this._offsetPrev = r * n,
            this._offsetNext = a * n
        },
        interpolate_: function(t, e, i, n) {
            var r = this.resultBuffer
              , a = this.sampleValues
              , o = this.valueSize
              , s = (t *= o) - o
              , c = this._offsetPrev
              , h = this._offsetNext
              , l = this._weightPrev
              , u = this._weightNext
              , p = (i - e) / (n - e);
            for (e = -l * (n = (i = p * p) * p) + 2 * l * i - l * p,
            l = (1 + l) * n + (-1.5 - 2 * l) * i + (-.5 + l) * p + 1,
            p = (-1 - u) * n + (1.5 + u) * i + .5 * p,
            u = u * n - u * i,
            i = 0; i !== o; ++i)
                r[i] = e * a[c + i] + l * a[s + i] + p * a[t + i] + u * a[h + i];
            return r
        }
    }),
    Hi.prototype = Object.assign(Object.create(Vi.prototype), {
        constructor: Hi,
        interpolate_: function(t, e, i, n) {
            var r = this.resultBuffer
              , a = this.sampleValues
              , o = this.valueSize
              , s = (t *= o) - o;
            for (i = 1 - (e = (i - e) / (n - e)),
            n = 0; n !== o; ++n)
                r[n] = a[s + n] * i + a[t + n] * e;
            return r
        }
    }),
    Wi.prototype = Object.assign(Object.create(Vi.prototype), {
        constructor: Wi,
        interpolate_: function(t) {
            return this.copySampleValue_(t - 1)
        }
    }),
    Object.assign(Xi, {
        toJSON: function(t) {
            var e = t.constructor;
            if (void 0 !== e.toJSON)
                e = e.toJSON(t);
            else {
                e = {
                    name: t.name,
                    times: wa.convertArray(t.times, Array),
                    values: wa.convertArray(t.values, Array)
                };
                var i = t.getInterpolation();
                i !== t.DefaultInterpolation && (e.interpolation = i)
            }
            return e.type = t.ValueTypeName,
            e
        }
    }),
    Object.assign(Xi.prototype, {
        constructor: Xi,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(t) {
            return new Wi(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodLinear: function(t) {
            return new Hi(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodSmooth: function(t) {
            return new ji(this.times,this.values,this.getValueSize(),t)
        },
        setInterpolation: function(t) {
            switch (t) {
            case 2300:
                var e = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name,
                void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation)
                        throw Error(e);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return this
            }
            return this.createInterpolant = e,
            this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(t) {
            if (0 !== t)
                for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
                    e[i] += t;
            return this
        },
        scale: function(t) {
            if (1 !== t)
                for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
                    e[i] *= t;
            return this
        },
        trim: function(t, e) {
            for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < t; )
                ++r;
            for (; -1 !== a && i[a] > e; )
                --a;
            return ++a,
            0 === r && a === n || (r >= a && (r = (a = Math.max(a, 1)) - 1),
            t = this.getValueSize(),
            this.times = wa.arraySlice(i, r, a),
            this.values = wa.arraySlice(this.values, r * t, a * t)),
            this
        },
        validate: function() {
            var t = !0
              , e = this.getValueSize();
            0 != e - Math.floor(e) && (t = !1);
            var i = this.times;
            e = this.values;
            var n = i.length;
            0 === n && (t = !1);
            for (var r = null, a = 0; a !== n; a++) {
                var o = i[a];
                if ("number" == typeof o && isNaN(o)) {
                    t = !1;
                    break
                }
                if (null !== r && r > o) {
                    t = !1;
                    break
                }
                r = o
            }
            if (void 0 !== e && wa.isTypedArray(e))
                for (a = 0,
                i = e.length; a !== i; ++a)
                    if (n = e[a],
                    isNaN(n)) {
                        t = !1;
                        break
                    }
            return t
        },
        optimize: function() {
            for (var t = this.times, e = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, a = t.length - 1, o = 1; o < a; ++o) {
                var s = !1
                  , c = t[o];
                if (c !== t[o + 1] && (1 !== o || c !== c[0]))
                    if (n)
                        s = !0;
                    else {
                        var h = o * i
                          , l = h - i
                          , u = h + i;
                        for (c = 0; c !== i; ++c) {
                            var p = e[h + c];
                            if (p !== e[l + c] || p !== e[u + c]) {
                                s = !0;
                                break
                            }
                        }
                    }
                if (s) {
                    if (o !== r)
                        for (t[r] = t[o],
                        s = o * i,
                        h = r * i,
                        c = 0; c !== i; ++c)
                            e[h + c] = e[s + c];
                    ++r
                }
            }
            if (0 < a) {
                for (t[r] = t[a],
                s = a * i,
                h = r * i,
                c = 0; c !== i; ++c)
                    e[h + c] = e[s + c];
                ++r
            }
            return r !== t.length && (this.times = wa.arraySlice(t, 0, r),
            this.values = wa.arraySlice(e, 0, r * i)),
            this
        },
        clone: function() {
            var t = wa.arraySlice(this.times, 0)
              , e = wa.arraySlice(this.values, 0);
            return (t = new this.constructor(this.name,t,e)).createInterpolant = this.createInterpolant,
            t
        }
    }),
    qi.prototype = Object.assign(Object.create(Xi.prototype), {
        constructor: qi,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    Yi.prototype = Object.assign(Object.create(Xi.prototype), {
        constructor: Yi,
        ValueTypeName: "color"
    }),
    Ji.prototype = Object.assign(Object.create(Xi.prototype), {
        constructor: Ji,
        ValueTypeName: "number"
    }),
    Zi.prototype = Object.assign(Object.create(Vi.prototype), {
        constructor: Zi,
        interpolate_: function(t, e, i, r) {
            var a = this.resultBuffer
              , o = this.sampleValues
              , s = this.valueSize;
            for (e = (i - e) / (r - e),
            i = (t *= s) + s; t !== i; t += 4)
                n.slerpFlat(a, 0, o, t - s, o, t, e);
            return a
        }
    }),
    Qi.prototype = Object.assign(Object.create(Xi.prototype), {
        constructor: Qi,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(t) {
            return new Zi(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    Ki.prototype = Object.assign(Object.create(Xi.prototype), {
        constructor: Ki,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    $i.prototype = Object.assign(Object.create(Xi.prototype), {
        constructor: $i,
        ValueTypeName: "vector"
    }),
    Object.assign(tn, {
        parse: function(t) {
            for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i.length; r !== a; ++r)
                e.push(en(i[r]).scale(n));
            return new tn(t.name,t.duration,e)
        },
        toJSON: function(t) {
            var e = []
              , i = t.tracks;
            t = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid
            };
            for (var n = 0, r = i.length; n !== r; ++n)
                e.push(Xi.toJSON(i[n]));
            return t
        },
        CreateFromMorphTargetSequence: function(t, e, i, n) {
            for (var r = e.length, a = [], o = 0; o < r; o++) {
                var s = []
                  , c = [];
                s.push((o + r - 1) % r, o, (o + 1) % r),
                c.push(0, 1, 0);
                var h = wa.getKeyframeOrder(s);
                s = wa.sortedArray(s, 1, h),
                c = wa.sortedArray(c, 1, h),
                n || 0 !== s[0] || (s.push(r),
                c.push(c[0])),
                a.push(new Ji(".morphTargetInfluences[" + e[o].name + "]",s,c).scale(1 / i))
            }
            return new tn(t,-1,a)
        },
        findByName: function(t, e) {
            var i = t;
            for (Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations),
            t = 0; t < i.length; t++)
                if (i[t].name === e)
                    return i[t];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(t, e, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
                var s = t[a]
                  , c = s.name.match(r);
                if (c && 1 < c.length) {
                    var h = c[1];
                    (c = n[h]) || (n[h] = c = []),
                    c.push(s)
                }
            }
            for (h in t = [],
            n)
                t.push(tn.CreateFromMorphTargetSequence(h, n[h], e, i));
            return t
        },
        parseAnimation: function(t, e) {
            if (!t)
                return null;
            var i = function(t, e, i, n, r) {
                if (0 !== i.length) {
                    var a = []
                      , o = [];
                    wa.flattenJSON(i, a, o, n),
                    0 !== a.length && r.push(new t(e,a,o))
                }
            }
              , n = []
              , r = t.name || "default"
              , a = t.length || -1
              , o = t.fps || 30;
            t = t.hierarchy || [];
            for (var s = 0; s < t.length; s++) {
                var c = t[s].keys;
                if (c && 0 !== c.length)
                    if (c[0].morphTargets) {
                        a = {};
                        for (var h = 0; h < c.length; h++)
                            if (c[h].morphTargets)
                                for (var l = 0; l < c[h].morphTargets.length; l++)
                                    a[c[h].morphTargets[l]] = -1;
                        for (var u in a) {
                            var p = []
                              , d = [];
                            for (l = 0; l !== c[h].morphTargets.length; ++l) {
                                var f = c[h];
                                p.push(f.time),
                                d.push(f.morphTarget === u ? 1 : 0)
                            }
                            n.push(new Ji(".morphTargetInfluence[" + u + "]",p,d))
                        }
                        a = a.length * (o || 1)
                    } else
                        i($i, (h = ".bones[" + e[s].name + "]") + ".position", c, "pos", n),
                        i(Qi, h + ".quaternion", c, "rot", n),
                        i($i, h + ".scale", c, "scl", n)
            }
            return 0 === n.length ? null : new tn(r,a,n)
        }
    }),
    Object.assign(tn.prototype, {
        resetDuration: function() {
            for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
                var n = this.tracks[e];
                t = Math.max(t, n.times[n.times.length - 1])
            }
            return this.duration = t,
            this
        },
        trim: function() {
            for (var t = 0; t < this.tracks.length; t++)
                this.tracks[t].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var t = !0, e = 0; e < this.tracks.length; e++)
                t = t && this.tracks[e].validate();
            return t
        },
        optimize: function() {
            for (var t = 0; t < this.tracks.length; t++)
                this.tracks[t].optimize();
            return this
        },
        clone: function() {
            for (var t = [], e = 0; e < this.tracks.length; e++)
                t.push(this.tracks[e].clone());
            return new tn(this.name,this.duration,t)
        }
    });
    var Ma = {
        enabled: !1,
        files: {},
        add: function(t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function(t) {
            if (!1 !== this.enabled)
                return this.files[t]
        },
        remove: function(t) {
            delete this.files[t]
        },
        clear: function() {
            this.files = {}
        }
    }
      , _a = new nn
      , Sa = {};
    Object.assign(rn.prototype, {
        load: function(t, e, i, n) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            var r = this
              , a = Ma.get(t);
            if (void 0 !== a)
                return r.manager.itemStart(t),
                setTimeout(function() {
                    e && e(a),
                    r.manager.itemEnd(t)
                }, 0),
                a;
            if (void 0 === Sa[t]) {
                var o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (o) {
                    i = o[1];
                    var s = !!o[2];
                    o = o[3],
                    o = decodeURIComponent(o),
                    s && (o = atob(o));
                    try {
                        var c = (this.responseType || "").toLowerCase();
                        switch (c) {
                        case "arraybuffer":
                        case "blob":
                            var h = new Uint8Array(o.length);
                            for (s = 0; s < o.length; s++)
                                h[s] = o.charCodeAt(s);
                            var l = "blob" === c ? new Blob([h.buffer],{
                                type: i
                            }) : h.buffer;
                            break;
                        case "document":
                            l = (new DOMParser).parseFromString(o, i);
                            break;
                        case "json":
                            l = JSON.parse(o);
                            break;
                        default:
                            l = o
                        }
                        setTimeout(function() {
                            e && e(l),
                            r.manager.itemEnd(t)
                        }, 0)
                    } catch (e) {
                        setTimeout(function() {
                            n && n(e),
                            r.manager.itemError(t),
                            r.manager.itemEnd(t)
                        }, 0)
                    }
                } else {
                    Sa[t] = [],
                    Sa[t].push({
                        onLoad: e,
                        onProgress: i,
                        onError: n
                    });
                    var u = new XMLHttpRequest;
                    for (s in u.open("GET", t, !0),
                    u.addEventListener("load", function(e) {
                        var i = this.response;
                        Ma.add(t, i);
                        var n = Sa[t];
                        if (delete Sa[t],
                        200 === this.status || 0 === this.status) {
                            this.status;
                            for (var a = 0, o = n.length; a < o; a++) {
                                var s = n[a];
                                s.onLoad && s.onLoad(i)
                            }
                        } else {
                            for (a = 0,
                            o = n.length; a < o; a++)
                                (s = n[a]).onError && s.onError(e);
                            r.manager.itemError(t)
                        }
                        r.manager.itemEnd(t)
                    }, !1),
                    u.addEventListener("progress", function(e) {
                        for (var i = Sa[t], n = 0, r = i.length; n < r; n++) {
                            var a = i[n];
                            a.onProgress && a.onProgress(e)
                        }
                    }, !1),
                    u.addEventListener("error", function(e) {
                        var i = Sa[t];
                        delete Sa[t];
                        for (var n = 0, a = i.length; n < a; n++) {
                            var o = i[n];
                            o.onError && o.onError(e)
                        }
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }, !1),
                    u.addEventListener("abort", function(e) {
                        var i = Sa[t];
                        delete Sa[t];
                        for (var n = 0, a = i.length; n < a; n++) {
                            var o = i[n];
                            o.onError && o.onError(e)
                        }
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }, !1),
                    void 0 !== this.responseType && (u.responseType = this.responseType),
                    void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials),
                    u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"),
                    this.requestHeader)
                        u.setRequestHeader(s, this.requestHeader[s]);
                    u.send(null)
                }
                return r.manager.itemStart(t),
                u
            }
            Sa[t].push({
                onLoad: e,
                onProgress: i,
                onError: n
            })
        },
        setPath: function(t) {
            return this.path = t,
            this
        },
        setResponseType: function(t) {
            return this.responseType = t,
            this
        },
        setWithCredentials: function(t) {
            return this.withCredentials = t,
            this
        },
        setMimeType: function(t) {
            return this.mimeType = t,
            this
        },
        setRequestHeader: function(t) {
            return this.requestHeader = t,
            this
        }
    }),
    Object.assign(an.prototype, {
        load: function(t, e, i, n) {
            var r = this
              , a = new rn(r.manager);
            a.setPath(r.path),
            a.load(t, function(t) {
                e(r.parse(JSON.parse(t)))
            }, i, n)
        },
        parse: function(t) {
            for (var e = [], i = 0; i < t.length; i++) {
                var n = tn.parse(t[i]);
                e.push(n)
            }
            return e
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(on.prototype, {
        load: function(t, e, i, n) {
            function r(r) {
                c.load(t[r], function(t) {
                    t = a._parser(t, !0),
                    o[r] = {
                        width: t.width,
                        height: t.height,
                        format: t.format,
                        mipmaps: t.mipmaps
                    },
                    6 === (h += 1) && (1 === t.mipmapCount && (s.minFilter = 1006),
                    s.format = t.format,
                    s.needsUpdate = !0,
                    e && e(s))
                }, i, n)
            }
            var a = this
              , o = []
              , s = new Ee;
            s.image = o;
            var c = new rn(this.manager);
            if (c.setPath(this.path),
            c.setResponseType("arraybuffer"),
            Array.isArray(t))
                for (var h = 0, l = 0, u = t.length; l < u; ++l)
                    r(l);
            else
                c.load(t, function(t) {
                    if ((t = a._parser(t, !0)).isCubemap)
                        for (var i = t.mipmaps.length / t.mipmapCount, n = 0; n < i; n++) {
                            o[n] = {
                                mipmaps: []
                            };
                            for (var r = 0; r < t.mipmapCount; r++)
                                o[n].mipmaps.push(t.mipmaps[n * t.mipmapCount + r]),
                                o[n].format = t.format,
                                o[n].width = t.width,
                                o[n].height = t.height
                        }
                    else
                        s.image.width = t.width,
                        s.image.height = t.height,
                        s.mipmaps = t.mipmaps;
                    1 === t.mipmapCount && (s.minFilter = 1006),
                    s.format = t.format,
                    s.needsUpdate = !0,
                    e && e(s)
                }, i, n);
            return s
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(sn.prototype, {
        load: function(t, e, i, n) {
            var r = this
              , a = new u
              , o = new rn(this.manager);
            return o.setResponseType("arraybuffer"),
            o.setPath(this.path),
            o.load(t, function(t) {
                (t = r._parser(t)) && (void 0 !== t.image ? a.image = t.image : void 0 !== t.data && (a.image.width = t.width,
                a.image.height = t.height,
                a.image.data = t.data),
                a.wrapS = void 0 !== t.wrapS ? t.wrapS : 1001,
                a.wrapT = void 0 !== t.wrapT ? t.wrapT : 1001,
                a.magFilter = void 0 !== t.magFilter ? t.magFilter : 1006,
                a.minFilter = void 0 !== t.minFilter ? t.minFilter : 1008,
                a.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1,
                void 0 !== t.format && (a.format = t.format),
                void 0 !== t.type && (a.type = t.type),
                void 0 !== t.mipmaps && (a.mipmaps = t.mipmaps),
                1 === t.mipmapCount && (a.minFilter = 1006),
                a.needsUpdate = !0,
                e && e(a, t))
            }, i, n),
            a
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(cn.prototype, {
        crossOrigin: "anonymous",
        load: function(t, e, i, n) {
            function r() {
                c.removeEventListener("load", r, !1),
                c.removeEventListener("error", a, !1),
                Ma.add(t, this),
                e && e(this),
                o.manager.itemEnd(t)
            }
            function a(e) {
                c.removeEventListener("load", r, !1),
                c.removeEventListener("error", a, !1),
                n && n(e),
                o.manager.itemError(t),
                o.manager.itemEnd(t)
            }
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            var o = this
              , s = Ma.get(t);
            if (void 0 !== s)
                return o.manager.itemStart(t),
                setTimeout(function() {
                    e && e(s),
                    o.manager.itemEnd(t)
                }, 0),
                s;
            var c = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return c.addEventListener("load", r, !1),
            c.addEventListener("error", a, !1),
            "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin),
            o.manager.itemStart(t),
            c.src = t,
            c
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(hn.prototype, {
        crossOrigin: "anonymous",
        load: function(t, e, i, n) {
            function r(i) {
                o.load(t[i], function(t) {
                    a.images[i] = t,
                    6 === ++s && (a.needsUpdate = !0,
                    e && e(a))
                }, void 0, n)
            }
            var a = new tt
              , o = new cn(this.manager);
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path);
            var s = 0;
            for (i = 0; i < t.length; ++i)
                r(i);
            return a
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(ln.prototype, {
        crossOrigin: "anonymous",
        load: function(t, e, i, n) {
            var r = new o
              , a = new cn(this.manager);
            return a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path),
            a.load(t, function(i) {
                r.image = i,
                i = 0 < t.search(/\.jpe?g($|\?)/i) || 0 === t.search(/^data:image\/jpeg/),
                r.format = i ? 1022 : 1023,
                r.needsUpdate = !0,
                void 0 !== e && e(r)
            }, i, n),
            r
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(un.prototype, {
        getPoint: function() {
            return null
        },
        getPointAt: function(t, e) {
            return t = this.getUtoTmapping(t),
            this.getPoint(t, e)
        },
        getPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], i = 0; i <= t; i++)
                e.push(this.getPoint(i / t));
            return e
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], i = 0; i <= t; i++)
                e.push(this.getPointAt(i / t));
            return e
        },
        getLength: function() {
            var t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function(t) {
            if (void 0 === t && (t = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e, i = [], n = this.getPoint(0), r = 0;
            for (i.push(0),
            e = 1; e <= t; e++) {
                var a = this.getPoint(e / t);
                r += a.distanceTo(n),
                i.push(r),
                n = a
            }
            return this.cacheArcLengths = i
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(t, e) {
            var i = this.getLengths()
              , n = i.length;
            e = e || t * i[n - 1];
            for (var r, a = 0, o = n - 1; a <= o; )
                if (0 > (r = i[t = Math.floor(a + (o - a) / 2)] - e))
                    a = t + 1;
                else {
                    if (!(0 < r)) {
                        o = t;
                        break
                    }
                    o = t - 1
                }
            return i[t = o] === e ? t / (n - 1) : (t + (e - (a = i[t])) / (i[t + 1] - a)) / (n - 1)
        },
        getTangent: function(t) {
            var e = t - 1e-4;
            return t += 1e-4,
            0 > e && (e = 0),
            1 < t && (t = 1),
            e = this.getPoint(e),
            this.getPoint(t).clone().sub(e).normalize()
        },
        getTangentAt: function(t) {
            return t = this.getUtoTmapping(t),
            this.getTangent(t)
        },
        computeFrenetFrames: function(t, e) {
            var i, n = new r, a = [], o = [], s = [], c = new r, h = new g;
            for (i = 0; i <= t; i++) {
                var l = i / t;
                a[i] = this.getTangentAt(l),
                a[i].normalize()
            }
            o[0] = new r,
            s[0] = new r,
            i = Number.MAX_VALUE,
            l = Math.abs(a[0].x);
            var u = Math.abs(a[0].y)
              , p = Math.abs(a[0].z);
            for (l <= i && (i = l,
            n.set(1, 0, 0)),
            u <= i && (i = u,
            n.set(0, 1, 0)),
            p <= i && n.set(0, 0, 1),
            c.crossVectors(a[0], n).normalize(),
            o[0].crossVectors(a[0], c),
            s[0].crossVectors(a[0], o[0]),
            i = 1; i <= t; i++)
                o[i] = o[i - 1].clone(),
                s[i] = s[i - 1].clone(),
                c.crossVectors(a[i - 1], a[i]),
                c.length() > Number.EPSILON && (c.normalize(),
                n = Math.acos(Vr.clamp(a[i - 1].dot(a[i]), -1, 1)),
                o[i].applyMatrix4(h.makeRotationAxis(c, n))),
                s[i].crossVectors(a[i], o[i]);
            if (!0 === e)
                for (n = Math.acos(Vr.clamp(o[0].dot(o[t]), -1, 1)),
                n /= t,
                0 < a[0].dot(c.crossVectors(o[0], o[t])) && (n = -n),
                i = 1; i <= t; i++)
                    o[i].applyMatrix4(h.makeRotationAxis(a[i], n * i)),
                    s[i].crossVectors(a[i], o[i]);
            return {
                tangents: a,
                normals: o,
                binormals: s
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions,
            t.type = this.type,
            t
        },
        fromJSON: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        }
    }),
    pn.prototype = Object.create(un.prototype),
    pn.prototype.constructor = pn,
    pn.prototype.isEllipseCurve = !0,
    pn.prototype.getPoint = function(t, e) {
        e = e || new i;
        for (var n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; 0 > r; )
            r += n;
        for (; r > n; )
            r -= n;
        r < Number.EPSILON && (r = a ? 0 : n),
        !0 !== this.aClockwise || a || (r = r === n ? -n : r - n),
        n = this.aStartAngle + t * r,
        t = this.aX + this.xRadius * Math.cos(n);
        var o = this.aY + this.yRadius * Math.sin(n);
        return 0 !== this.aRotation && (n = Math.cos(this.aRotation),
        r = Math.sin(this.aRotation),
        t = (a = t - this.aX) * n - (o -= this.aY) * r + this.aX,
        o = a * r + o * n + this.aY),
        e.set(t, o)
    }
    ,
    pn.prototype.copy = function(t) {
        return un.prototype.copy.call(this, t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    ,
    pn.prototype.toJSON = function() {
        var t = un.prototype.toJSON.call(this);
        return t.aX = this.aX,
        t.aY = this.aY,
        t.xRadius = this.xRadius,
        t.yRadius = this.yRadius,
        t.aStartAngle = this.aStartAngle,
        t.aEndAngle = this.aEndAngle,
        t.aClockwise = this.aClockwise,
        t.aRotation = this.aRotation,
        t
    }
    ,
    pn.prototype.fromJSON = function(t) {
        return un.prototype.fromJSON.call(this, t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    ,
    dn.prototype = Object.create(pn.prototype),
    dn.prototype.constructor = dn,
    dn.prototype.isArcCurve = !0;
    var Ta = new r
      , Ea = new fn
      , Aa = new fn
      , La = new fn;
    mn.prototype = Object.create(un.prototype),
    mn.prototype.constructor = mn,
    mn.prototype.isCatmullRomCurve3 = !0,
    mn.prototype.getPoint = function(t, e) {
        e = e || new r;
        var i = this.points
          , n = i.length;
        t *= n - (this.closed ? 0 : 1);
        var a = Math.floor(t);
        if (t -= a,
        this.closed ? a += 0 < a ? 0 : (Math.floor(Math.abs(a) / n) + 1) * n : 0 === t && a === n - 1 && (a = n - 2,
        t = 1),
        this.closed || 0 < a)
            var o = i[(a - 1) % n];
        else
            Ta.subVectors(i[0], i[1]).add(i[0]),
            o = Ta;
        var s = i[a % n]
          , c = i[(a + 1) % n];
        if (this.closed || a + 2 < n ? i = i[(a + 2) % n] : (Ta.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]),
        i = Ta),
        "centripetal" === this.curveType || "chordal" === this.curveType) {
            var h = "chordal" === this.curveType ? .5 : .25;
            n = Math.pow(o.distanceToSquared(s), h),
            a = Math.pow(s.distanceToSquared(c), h),
            h = Math.pow(c.distanceToSquared(i), h),
            1e-4 > a && (a = 1),
            1e-4 > n && (n = a),
            1e-4 > h && (h = a),
            Ea.initNonuniformCatmullRom(o.x, s.x, c.x, i.x, n, a, h),
            Aa.initNonuniformCatmullRom(o.y, s.y, c.y, i.y, n, a, h),
            La.initNonuniformCatmullRom(o.z, s.z, c.z, i.z, n, a, h)
        } else
            "catmullrom" === this.curveType && (Ea.initCatmullRom(o.x, s.x, c.x, i.x, this.tension),
            Aa.initCatmullRom(o.y, s.y, c.y, i.y, this.tension),
            La.initCatmullRom(o.z, s.z, c.z, i.z, this.tension));
        return e.set(Ea.calc(t), Aa.calc(t), La.calc(t)),
        e
    }
    ,
    mn.prototype.copy = function(t) {
        un.prototype.copy.call(this, t),
        this.points = [];
        for (var e = 0, i = t.points.length; e < i; e++)
            this.points.push(t.points[e].clone());
        return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    ,
    mn.prototype.toJSON = function() {
        var t = un.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, i = this.points.length; e < i; e++)
            t.points.push(this.points[e].toArray());
        return t.closed = this.closed,
        t.curveType = this.curveType,
        t.tension = this.tension,
        t
    }
    ,
    mn.prototype.fromJSON = function(t) {
        un.prototype.fromJSON.call(this, t),
        this.points = [];
        for (var e = 0, i = t.points.length; e < i; e++) {
            var n = t.points[e];
            this.points.push((new r).fromArray(n))
        }
        return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    ,
    xn.prototype = Object.create(un.prototype),
    xn.prototype.constructor = xn,
    xn.prototype.isCubicBezierCurve = !0,
    xn.prototype.getPoint = function(t, e) {
        e = e || new i;
        var n = this.v0
          , r = this.v1
          , a = this.v2
          , o = this.v3;
        return e.set(yn(t, n.x, r.x, a.x, o.x), yn(t, n.y, r.y, a.y, o.y)),
        e
    }
    ,
    xn.prototype.copy = function(t) {
        return un.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    ,
    xn.prototype.toJSON = function() {
        var t = un.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    ,
    xn.prototype.fromJSON = function(t) {
        return un.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
    ,
    bn.prototype = Object.create(un.prototype),
    bn.prototype.constructor = bn,
    bn.prototype.isCubicBezierCurve3 = !0,
    bn.prototype.getPoint = function(t, e) {
        e = e || new r;
        var i = this.v0
          , n = this.v1
          , a = this.v2
          , o = this.v3;
        return e.set(yn(t, i.x, n.x, a.x, o.x), yn(t, i.y, n.y, a.y, o.y), yn(t, i.z, n.z, a.z, o.z)),
        e
    }
    ,
    bn.prototype.copy = function(t) {
        return un.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    ,
    bn.prototype.toJSON = function() {
        var t = un.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    ,
    bn.prototype.fromJSON = function(t) {
        return un.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
    ,
    wn.prototype = Object.create(un.prototype),
    wn.prototype.constructor = wn,
    wn.prototype.isLineCurve = !0,
    wn.prototype.getPoint = function(t, e) {
        return e = e || new i,
        1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1),
        e.multiplyScalar(t).add(this.v1)),
        e
    }
    ,
    wn.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }
    ,
    wn.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }
    ,
    wn.prototype.copy = function(t) {
        return un.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    wn.prototype.toJSON = function() {
        var t = un.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    wn.prototype.fromJSON = function(t) {
        return un.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    Mn.prototype = Object.create(un.prototype),
    Mn.prototype.constructor = Mn,
    Mn.prototype.isLineCurve3 = !0,
    Mn.prototype.getPoint = function(t, e) {
        return e = e || new r,
        1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1),
        e.multiplyScalar(t).add(this.v1)),
        e
    }
    ,
    Mn.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }
    ,
    Mn.prototype.copy = function(t) {
        return un.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    Mn.prototype.toJSON = function() {
        var t = un.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    Mn.prototype.fromJSON = function(t) {
        return un.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    _n.prototype = Object.create(un.prototype),
    _n.prototype.constructor = _n,
    _n.prototype.isQuadraticBezierCurve = !0,
    _n.prototype.getPoint = function(t, e) {
        e = e || new i;
        var n = this.v0
          , r = this.v1
          , a = this.v2;
        return e.set(vn(t, n.x, r.x, a.x), vn(t, n.y, r.y, a.y)),
        e
    }
    ,
    _n.prototype.copy = function(t) {
        return un.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    _n.prototype.toJSON = function() {
        var t = un.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    _n.prototype.fromJSON = function(t) {
        return un.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    Sn.prototype = Object.create(un.prototype),
    Sn.prototype.constructor = Sn,
    Sn.prototype.isQuadraticBezierCurve3 = !0,
    Sn.prototype.getPoint = function(t, e) {
        e = e || new r;
        var i = this.v0
          , n = this.v1
          , a = this.v2;
        return e.set(vn(t, i.x, n.x, a.x), vn(t, i.y, n.y, a.y), vn(t, i.z, n.z, a.z)),
        e
    }
    ,
    Sn.prototype.copy = function(t) {
        return un.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    Sn.prototype.toJSON = function() {
        var t = un.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    Sn.prototype.fromJSON = function(t) {
        return un.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    Tn.prototype = Object.create(un.prototype),
    Tn.prototype.constructor = Tn,
    Tn.prototype.isSplineCurve = !0,
    Tn.prototype.getPoint = function(t, e) {
        e = e || new i;
        var n = this.points
          , r = (n.length - 1) * t;
        r -= t = Math.floor(r);
        var a = n[0 === t ? t : t - 1]
          , o = n[t]
          , s = n[t > n.length - 2 ? n.length - 1 : t + 1];
        return n = n[t > n.length - 3 ? n.length - 1 : t + 2],
        e.set(gn(r, a.x, o.x, s.x, n.x), gn(r, a.y, o.y, s.y, n.y)),
        e
    }
    ,
    Tn.prototype.copy = function(t) {
        un.prototype.copy.call(this, t),
        this.points = [];
        for (var e = 0, i = t.points.length; e < i; e++)
            this.points.push(t.points[e].clone());
        return this
    }
    ,
    Tn.prototype.toJSON = function() {
        var t = un.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, i = this.points.length; e < i; e++)
            t.points.push(this.points[e].toArray());
        return t
    }
    ,
    Tn.prototype.fromJSON = function(t) {
        un.prototype.fromJSON.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push((new i).fromArray(r))
        }
        return this
    }
    ;
    var Pa = Object.freeze({
        ArcCurve: dn,
        CatmullRomCurve3: mn,
        CubicBezierCurve: xn,
        CubicBezierCurve3: bn,
        EllipseCurve: pn,
        LineCurve: wn,
        LineCurve3: Mn,
        QuadraticBezierCurve: _n,
        QuadraticBezierCurve3: Sn,
        SplineCurve: Tn
    });
    En.prototype = Object.assign(Object.create(un.prototype), {
        constructor: En,
        add: function(t) {
            this.curves.push(t)
        },
        closePath: function() {
            var t = this.curves[0].getPoint(0)
              , e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new wn(e,t))
        },
        getPoint: function(t) {
            var e = t * this.getLength()
              , i = this.getCurveLengths();
            for (t = 0; t < i.length; ) {
                if (i[t] >= e)
                    return e = i[t] - e,
                    i = (t = this.curves[t]).getLength(),
                    t.getPointAt(0 === i ? 0 : 1 - e / i);
                t++
            }
            return null
        },
        getLength: function() {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++)
                e += this.curves[i].getLength(),
                t.push(e);
            return this.cacheLengths = t
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 40);
            for (var e = [], i = 0; i <= t; i++)
                e.push(this.getPoint(i / t));
            return this.autoClose && e.push(e[0]),
            e
        },
        getPoints: function(t) {
            t = t || 12;
            for (var e, i = [], n = 0, r = this.curves; n < r.length; n++) {
                var a = r[n];
                a = a.getPoints(a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t);
                for (var o = 0; o < a.length; o++) {
                    var s = a[o];
                    e && e.equals(s) || (i.push(s),
                    e = s)
                }
            }
            return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]),
            i
        },
        copy: function(t) {
            un.prototype.copy.call(this, t),
            this.curves = [];
            for (var e = 0, i = t.curves.length; e < i; e++)
                this.curves.push(t.curves[e].clone());
            return this.autoClose = t.autoClose,
            this
        },
        toJSON: function() {
            var t = un.prototype.toJSON.call(this);
            t.autoClose = this.autoClose,
            t.curves = [];
            for (var e = 0, i = this.curves.length; e < i; e++)
                t.curves.push(this.curves[e].toJSON());
            return t
        },
        fromJSON: function(t) {
            un.prototype.fromJSON.call(this, t),
            this.autoClose = t.autoClose,
            this.curves = [];
            for (var e = 0, i = t.curves.length; e < i; e++) {
                var n = t.curves[e];
                this.curves.push((new Pa[n.type]).fromJSON(n))
            }
            return this
        }
    }),
    An.prototype = Object.assign(Object.create(En.prototype), {
        constructor: An,
        setFromPoints: function(t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, i = t.length; e < i; e++)
                this.lineTo(t[e].x, t[e].y)
        },
        moveTo: function(t, e) {
            this.currentPoint.set(t, e)
        },
        lineTo: function(t, e) {
            var n = new wn(this.currentPoint.clone(),new i(t,e));
            this.curves.push(n),
            this.currentPoint.set(t, e)
        },
        quadraticCurveTo: function(t, e, n, r) {
            t = new _n(this.currentPoint.clone(),new i(t,e),new i(n,r)),
            this.curves.push(t),
            this.currentPoint.set(n, r)
        },
        bezierCurveTo: function(t, e, n, r, a, o) {
            t = new xn(this.currentPoint.clone(),new i(t,e),new i(n,r),new i(a,o)),
            this.curves.push(t),
            this.currentPoint.set(a, o)
        },
        splineThru: function(t) {
            var e = [this.currentPoint.clone()].concat(t);
            e = new Tn(e),
            this.curves.push(e),
            this.currentPoint.copy(t[t.length - 1])
        },
        arc: function(t, e, i, n, r, a) {
            this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, a)
        },
        absarc: function(t, e, i, n, r, a) {
            this.absellipse(t, e, i, i, n, r, a)
        },
        ellipse: function(t, e, i, n, r, a, o, s) {
            this.absellipse(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, a, o, s)
        },
        absellipse: function(t, e, i, n, r, a, o, s) {
            t = new pn(t,e,i,n,r,a,o,s),
            0 < this.curves.length && ((e = t.getPoint(0)).equals(this.currentPoint) || this.lineTo(e.x, e.y)),
            this.curves.push(t),
            t = t.getPoint(1),
            this.currentPoint.copy(t)
        },
        copy: function(t) {
            return En.prototype.copy.call(this, t),
            this.currentPoint.copy(t.currentPoint),
            this
        },
        toJSON: function() {
            var t = En.prototype.toJSON.call(this);
            return t.currentPoint = this.currentPoint.toArray(),
            t
        },
        fromJSON: function(t) {
            return En.prototype.fromJSON.call(this, t),
            this.currentPoint.fromArray(t.currentPoint),
            this
        }
    }),
    Ln.prototype = Object.assign(Object.create(An.prototype), {
        constructor: Ln,
        getPointsHoles: function(t) {
            for (var e = [], i = 0, n = this.holes.length; i < n; i++)
                e[i] = this.holes[i].getPoints(t);
            return e
        },
        extractPoints: function(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        },
        copy: function(t) {
            An.prototype.copy.call(this, t),
            this.holes = [];
            for (var e = 0, i = t.holes.length; e < i; e++)
                this.holes.push(t.holes[e].clone());
            return this
        },
        toJSON: function() {
            var t = An.prototype.toJSON.call(this);
            t.uuid = this.uuid,
            t.holes = [];
            for (var e = 0, i = this.holes.length; e < i; e++)
                t.holes.push(this.holes[e].toJSON());
            return t
        },
        fromJSON: function(t) {
            An.prototype.fromJSON.call(this, t),
            this.uuid = t.uuid,
            this.holes = [];
            for (var e = 0, i = t.holes.length; e < i; e++) {
                var n = t.holes[e];
                this.holes.push((new An).fromJSON(n))
            }
            return this
        }
    }),
    Pn.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Pn,
        isLight: !0,
        copy: function(t) {
            return T.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.intensity = t.intensity,
            this
        },
        toJSON: function(t) {
            return (t = T.prototype.toJSON.call(this, t)).object.color = this.color.getHex(),
            t.object.intensity = this.intensity,
            void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
        }
    }),
    Cn.prototype = Object.assign(Object.create(Pn.prototype), {
        constructor: Cn,
        isHemisphereLight: !0,
        copy: function(t) {
            return Pn.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
        }
    }),
    Object.assign(In.prototype, {
        copy: function(t) {
            return this.camera = t.camera.clone(),
            this.bias = t.bias,
            this.radius = t.radius,
            this.mapSize.copy(t.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var t = {};
            return 0 !== this.bias && (t.bias = this.bias),
            1 !== this.radius && (t.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
            t.camera = this.camera.toJSON(!1).object,
            delete t.camera.matrix,
            t
        }
    }),
    Rn.prototype = Object.assign(Object.create(In.prototype), {
        constructor: Rn,
        isSpotLightShadow: !0,
        update: function(t) {
            var e = this.camera
              , i = 2 * Vr.RAD2DEG * t.angle
              , n = this.mapSize.width / this.mapSize.height;
            t = t.distance || e.far,
            i === e.fov && n === e.aspect && t === e.far || (e.fov = i,
            e.aspect = n,
            e.far = t,
            e.updateProjectionMatrix())
        }
    }),
    On.prototype = Object.assign(Object.create(Pn.prototype), {
        constructor: On,
        isSpotLight: !0,
        copy: function(t) {
            return Pn.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.angle = t.angle,
            this.penumbra = t.penumbra,
            this.decay = t.decay,
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    Dn.prototype = Object.assign(Object.create(Pn.prototype), {
        constructor: Dn,
        isPointLight: !0,
        copy: function(t) {
            return Pn.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.decay = t.decay,
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    zn.prototype = Object.assign(Object.create(ee.prototype), {
        constructor: zn,
        isOrthographicCamera: !0,
        copy: function(t, e) {
            return ee.prototype.copy.call(this, t, e),
            this.left = t.left,
            this.right = t.right,
            this.top = t.top,
            this.bottom = t.bottom,
            this.near = t.near,
            this.far = t.far,
            this.zoom = t.zoom,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this
        },
        setViewOffset: function(t, e, i, n, r, a) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = i,
            this.view.offsetY = n,
            this.view.width = r,
            this.view.height = a,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = (this.right - this.left) / (2 * this.zoom)
              , e = (this.top - this.bottom) / (2 * this.zoom)
              , i = (this.right + this.left) / 2
              , n = (this.top + this.bottom) / 2
              , r = i - t;
            if (i += t,
            t = n + e,
            e = n - e,
            null !== this.view && this.view.enabled) {
                i = this.zoom / (this.view.width / this.view.fullWidth),
                e = this.zoom / (this.view.height / this.view.fullHeight);
                var a = (this.right - this.left) / this.view.width;
                n = (this.top - this.bottom) / this.view.height,
                i = (r += this.view.offsetX / i * a) + this.view.width / i * a,
                e = (t -= this.view.offsetY / e * n) - this.view.height / e * n
            }
            this.projectionMatrix.makeOrthographic(r, i, t, e, this.near, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(t) {
            return (t = T.prototype.toJSON.call(this, t)).object.zoom = this.zoom,
            t.object.left = this.left,
            t.object.right = this.right,
            t.object.top = this.top,
            t.object.bottom = this.bottom,
            t.object.near = this.near,
            t.object.far = this.far,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t
        }
    }),
    Bn.prototype = Object.assign(Object.create(In.prototype), {
        constructor: Bn
    }),
    Nn.prototype = Object.assign(Object.create(Pn.prototype), {
        constructor: Nn,
        isDirectionalLight: !0,
        copy: function(t) {
            return Pn.prototype.copy.call(this, t),
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    kn.prototype = Object.assign(Object.create(Pn.prototype), {
        constructor: kn,
        isAmbientLight: !0
    }),
    Un.prototype = Object.assign(Object.create(Pn.prototype), {
        constructor: Un,
        isRectAreaLight: !0,
        copy: function(t) {
            return Pn.prototype.copy.call(this, t),
            this.width = t.width,
            this.height = t.height,
            this
        },
        toJSON: function(t) {
            return (t = Pn.prototype.toJSON.call(this, t)).object.width = this.width,
            t.object.height = this.height,
            t
        }
    }),
    Object.assign(Fn.prototype, {
        load: function(t, e, i, n) {
            var r = this
              , a = new rn(r.manager);
            a.setPath(r.path),
            a.load(t, function(t) {
                e(r.parse(JSON.parse(t)))
            }, i, n)
        },
        parse: function(t) {
            function e(t) {
                return n[t],
                n[t]
            }
            var n = this.textures
              , o = new ba[t.type];
            if (void 0 !== t.uuid && (o.uuid = t.uuid),
            void 0 !== t.name && (o.name = t.name),
            void 0 !== t.color && o.color.setHex(t.color),
            void 0 !== t.roughness && (o.roughness = t.roughness),
            void 0 !== t.metalness && (o.metalness = t.metalness),
            void 0 !== t.emissive && o.emissive.setHex(t.emissive),
            void 0 !== t.specular && o.specular.setHex(t.specular),
            void 0 !== t.shininess && (o.shininess = t.shininess),
            void 0 !== t.clearCoat && (o.clearCoat = t.clearCoat),
            void 0 !== t.clearCoatRoughness && (o.clearCoatRoughness = t.clearCoatRoughness),
            void 0 !== t.vertexColors && (o.vertexColors = t.vertexColors),
            void 0 !== t.fog && (o.fog = t.fog),
            void 0 !== t.flatShading && (o.flatShading = t.flatShading),
            void 0 !== t.blending && (o.blending = t.blending),
            void 0 !== t.combine && (o.combine = t.combine),
            void 0 !== t.side && (o.side = t.side),
            void 0 !== t.opacity && (o.opacity = t.opacity),
            void 0 !== t.transparent && (o.transparent = t.transparent),
            void 0 !== t.alphaTest && (o.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (o.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (o.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (o.colorWrite = t.colorWrite),
            void 0 !== t.wireframe && (o.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth && (o.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap && (o.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin && (o.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (o.rotation = t.rotation),
            1 !== t.linewidth && (o.linewidth = t.linewidth),
            void 0 !== t.dashSize && (o.dashSize = t.dashSize),
            void 0 !== t.gapSize && (o.gapSize = t.gapSize),
            void 0 !== t.scale && (o.scale = t.scale),
            void 0 !== t.polygonOffset && (o.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor && (o.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits && (o.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.skinning && (o.skinning = t.skinning),
            void 0 !== t.morphTargets && (o.morphTargets = t.morphTargets),
            void 0 !== t.dithering && (o.dithering = t.dithering),
            void 0 !== t.visible && (o.visible = t.visible),
            void 0 !== t.userData && (o.userData = t.userData),
            void 0 !== t.uniforms)
                for (var c in t.uniforms) {
                    var h = t.uniforms[c];
                    switch (o.uniforms[c] = {},
                    h.type) {
                    case "t":
                        o.uniforms[c].value = e(h.value);
                        break;
                    case "c":
                        o.uniforms[c].value = (new x).setHex(h.value);
                        break;
                    case "v2":
                        o.uniforms[c].value = (new i).fromArray(h.value);
                        break;
                    case "v3":
                        o.uniforms[c].value = (new r).fromArray(h.value);
                        break;
                    case "v4":
                        o.uniforms[c].value = (new s).fromArray(h.value);
                        break;
                    case "m3":
                        o.uniforms[c].value = (new a).fromArray(h.value);
                    case "m4":
                        o.uniforms[c].value = (new g).fromArray(h.value);
                        break;
                    default:
                        o.uniforms[c].value = h.value
                    }
                }
            if (void 0 !== t.defines && (o.defines = t.defines),
            void 0 !== t.vertexShader && (o.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader && (o.fragmentShader = t.fragmentShader),
            void 0 !== t.extensions)
                for (var l in t.extensions)
                    o.extensions[l] = t.extensions[l];
            return void 0 !== t.shading && (o.flatShading = 1 === t.shading),
            void 0 !== t.size && (o.size = t.size),
            void 0 !== t.sizeAttenuation && (o.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (o.map = e(t.map)),
            void 0 !== t.alphaMap && (o.alphaMap = e(t.alphaMap),
            o.transparent = !0),
            void 0 !== t.bumpMap && (o.bumpMap = e(t.bumpMap)),
            void 0 !== t.bumpScale && (o.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (o.normalMap = e(t.normalMap)),
            void 0 !== t.normalMapType && (o.normalMapType = t.normalMapType),
            void 0 !== t.normalScale && (c = t.normalScale,
            !1 === Array.isArray(c) && (c = [c, c]),
            o.normalScale = (new i).fromArray(c)),
            void 0 !== t.displacementMap && (o.displacementMap = e(t.displacementMap)),
            void 0 !== t.displacementScale && (o.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias && (o.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (o.roughnessMap = e(t.roughnessMap)),
            void 0 !== t.metalnessMap && (o.metalnessMap = e(t.metalnessMap)),
            void 0 !== t.emissiveMap && (o.emissiveMap = e(t.emissiveMap)),
            void 0 !== t.emissiveIntensity && (o.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (o.specularMap = e(t.specularMap)),
            void 0 !== t.envMap && (o.envMap = e(t.envMap)),
            void 0 !== t.envMapIntensity && (o.envMapIntensity = t.envMapIntensity),
            void 0 !== t.reflectivity && (o.reflectivity = t.reflectivity),
            void 0 !== t.lightMap && (o.lightMap = e(t.lightMap)),
            void 0 !== t.lightMapIntensity && (o.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (o.aoMap = e(t.aoMap)),
            void 0 !== t.aoMapIntensity && (o.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (o.gradientMap = e(t.gradientMap)),
            o
        },
        setPath: function(t) {
            return this.path = t,
            this
        },
        setTextures: function(t) {
            return this.textures = t,
            this
        }
    });
    var Ca = {
        decodeText: function(t) {
            if ("undefined" != typeof TextDecoder)
                return (new TextDecoder).decode(t);
            for (var e = "", i = 0, n = t.length; i < n; i++)
                e += String.fromCharCode(t[i]);
            return decodeURIComponent(escape(e))
        },
        extractUrlBase: function(t) {
            var e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        }
    };
    Object.assign(Gn.prototype, {
        load: function(t, e, i, n) {
            var r = this
              , a = new rn(r.manager);
            a.setPath(r.path),
            a.load(t, function(t) {
                e(r.parse(JSON.parse(t)))
            }, i, n)
        },
        parse: function(t) {
            var e = new U
              , i = t.data.index;
            if (void 0 !== i) {
                var n = new Ia[i.type](i.array);
                e.setIndex(new A(n,1))
            }
            for (var a in i = t.data.attributes) {
                var o = i[a];
                n = new A(n = new Ia[o.type](o.array),o.itemSize,o.normalized),
                void 0 !== o.name && (n.name = o.name),
                e.addAttribute(a, n)
            }
            var s = t.data.morphAttributes;
            if (s)
                for (a in s) {
                    var c = s[a]
                      , h = [];
                    i = 0;
                    for (var l = c.length; i < l; i++)
                        o = c[i],
                        n = new A(n = new Ia[o.type](o.array),o.itemSize,o.normalized),
                        void 0 !== o.name && (n.name = o.name),
                        h.push(n);
                    e.morphAttributes[a] = h
                }
            if (void 0 !== (a = t.data.groups || t.data.drawcalls || t.data.offsets))
                for (i = 0,
                o = a.length; i !== o; ++i)
                    n = a[i],
                    e.addGroup(n.start, n.count, n.materialIndex);
            return void 0 !== (i = t.data.boundingSphere) && (a = new r,
            void 0 !== i.center && a.fromArray(i.center),
            e.boundingSphere = new d(a,i.radius)),
            t.name && (e.name = t.name),
            t.userData && (e.userData = t.userData),
            e
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    });
    var Ia = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    Object.assign(Vn.prototype, {
        crossOrigin: "anonymous",
        load: function(t, e, i, n) {
            var r = this
              , a = void 0 === this.path ? Ca.extractUrlBase(t) : this.path;
            this.resourcePath = this.resourcePath || a,
            (a = new rn(r.manager)).setPath(this.path),
            a.load(t, function(t) {
                var i = null;
                try {
                    i = JSON.parse(t)
                } catch (t) {
                    return void (void 0 !== n && n(t))
                }
                void 0 === (t = i.metadata) || void 0 === t.type || "geometry" === t.type.toLowerCase() || r.parse(i, e)
            }, i, n)
        },
        setPath: function(t) {
            return this.path = t,
            this
        },
        setResourcePath: function(t) {
            return this.resourcePath = t,
            this
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        parse: function(t, e) {
            var i = this.parseShape(t.shapes);
            i = this.parseGeometries(t.geometries, i);
            var n = this.parseImages(t.images, function() {
                void 0 !== e && e(r)
            });
            n = this.parseTextures(t.textures, n),
            n = this.parseMaterials(t.materials, n);
            var r = this.parseObject(t.object, i, n);
            return t.animations && (r.animations = this.parseAnimations(t.animations)),
            void 0 !== t.images && 0 !== t.images.length || void 0 === e || e(r),
            r
        },
        parseShape: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var i = 0, n = t.length; i < n; i++) {
                    var r = (new Ln).fromJSON(t[i]);
                    e[r.uuid] = r
                }
            return e
        },
        parseGeometries: function(t, e) {
            var i = {};
            if (void 0 !== t)
                for (var n = new Gn, r = 0, a = t.length; r < a; r++) {
                    var o = t[r];
                    switch (o.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        var s = new xa[o.type](o.width,o.height,o.widthSegments,o.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        s = new xa[o.type](o.width,o.height,o.depth,o.widthSegments,o.heightSegments,o.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        s = new xa[o.type](o.radius,o.segments,o.thetaStart,o.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        s = new xa[o.type](o.radiusTop,o.radiusBottom,o.height,o.radialSegments,o.heightSegments,o.openEnded,o.thetaStart,o.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        s = new xa[o.type](o.radius,o.height,o.radialSegments,o.heightSegments,o.openEnded,o.thetaStart,o.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        s = new xa[o.type](o.radius,o.widthSegments,o.heightSegments,o.phiStart,o.phiLength,o.thetaStart,o.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        s = new xa[o.type](o.radius,o.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        s = new xa[o.type](o.innerRadius,o.outerRadius,o.thetaSegments,o.phiSegments,o.thetaStart,o.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        s = new xa[o.type](o.radius,o.tube,o.radialSegments,o.tubularSegments,o.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        s = new xa[o.type](o.radius,o.tube,o.tubularSegments,o.radialSegments,o.p,o.q);
                        break;
                    case "TubeGeometry":
                    case "TubeBufferGeometry":
                        s = new xa[o.type]((new Pa[o.path.type]).fromJSON(o.path),o.tubularSegments,o.radius,o.radialSegments,o.closed);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        s = new xa[o.type](o.points,o.segments,o.phiStart,o.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        s = new xa[o.type](o.vertices,o.indices,o.radius,o.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        s = [];
                        for (var c = 0, h = o.shapes.length; c < h; c++) {
                            var l = e[o.shapes[c]];
                            s.push(l)
                        }
                        s = new xa[o.type](s,o.curveSegments);
                        break;
                    case "ExtrudeGeometry":
                    case "ExtrudeBufferGeometry":
                        for (s = [],
                        c = 0,
                        h = o.shapes.length; c < h; c++)
                            l = e[o.shapes[c]],
                            s.push(l);
                        void 0 !== (c = o.options.extrudePath) && (o.options.extrudePath = (new Pa[c.type]).fromJSON(c)),
                        s = new xa[o.type](s,o.options);
                        break;
                    case "BufferGeometry":
                        s = n.parse(o);
                        break;
                    case "Geometry":
                        "THREE"in window && "LegacyJSONLoader"in THREE && (s = (new THREE.LegacyJSONLoader).parse(o, this.resourcePath).geometry);
                        break;
                    default:
                        continue
                    }
                    s.uuid = o.uuid,
                    void 0 !== o.name && (s.name = o.name),
                    !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData),
                    i[o.uuid] = s
                }
            return i
        },
        parseMaterials: function(t, e) {
            var i = {}
              , n = {};
            if (void 0 !== t) {
                var r = new Fn;
                r.setTextures(e),
                e = 0;
                for (var a = t.length; e < a; e++) {
                    var o = t[e];
                    if ("MultiMaterial" === o.type) {
                        for (var s = [], c = 0; c < o.materials.length; c++) {
                            var h = o.materials[c];
                            void 0 === i[h.uuid] && (i[h.uuid] = r.parse(h)),
                            s.push(i[h.uuid])
                        }
                        n[o.uuid] = s
                    } else
                        void 0 === i[o.uuid] && (i[o.uuid] = r.parse(o)),
                        n[o.uuid] = i[o.uuid]
                }
            }
            return n
        },
        parseAnimations: function(t) {
            for (var e = [], i = 0; i < t.length; i++) {
                var n = t[i]
                  , r = tn.parse(n);
                void 0 !== n.uuid && (r.uuid = n.uuid),
                e.push(r)
            }
            return e
        },
        parseImages: function(t, e) {
            function i(t) {
                return n.manager.itemStart(t),
                a.load(t, function() {
                    n.manager.itemEnd(t)
                }, void 0, function() {
                    n.manager.itemError(t),
                    n.manager.itemEnd(t)
                })
            }
            var n = this
              , r = {};
            if (void 0 !== t && 0 < t.length) {
                var a = new cn(e = new nn(e));
                a.setCrossOrigin(this.crossOrigin),
                e = 0;
                for (var o = t.length; e < o; e++) {
                    var s = t[e]
                      , c = s.url;
                    if (Array.isArray(c)) {
                        r[s.uuid] = [];
                        for (var h = 0, l = c.length; h < l; h++) {
                            var u = c[h];
                            u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u,
                            r[s.uuid].push(i(u))
                        }
                    } else
                        u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : n.resourcePath + s.url,
                        r[s.uuid] = i(u)
                }
            }
            return r
        },
        parseTextures: function(t, e) {
            function i(t, e) {
                return "number" == typeof t ? t : e[t]
            }
            var n = {};
            if (void 0 !== t)
                for (var r = 0, a = t.length; r < a; r++) {
                    var s = t[r];
                    s.image,
                    e[s.image];
                    var c = Array.isArray(e[s.image]) ? new tt(e[s.image]) : new o(e[s.image]);
                    c.needsUpdate = !0,
                    c.uuid = s.uuid,
                    void 0 !== s.name && (c.name = s.name),
                    void 0 !== s.mapping && (c.mapping = i(s.mapping, Ra)),
                    void 0 !== s.offset && c.offset.fromArray(s.offset),
                    void 0 !== s.repeat && c.repeat.fromArray(s.repeat),
                    void 0 !== s.center && c.center.fromArray(s.center),
                    void 0 !== s.rotation && (c.rotation = s.rotation),
                    void 0 !== s.wrap && (c.wrapS = i(s.wrap[0], Oa),
                    c.wrapT = i(s.wrap[1], Oa)),
                    void 0 !== s.format && (c.format = s.format),
                    void 0 !== s.type && (c.type = s.type),
                    void 0 !== s.encoding && (c.encoding = s.encoding),
                    void 0 !== s.minFilter && (c.minFilter = i(s.minFilter, Da)),
                    void 0 !== s.magFilter && (c.magFilter = i(s.magFilter, Da)),
                    void 0 !== s.anisotropy && (c.anisotropy = s.anisotropy),
                    void 0 !== s.flipY && (c.flipY = s.flipY),
                    void 0 !== s.premultiplyAlpha && (c.premultiplyAlpha = s.premultiplyAlpha),
                    void 0 !== s.unpackAlignment && (c.unpackAlignment = s.unpackAlignment),
                    n[s.uuid] = c
                }
            return n
        },
        parseObject: function(t, e, i) {
            function n(t) {
                return e[t],
                e[t]
            }
            function r(t) {
                if (void 0 !== t) {
                    if (Array.isArray(t)) {
                        for (var e = [], n = 0, r = t.length; n < r; n++) {
                            var a = t[n];
                            i[a],
                            e.push(i[a])
                        }
                        return e
                    }
                    return i[t],
                    i[t]
                }
            }
            switch (t.type) {
            case "Scene":
                var a = new le;
                void 0 !== t.background && Number.isInteger(t.background) && (a.background = new x(t.background)),
                void 0 !== t.fog && ("Fog" === t.fog.type ? a.fog = new he(t.fog.color,t.fog.near,t.fog.far) : "FogExp2" === t.fog.type && (a.fog = new ce(t.fog.color,t.fog.density)));
                break;
            case "PerspectiveCamera":
                a = new ie(t.fov,t.aspect,t.near,t.far),
                void 0 !== t.focus && (a.focus = t.focus),
                void 0 !== t.zoom && (a.zoom = t.zoom),
                void 0 !== t.filmGauge && (a.filmGauge = t.filmGauge),
                void 0 !== t.filmOffset && (a.filmOffset = t.filmOffset),
                void 0 !== t.view && (a.view = Object.assign({}, t.view));
                break;
            case "OrthographicCamera":
                a = new zn(t.left,t.right,t.top,t.bottom,t.near,t.far),
                void 0 !== t.zoom && (a.zoom = t.zoom),
                void 0 !== t.view && (a.view = Object.assign({}, t.view));
                break;
            case "AmbientLight":
                a = new kn(t.color,t.intensity);
                break;
            case "DirectionalLight":
                a = new Nn(t.color,t.intensity);
                break;
            case "PointLight":
                a = new Dn(t.color,t.intensity,t.distance,t.decay);
                break;
            case "RectAreaLight":
                a = new Un(t.color,t.intensity,t.width,t.height);
                break;
            case "SpotLight":
                a = new On(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);
                break;
            case "HemisphereLight":
                a = new Cn(t.color,t.groundColor,t.intensity);
                break;
            case "SkinnedMesh":
            case "Mesh":
                a = n(t.geometry);
                var o = r(t.material);
                a = a.bones && 0 < a.bones.length ? new ge(a,o) : new J(a,o),
                void 0 !== t.drawMode && a.setDrawMode(t.drawMode);
                break;
            case "LOD":
                a = new me;
                break;
            case "Line":
                a = new be(n(t.geometry),r(t.material),t.mode);
                break;
            case "LineLoop":
                a = new Me(n(t.geometry),r(t.material));
                break;
            case "LineSegments":
                a = new we(n(t.geometry),r(t.material));
                break;
            case "PointCloud":
            case "Points":
                a = new Se(n(t.geometry),r(t.material));
                break;
            case "Sprite":
                a = new fe(r(t.material));
                break;
            case "Group":
                a = new te;
                break;
            default:
                a = new T
            }
            if (a.uuid = t.uuid,
            void 0 !== t.name && (a.name = t.name),
            void 0 !== t.matrix ? (a.matrix.fromArray(t.matrix),
            void 0 !== t.matrixAutoUpdate && (a.matrixAutoUpdate = t.matrixAutoUpdate),
            a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== t.position && a.position.fromArray(t.position),
            void 0 !== t.rotation && a.rotation.fromArray(t.rotation),
            void 0 !== t.quaternion && a.quaternion.fromArray(t.quaternion),
            void 0 !== t.scale && a.scale.fromArray(t.scale)),
            void 0 !== t.castShadow && (a.castShadow = t.castShadow),
            void 0 !== t.receiveShadow && (a.receiveShadow = t.receiveShadow),
            t.shadow && (void 0 !== t.shadow.bias && (a.shadow.bias = t.shadow.bias),
            void 0 !== t.shadow.radius && (a.shadow.radius = t.shadow.radius),
            void 0 !== t.shadow.mapSize && a.shadow.mapSize.fromArray(t.shadow.mapSize),
            void 0 !== t.shadow.camera && (a.shadow.camera = this.parseObject(t.shadow.camera))),
            void 0 !== t.visible && (a.visible = t.visible),
            void 0 !== t.frustumCulled && (a.frustumCulled = t.frustumCulled),
            void 0 !== t.renderOrder && (a.renderOrder = t.renderOrder),
            void 0 !== t.userData && (a.userData = t.userData),
            void 0 !== t.layers && (a.layers.mask = t.layers),
            void 0 !== t.children) {
                o = t.children;
                for (var s = 0; s < o.length; s++)
                    a.add(this.parseObject(o[s], e, i))
            }
            if ("LOD" === t.type)
                for (t = t.levels,
                o = 0; o < t.length; o++) {
                    s = t[o];
                    var c = a.getObjectByProperty("uuid", s.object);
                    void 0 !== c && a.addLevel(c, s.distance)
                }
            return a
        }
    });
    var Ra = {
        UVMapping: 300,
        CubeReflectionMapping: 301,
        CubeRefractionMapping: 302,
        EquirectangularReflectionMapping: 303,
        EquirectangularRefractionMapping: 304,
        SphericalReflectionMapping: 305,
        CubeUVReflectionMapping: 306,
        CubeUVRefractionMapping: 307
    }
      , Oa = {
        RepeatWrapping: 1e3,
        ClampToEdgeWrapping: 1001,
        MirroredRepeatWrapping: 1002
    }
      , Da = {
        NearestFilter: 1003,
        NearestMipMapNearestFilter: 1004,
        NearestMipMapLinearFilter: 1005,
        LinearFilter: 1006,
        LinearMipMapNearestFilter: 1007,
        LinearMipMapLinearFilter: 1008
    };
    jn.prototype = {
        constructor: jn,
        setOptions: function(t) {
            return this.options = t,
            this
        },
        load: function(t, e, i, n) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            var r = this
              , a = Ma.get(t);
            if (void 0 !== a)
                return r.manager.itemStart(t),
                setTimeout(function() {
                    e && e(a),
                    r.manager.itemEnd(t)
                }, 0),
                a;
            fetch(t).then(function(t) {
                return t.blob()
            }).then(function(t) {
                return void 0 === r.options ? createImageBitmap(t) : createImageBitmap(t, r.options)
            }).then(function(i) {
                Ma.add(t, i),
                e && e(i),
                r.manager.itemEnd(t)
            }).catch(function(e) {
                n && n(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }),
            r.manager.itemStart(t)
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    },
    Object.assign(Hn.prototype, {
        moveTo: function(t, e) {
            this.currentPath = new An,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e)
        },
        lineTo: function(t, e) {
            this.currentPath.lineTo(t, e)
        },
        quadraticCurveTo: function(t, e, i, n) {
            this.currentPath.quadraticCurveTo(t, e, i, n)
        },
        bezierCurveTo: function(t, e, i, n, r, a) {
            this.currentPath.bezierCurveTo(t, e, i, n, r, a)
        },
        splineThru: function(t) {
            this.currentPath.splineThru(t)
        },
        toShapes: function(t, e) {
            function i(t) {
                for (var e = [], i = 0, n = t.length; i < n; i++) {
                    var r = t[i]
                      , a = new Ln;
                    a.curves = r.curves,
                    e.push(a)
                }
                return e
            }
            function n(t, e) {
                for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
                    var o = e[r]
                      , s = e[a]
                      , c = s.x - o.x
                      , h = s.y - o.y;
                    if (Math.abs(h) > Number.EPSILON) {
                        if (0 > h && (o = e[a],
                        c = -c,
                        s = e[r],
                        h = -h),
                        !(t.y < o.y || t.y > s.y))
                            if (t.y === o.y) {
                                if (t.x === o.x)
                                    return !0
                            } else {
                                if (0 === (r = h * (t.x - o.x) - c * (t.y - o.y)))
                                    return !0;
                                0 > r || (n = !n)
                            }
                    } else if (t.y === o.y && (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x))
                        return !0
                }
                return n
            }
            var r = va.isClockWise
              , a = this.subPaths;
            if (0 === a.length)
                return [];
            if (!0 === e)
                return i(a);
            if (e = [],
            1 === a.length) {
                var o = a[0]
                  , s = new Ln;
                return s.curves = o.curves,
                e.push(s),
                e
            }
            var c = !r(a[0].getPoints());
            c = t ? !c : c,
            s = [];
            var h = []
              , l = []
              , u = 0;
            h[u] = void 0,
            l[u] = [];
            for (var p = 0, d = a.length; p < d; p++) {
                var f = (o = a[p]).getPoints()
                  , m = r(f);
                (m = t ? !m : m) ? (!c && h[u] && u++,
                h[u] = {
                    s: new Ln,
                    p: f
                },
                h[u].s.curves = o.curves,
                c && u++,
                l[u] = []) : l[u].push({
                    h: o,
                    p: f[0]
                })
            }
            if (!h[0])
                return i(a);
            if (1 < h.length) {
                for (p = !1,
                t = [],
                r = 0,
                a = h.length; r < a; r++)
                    s[r] = [];
                for (r = 0,
                a = h.length; r < a; r++)
                    for (o = l[r],
                    m = 0; m < o.length; m++) {
                        for (c = o[m],
                        u = !0,
                        f = 0; f < h.length; f++)
                            n(c.p, h[f].p) && (r !== f && t.push({
                                froms: r,
                                tos: f,
                                hole: m
                            }),
                            u ? (u = !1,
                            s[f].push(c)) : p = !0);
                        u && s[r].push(c)
                    }
                0 < t.length && (p || (l = s))
            }
            for (p = 0,
            r = h.length; p < r; p++)
                for (s = h[p].s,
                e.push(s),
                a = 0,
                o = (t = l[p]).length; a < o; a++)
                    s.holes.push(t[a].h);
            return e
        }
    }),
    Object.assign(Wn.prototype, {
        isFont: !0,
        generateShapes: function(t, e) {
            void 0 === e && (e = 100);
            var i = []
              , n = e;
            e = this.data;
            var r = Array.from ? Array.from(t) : String(t).split("");
            n /= e.resolution;
            var a = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * n;
            t = [];
            for (var o = 0, s = 0, c = 0; c < r.length; c++) {
                var h = r[c];
                if ("\n" === h)
                    o = 0,
                    s -= a;
                else {
                    var l = n
                      , u = o
                      , p = s;
                    if (h = e.glyphs[h] || e.glyphs["?"]) {
                        var d = new Hn;
                        if (h.o)
                            for (var f = h._cachedOutline || (h._cachedOutline = h.o.split(" ")), m = 0, g = f.length; m < g; )
                                switch (f[m++]) {
                                case "m":
                                    var v = f[m++] * l + u
                                      , y = f[m++] * l + p;
                                    d.moveTo(v, y);
                                    break;
                                case "l":
                                    v = f[m++] * l + u,
                                    y = f[m++] * l + p,
                                    d.lineTo(v, y);
                                    break;
                                case "q":
                                    var x = f[m++] * l + u
                                      , b = f[m++] * l + p
                                      , w = f[m++] * l + u
                                      , M = f[m++] * l + p;
                                    d.quadraticCurveTo(w, M, x, b);
                                    break;
                                case "b":
                                    x = f[m++] * l + u,
                                    b = f[m++] * l + p,
                                    w = f[m++] * l + u,
                                    M = f[m++] * l + p,
                                    v = f[m++] * l + u,
                                    y = f[m++] * l + p,
                                    d.bezierCurveTo(w, M, v, y, x, b)
                                }
                        l = {
                            offsetX: h.ha * l,
                            path: d
                        }
                    } else
                        l = void 0;
                    o += l.offsetX,
                    t.push(l.path)
                }
            }
            for (e = 0,
            r = t.length; e < r; e++)
                Array.prototype.push.apply(i, t[e].toShapes());
            return i
        }
    }),
    Object.assign(Xn.prototype, {
        load: function(t, e, i, n) {
            var r = this
              , a = new rn(this.manager);
            a.setPath(this.path),
            a.load(t, function(t) {
                try {
                    var i = JSON.parse(t)
                } catch (e) {
                    i = JSON.parse(t.substring(65, t.length - 2))
                }
                t = r.parse(i),
                e && e(t)
            }, i, n)
        },
        parse: function(t) {
            return new Wn(t)
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    qn.Handlers = {
        handlers: [],
        add: function(t, e) {
            this.handlers.push(t, e)
        },
        get: function(t) {
            for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                var r = e[i + 1];
                if (e[i].test(t))
                    return r
            }
            return null
        }
    },
    Object.assign(qn.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(t, e, i) {
            for (var n = [], r = 0; r < t.length; ++r)
                n[r] = this.createMaterial(t[r], e, i);
            return n
        },
        createMaterial: function() {
            var t = {
                NoBlending: 0,
                NormalBlending: 1,
                AdditiveBlending: 2,
                SubtractiveBlending: 3,
                MultiplyBlending: 4,
                CustomBlending: 5
            }
              , e = new x
              , i = new ln
              , n = new Fn;
            return function(r, a, o) {
                function s(t, e, n, r, s) {
                    t = a + t;
                    var c = qn.Handlers.get(t);
                    return null !== c ? t = c.load(t) : (i.setCrossOrigin(o),
                    t = i.load(t)),
                    void 0 !== e && (t.repeat.fromArray(e),
                    1 !== e[0] && (t.wrapS = 1e3),
                    1 !== e[1] && (t.wrapT = 1e3)),
                    void 0 !== n && t.offset.fromArray(n),
                    void 0 !== r && ("repeat" === r[0] && (t.wrapS = 1e3),
                    "mirror" === r[0] && (t.wrapS = 1002),
                    "repeat" === r[1] && (t.wrapT = 1e3),
                    "mirror" === r[1] && (t.wrapT = 1002)),
                    void 0 !== s && (t.anisotropy = s),
                    e = Vr.generateUUID(),
                    h[e] = t,
                    e
                }
                var c, h = {}, l = {
                    uuid: Vr.generateUUID(),
                    type: "MeshLambertMaterial"
                };
                for (c in r) {
                    var u = r[c];
                    switch (c) {
                    case "DbgColor":
                    case "DbgIndex":
                    case "opticalDensity":
                    case "illumination":
                        break;
                    case "DbgName":
                        l.name = u;
                        break;
                    case "blending":
                        l.blending = t[u];
                        break;
                    case "colorAmbient":
                    case "mapAmbient":
                        break;
                    case "colorDiffuse":
                        l.color = e.fromArray(u).getHex();
                        break;
                    case "colorSpecular":
                        l.specular = e.fromArray(u).getHex();
                        break;
                    case "colorEmissive":
                        l.emissive = e.fromArray(u).getHex();
                        break;
                    case "specularCoef":
                        l.shininess = u;
                        break;
                    case "shading":
                        "basic" === u.toLowerCase() && (l.type = "MeshBasicMaterial"),
                        "phong" === u.toLowerCase() && (l.type = "MeshPhongMaterial"),
                        "standard" === u.toLowerCase() && (l.type = "MeshStandardMaterial");
                        break;
                    case "mapDiffuse":
                        l.map = s(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                        break;
                    case "mapDiffuseRepeat":
                    case "mapDiffuseOffset":
                    case "mapDiffuseWrap":
                    case "mapDiffuseAnisotropy":
                        break;
                    case "mapEmissive":
                        l.emissiveMap = s(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                        break;
                    case "mapEmissiveRepeat":
                    case "mapEmissiveOffset":
                    case "mapEmissiveWrap":
                    case "mapEmissiveAnisotropy":
                        break;
                    case "mapLight":
                        l.lightMap = s(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                        break;
                    case "mapLightRepeat":
                    case "mapLightOffset":
                    case "mapLightWrap":
                    case "mapLightAnisotropy":
                        break;
                    case "mapAO":
                        l.aoMap = s(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                        break;
                    case "mapAORepeat":
                    case "mapAOOffset":
                    case "mapAOWrap":
                    case "mapAOAnisotropy":
                        break;
                    case "mapBump":
                        l.bumpMap = s(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                        break;
                    case "mapBumpScale":
                        l.bumpScale = u;
                        break;
                    case "mapBumpRepeat":
                    case "mapBumpOffset":
                    case "mapBumpWrap":
                    case "mapBumpAnisotropy":
                        break;
                    case "mapNormal":
                        l.normalMap = s(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                        break;
                    case "mapNormalFactor":
                        l.normalScale = u;
                        break;
                    case "mapNormalRepeat":
                    case "mapNormalOffset":
                    case "mapNormalWrap":
                    case "mapNormalAnisotropy":
                        break;
                    case "mapSpecular":
                        l.specularMap = s(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                        break;
                    case "mapSpecularRepeat":
                    case "mapSpecularOffset":
                    case "mapSpecularWrap":
                    case "mapSpecularAnisotropy":
                        break;
                    case "mapMetalness":
                        l.metalnessMap = s(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                        break;
                    case "mapMetalnessRepeat":
                    case "mapMetalnessOffset":
                    case "mapMetalnessWrap":
                    case "mapMetalnessAnisotropy":
                        break;
                    case "mapRoughness":
                        l.roughnessMap = s(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                        break;
                    case "mapRoughnessRepeat":
                    case "mapRoughnessOffset":
                    case "mapRoughnessWrap":
                    case "mapRoughnessAnisotropy":
                        break;
                    case "mapAlpha":
                        l.alphaMap = s(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                        break;
                    case "mapAlphaRepeat":
                    case "mapAlphaOffset":
                    case "mapAlphaWrap":
                    case "mapAlphaAnisotropy":
                        break;
                    case "flipSided":
                        l.side = 1;
                        break;
                    case "doubleSided":
                        l.side = 2;
                        break;
                    case "transparency":
                        l.opacity = u;
                        break;
                    case "depthTest":
                    case "depthWrite":
                    case "colorWrite":
                    case "opacity":
                    case "reflectivity":
                    case "transparent":
                    case "visible":
                    case "wireframe":
                        l[c] = u;
                        break;
                    case "vertexColors":
                        !0 === u && (l.vertexColors = 2),
                        "face" === u && (l.vertexColors = 1)
                    }
                }
                return "MeshBasicMaterial" === l.type && delete l.emissive,
                "MeshPhongMaterial" !== l.type && delete l.specular,
                1 > l.opacity && (l.transparent = !0),
                n.setTextures(h),
                n.parse(l)
            }
        }()
    });
    var za, Ba, Na, ka = {
        getContext: function() {
            return void 0 === za && (za = new (window.AudioContext || window.webkitAudioContext)),
            za
        },
        setContext: function(t) {
            za = t
        }
    };
    Object.assign(Yn.prototype, {
        load: function(t, e, i, n) {
            var r = new rn(this.manager);
            r.setResponseType("arraybuffer"),
            r.setPath(this.path),
            r.load(t, function(t) {
                t = t.slice(0),
                ka.getContext().decodeAudioData(t, function(t) {
                    e(t)
                })
            }, i, n)
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(Jn.prototype, {
        update: function() {
            var t, e, i, n, r, a, o, s, c = new g, h = new g;
            return function(l) {
                if (t !== this || e !== l.focus || i !== l.fov || n !== l.aspect * this.aspect || r !== l.near || a !== l.far || o !== l.zoom || s !== this.eyeSep) {
                    t = this,
                    e = l.focus,
                    i = l.fov,
                    n = l.aspect * this.aspect,
                    r = l.near,
                    a = l.far,
                    o = l.zoom;
                    var u = l.projectionMatrix.clone()
                      , p = (s = this.eyeSep / 2) * r / e
                      , d = r * Math.tan(Vr.DEG2RAD * i * .5) / o;
                    h.elements[12] = -s,
                    c.elements[12] = s;
                    var f = -d * n + p
                      , m = d * n + p;
                    u.elements[0] = 2 * r / (m - f),
                    u.elements[8] = (m + f) / (m - f),
                    this.cameraL.projectionMatrix.copy(u),
                    f = -d * n - p,
                    m = d * n - p,
                    u.elements[0] = 2 * r / (m - f),
                    u.elements[8] = (m + f) / (m - f),
                    this.cameraR.projectionMatrix.copy(u)
                }
                this.cameraL.matrixWorld.copy(l.matrixWorld).multiply(h),
                this.cameraR.matrixWorld.copy(l.matrixWorld).multiply(c)
            }
        }()
    }),
    Zn.prototype = Object.create(T.prototype),
    Zn.prototype.constructor = Zn,
    Object.assign(Qn.prototype, {
        start: function() {
            this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
            this.elapsedTime = 0,
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime(),
            this.autoStart = this.running = !1
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var t = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                var e = ("undefined" == typeof performance ? Date : performance).now();
                t = (e - this.oldTime) / 1e3,
                this.oldTime = e,
                this.elapsedTime += t
            }
            return t
        }
    }),
    Kn.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Kn,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null),
            this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(t) {
            return null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = t,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
            this
        },
        updateMatrixWorld: function() {
            var t = new r
              , e = new n
              , i = new r
              , a = new r
              , o = new Qn;
            return function(n) {
                T.prototype.updateMatrixWorld.call(this, n),
                n = this.context.listener;
                var r = this.up;
                if (this.timeDelta = o.getDelta(),
                this.matrixWorld.decompose(t, e, i),
                a.set(0, 0, -1).applyQuaternion(e),
                n.positionX) {
                    var s = this.context.currentTime + this.timeDelta;
                    n.positionX.linearRampToValueAtTime(t.x, s),
                    n.positionY.linearRampToValueAtTime(t.y, s),
                    n.positionZ.linearRampToValueAtTime(t.z, s),
                    n.forwardX.linearRampToValueAtTime(a.x, s),
                    n.forwardY.linearRampToValueAtTime(a.y, s),
                    n.forwardZ.linearRampToValueAtTime(a.z, s),
                    n.upX.linearRampToValueAtTime(r.x, s),
                    n.upY.linearRampToValueAtTime(r.y, s),
                    n.upZ.linearRampToValueAtTime(r.z, s)
                } else
                    n.setPosition(t.x, t.y, t.z),
                    n.setOrientation(a.x, a.y, a.z, r.x, r.y, r.z)
            }
        }()
    }),
    $n.prototype = Object.assign(Object.create(T.prototype), {
        constructor: $n,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = t,
            this.connect(),
            this
        },
        setMediaElementSource: function(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(t),
            this.connect(),
            this
        },
        setBuffer: function(t) {
            return this.buffer = t,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        },
        play: function() {
            if (!0 === this.isPlaying)
                ;
            else if (!1 !== this.hasPlaybackControl) {
                var t = this.context.createBufferSource();
                return t.buffer = this.buffer,
                t.loop = this.loop,
                t.onended = this.onEnded.bind(this),
                this.startTime = this.context.currentTime,
                t.start(this.startTime, this.offset),
                this.isPlaying = !0,
                this.source = t,
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            }
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this.source.stop(),
                this.source.onended = null,
                this.offset += (this.context.currentTime - this.startTime) * this.playbackRate,
                this.isPlaying = !1),
                this
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl)
                return this.source.stop(),
                this.source.onended = null,
                this.offset = 0,
                this.isPlaying = !1,
                this
        },
        connect: function() {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(t) {
            return t || (t = []),
            !0 === this.isPlaying ? (this.disconnect(),
            this.filters = t,
            this.connect()) : this.filters = t,
            this
        },
        setDetune: function(t) {
            if (this.detune = t,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(t) {
            return this.setFilters(t ? [t] : [])
        },
        setPlaybackRate: function(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = t,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 !== this.hasPlaybackControl && this.loop
        },
        setLoop: function(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = t,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
            this
        }
    }),
    tr.prototype = Object.assign(Object.create($n.prototype), {
        constructor: tr,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(t) {
            return this.panner.refDistance = t,
            this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(t) {
            return this.panner.rolloffFactor = t,
            this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(t) {
            return this.panner.distanceModel = t,
            this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(t) {
            return this.panner.maxDistance = t,
            this
        },
        setDirectionalCone: function(t, e, i) {
            return this.panner.coneInnerAngle = t,
            this.panner.coneOuterAngle = e,
            this.panner.coneOuterGain = i,
            this
        },
        updateMatrixWorld: function() {
            var t = new r
              , e = new n
              , i = new r
              , a = new r;
            return function(n) {
                if (T.prototype.updateMatrixWorld.call(this, n),
                !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
                    if (this.matrixWorld.decompose(t, e, i),
                    a.set(0, 0, 1).applyQuaternion(e),
                    (n = this.panner).positionX) {
                        var r = this.context.currentTime + this.listener.timeDelta;
                        n.positionX.linearRampToValueAtTime(t.x, r),
                        n.positionY.linearRampToValueAtTime(t.y, r),
                        n.positionZ.linearRampToValueAtTime(t.z, r),
                        n.orientationX.linearRampToValueAtTime(a.x, r),
                        n.orientationY.linearRampToValueAtTime(a.y, r),
                        n.orientationZ.linearRampToValueAtTime(a.z, r)
                    } else
                        n.setPosition(t.x, t.y, t.z),
                        n.setOrientation(a.x, a.y, a.z)
            }
        }()
    }),
    Object.assign(er.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        },
        getAverageFrequency: function() {
            for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++)
                t += e[i];
            return t / e.length
        }
    }),
    Object.assign(ir.prototype, {
        accumulate: function(t, e) {
            var i = this.buffer
              , n = this.valueSize;
            t = t * n + n;
            var r = this.cumulativeWeight;
            if (0 === r) {
                for (r = 0; r !== n; ++r)
                    i[t + r] = i[r];
                r = e
            } else
                r += e,
                this._mixBufferRegion(i, t, 0, e / r, n);
            this.cumulativeWeight = r
        },
        apply: function(t) {
            var e = this.valueSize
              , i = this.buffer;
            t = t * e + e;
            var n = this.cumulativeWeight
              , r = this.binding;
            this.cumulativeWeight = 0,
            1 > n && this._mixBufferRegion(i, t, 3 * e, 1 - n, e),
            n = e;
            for (var a = e + e; n !== a; ++n)
                if (i[n] !== i[n + e]) {
                    r.setValue(i, t);
                    break
                }
        },
        saveOriginalState: function() {
            var t = this.buffer
              , e = this.valueSize
              , i = 3 * e;
            this.binding.getValue(t, i);
            for (var n = e; n !== i; ++n)
                t[n] = t[i + n % e];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        },
        _select: function(t, e, i, n, r) {
            if (.5 <= n)
                for (n = 0; n !== r; ++n)
                    t[e + n] = t[i + n]
        },
        _slerp: function(t, e, i, r) {
            n.slerpFlat(t, e, t, e, t, i, r)
        },
        _lerp: function(t, e, i, n, r) {
            for (var a = 1 - n, o = 0; o !== r; ++o) {
                var s = e + o;
                t[s] = t[s] * a + t[i + o] * n
            }
        }
    }),
    Object.assign(nr.prototype, {
        getValue: function(t, e) {
            this.bind();
            var i = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== i && i.getValue(t, e)
        },
        setValue: function(t, e) {
            for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
                i[n].setValue(t, e)
        },
        bind: function() {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
                t[e].bind()
        },
        unbind: function() {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
                t[e].unbind()
        }
    }),
    Object.assign(rr, {
        Composite: nr,
        create: function(t, e, i) {
            return t && t.isAnimationObjectGroup ? new rr.Composite(t,e,i) : new rr(t,e,i)
        },
        sanitizeNodeName: function() {
            var t = /[\[\]\.:\/]/g;
            return function(e) {
                return e.replace(/\s/g, "_").replace(t, "")
            }
        }(),
        parseTrackName: function() {
            var t = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]"
              , e = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
            t = /(WCOD+)?/.source.replace("WCOD", t);
            var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]")
              , n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]")
              , r = new RegExp("^" + e + t + i + n + "$")
              , a = ["material", "materials", "bones"];
            return function(t) {
                var e = r.exec(t);
                if (!e)
                    throw Error("PropertyBinding: Cannot parse trackName: " + t);
                var i = (e = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }).nodeName && e.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    var n = e.nodeName.substring(i + 1);
                    -1 !== a.indexOf(n) && (e.nodeName = e.nodeName.substring(0, i),
                    e.objectName = n)
                }
                if (null === e.propertyName || 0 === e.propertyName.length)
                    throw Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return e
            }
        }(),
        findNode: function(t, e) {
            if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                return t;
            if (t.skeleton) {
                var i = t.skeleton.getBoneByName(e);
                if (void 0 !== i)
                    return i
            }
            if (t.children) {
                var n = function(t) {
                    for (var i = 0; i < t.length; i++) {
                        var r = t[i];
                        if (r.name === e || r.uuid === e || (r = n(r.children)))
                            return r
                    }
                    return null
                };
                if (t = n(t.children))
                    return t
            }
            return null
        }
    }),
    Object.assign(rr.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(t, e) {
            t[e] = this.node[this.propertyName]
        }
        , function(t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                t[e++] = i[n]
        }
        , function(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }
        , function(t, e) {
            this.resolvedProperty.toArray(t, e)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(t, e) {
            this.targetObject[this.propertyName] = t[e]
        }
        , function(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                i[n] = t[e++]
        }
        , function(t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                i[n] = t[e++];
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                i[n] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e]
        }
        , function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            this.resolvedProperty.fromArray(t, e)
        }
        , function(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(t, e) {
            this.bind(),
            this.getValue(t, e)
        },
        setValue: function(t, e) {
            this.bind(),
            this.setValue(t, e)
        },
        bind: function() {
            var t = this.node
              , e = this.parsedPath
              , i = e.objectName
              , n = e.propertyName
              , r = e.propertyIndex;
            if (t || (this.node = t = rr.findNode(this.rootNode, e.nodeName) || this.rootNode),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            t) {
                if (i) {
                    var a = e.objectIndex;
                    switch (i) {
                    case "materials":
                        if (!t.material)
                            return;
                        if (!t.material.materials)
                            return;
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return;
                        for (t = t.skeleton.bones,
                        i = 0; i < t.length; i++)
                            if (t[i].name === a) {
                                a = i;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[i])
                            return;
                        t = t[i]
                    }
                    if (void 0 !== a) {
                        if (void 0 === t[a])
                            return;
                        t = t[a]
                    }
                }
                if (void 0 === (a = t[n]))
                    ;
                else {
                    if (e = this.Versioning.None,
                    this.targetObject = t,
                    void 0 !== t.needsUpdate ? e = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (e = this.Versioning.MatrixWorldNeedsUpdate),
                    i = this.BindingType.Direct,
                    void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!t.geometry)
                                return;
                            if (t.geometry.isBufferGeometry) {
                                if (!t.geometry.morphAttributes)
                                    return;
                                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                                    if (t.geometry.morphAttributes.position[i].name === r) {
                                        r = i;
                                        break
                                    }
                            } else {
                                if (!t.geometry.morphTargets)
                                    return;
                                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                                    if (t.geometry.morphTargets[i].name === r) {
                                        r = i;
                                        break
                                    }
                            }
                        }
                        i = this.BindingType.ArrayElement,
                        this.resolvedProperty = a,
                        this.propertyIndex = r
                    } else
                        void 0 !== a.fromArray && void 0 !== a.toArray ? (i = this.BindingType.HasFromToArray,
                        this.resolvedProperty = a) : Array.isArray(a) ? (i = this.BindingType.EntireArray,
                        this.resolvedProperty = a) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[i],
                    this.setValue = this.SetterByBindingTypeAndVersioning[i][e]
                }
            }
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    Object.assign(rr.prototype, {
        _getValue_unbound: rr.prototype.getValue,
        _setValue_unbound: rr.prototype.setValue
    }),
    Object.assign(ar.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, c = 0, h = arguments.length; c !== h; ++c) {
                var l = arguments[c]
                  , u = l.uuid
                  , p = n[u];
                if (void 0 === p) {
                    p = e++,
                    n[u] = p,
                    t.push(l),
                    u = 0;
                    for (var d = s; u !== d; ++u)
                        o[u].push(new rr(l,r[u],a[u]))
                } else if (p < i) {
                    t[p];
                    var f = --i;
                    for (n[(d = t[f]).uuid] = p,
                    t[p] = d,
                    n[u] = f,
                    t[f] = l,
                    u = 0,
                    d = s; u !== d; ++u) {
                        var m = o[u]
                          , g = m[p];
                        m[p] = m[f],
                        void 0 === g && (g = new rr(l,r[u],a[u])),
                        m[f] = g
                    }
                } else
                    t[p]
            }
            this.nCachedObjects_ = i
        },
        remove: function() {
            for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, a = 0, o = arguments.length; a !== o; ++a) {
                var s = arguments[a]
                  , c = s.uuid
                  , h = i[c];
                if (void 0 !== h && h >= e) {
                    var l = e++
                      , u = t[l];
                    for (i[u.uuid] = h,
                    t[h] = u,
                    i[c] = l,
                    t[l] = s,
                    s = 0,
                    c = r; s !== c; ++s) {
                        var p = (u = n[s])[h];
                        u[h] = u[l],
                        u[l] = p
                    }
                }
            }
            this.nCachedObjects_ = e
        },
        uncache: function() {
            for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                var c = arguments[o].uuid
                  , h = n[c];
                if (void 0 !== h)
                    if (delete n[c],
                    h < i) {
                        var l = t[c = --i]
                          , u = --e
                          , p = t[u];
                        for (n[l.uuid] = h,
                        t[h] = l,
                        n[p.uuid] = c,
                        t[c] = p,
                        t.pop(),
                        l = 0,
                        p = a; l !== p; ++l) {
                            var d = r[l]
                              , f = d[u];
                            d[h] = d[c],
                            d[c] = f,
                            d.pop()
                        }
                    } else
                        for (n[(p = t[u = --e]).uuid] = h,
                        t[h] = p,
                        t.pop(),
                        l = 0,
                        p = a; l !== p; ++l)
                            (d = r[l])[h] = d[u],
                            d.pop()
            }
            this.nCachedObjects_ = i
        },
        subscribe_: function(t, e) {
            var i = this._bindingsIndicesByPath
              , n = i[t]
              , r = this._bindings;
            if (void 0 !== n)
                return r[n];
            var a = this._paths
              , o = this._parsedPaths
              , s = this._objects
              , c = this.nCachedObjects_
              , h = Array(s.length);
            for (n = r.length,
            i[t] = n,
            a.push(t),
            o.push(e),
            r.push(h),
            i = c,
            n = s.length; i !== n; ++i)
                h[i] = new rr(s[i],t,e);
            return h
        },
        unsubscribe_: function(t) {
            var e = this._bindingsIndicesByPath
              , i = e[t];
            if (void 0 !== i) {
                var n = this._paths
                  , r = this._parsedPaths
                  , a = this._bindings
                  , o = a.length - 1
                  , s = a[o];
                e[t[o]] = i,
                a[i] = s,
                a.pop(),
                r[i] = r[o],
                r.pop(),
                n[i] = n[o],
                n.pop()
            }
        }
    }),
    Object.assign(or.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(t) {
            return this._startTime = t,
            this
        },
        setLoop: function(t, e) {
            return this.loop = t,
            this.repetitions = e,
            this
        },
        setEffectiveWeight: function(t) {
            return this.weight = t,
            this._effectiveWeight = this.enabled ? t : 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(t) {
            return this._scheduleFading(t, 0, 1)
        },
        fadeOut: function(t) {
            return this._scheduleFading(t, 1, 0)
        },
        crossFadeFrom: function(t, e, i) {
            if (t.fadeOut(e),
            this.fadeIn(e),
            i) {
                i = this._clip.duration;
                var n = t._clip.duration
                  , r = i / n;
                t.warp(1, n / i, e),
                this.warp(r, 1, e)
            }
            return this
        },
        crossFadeTo: function(t, e, i) {
            return t.crossFadeFrom(this, e, i)
        },
        stopFading: function() {
            var t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        },
        setEffectiveTimeScale: function(t) {
            return this.timeScale = t,
            this._effectiveTimeScale = this.paused ? 0 : t,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(t) {
            return this.timeScale = this._clip.duration / t,
            this.stopWarping()
        },
        syncWith: function(t) {
            return this.time = t.time,
            this.timeScale = t.timeScale,
            this.stopWarping()
        },
        halt: function(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        },
        warp: function(t, e, i) {
            var n = this._mixer
              , r = n.time
              , a = this._timeScaleInterpolant
              , o = this.timeScale;
            return null === a && (this._timeScaleInterpolant = a = n._lendControlInterpolant()),
            n = a.parameterPositions,
            a = a.sampleValues,
            n[0] = r,
            n[1] = r + i,
            a[0] = t / o,
            a[1] = e / o,
            this
        },
        stopWarping: function() {
            var t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(t, e, i, n) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    if (0 > (e = (t - r) * i) || 0 === i)
                        return;
                    this._startTime = null,
                    e *= i
                }
                if (e *= this._updateTimeScale(t),
                i = this._updateTime(e),
                0 < (t = this._updateWeight(t))) {
                    e = this._interpolants,
                    r = this._propertyBindings;
                    for (var a = 0, o = e.length; a !== o; ++a)
                        e[a].evaluate(i),
                        r[a].accumulate(n, t)
                }
            } else
                this._updateWeight(t)
        },
        _updateWeight: function(t) {
            var e = 0;
            if (this.enabled) {
                e = this.weight;
                var i = this._weightInterpolant;
                if (null !== i) {
                    var n = i.evaluate(t)[0];
                    e *= n,
                    t > i.parameterPositions[1] && (this.stopFading(),
                    0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = e
        },
        _updateTimeScale: function(t) {
            var e = 0;
            if (!this.paused) {
                e = this.timeScale;
                var i = this._timeScaleInterpolant;
                if (null !== i)
                    e *= i.evaluate(t)[0],
                    t > i.parameterPositions[1] && (this.stopWarping(),
                    0 === e ? this.paused = !0 : this.timeScale = e)
            }
            return this._effectiveTimeScale = e
        },
        _updateTime: function(t) {
            var e = this.time + t
              , i = this._clip.duration
              , n = this.loop
              , r = this._loopCount
              , a = 2202 === n;
            if (0 === t)
                return -1 === r ? e : a && 1 == (1 & r) ? i - e : e;
            if (2200 === n)
                t: {
                    if (-1 === r && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1)),
                    e >= i)
                        e = i;
                    else {
                        if (!(0 > e))
                            break t;
                        e = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 > t ? -1 : 1
                    })
                }
            else {
                if (-1 === r && (0 <= t ? (r = 0,
                this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)),
                e >= i || 0 > e) {
                    e -= i * (n = Math.floor(e / i)),
                    r += Math.abs(n);
                    var o = this.repetitions - r;
                    0 >= o ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    e = 0 < t ? i : 0,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 < t ? 1 : -1
                    })) : (1 === o ? (t = 0 > t,
                    this._setEndings(t, !t, a)) : this._setEndings(!1, !1, a),
                    this._loopCount = r,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: n
                    }))
                }
                if (a && 1 == (1 & r))
                    return this.time = e,
                    i - e
            }
            return this.time = e
        },
        _setEndings: function(t, e, i) {
            var n = this._interpolantSettings;
            i ? (n.endingStart = 2401,
            n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402,
            n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function(t, e, i) {
            var n = this._mixer
              , r = n.time
              , a = this._weightInterpolant;
            return null === a && (this._weightInterpolant = a = n._lendControlInterpolant()),
            n = a.parameterPositions,
            a = a.sampleValues,
            n[0] = r,
            a[0] = e,
            n[1] = r + t,
            a[1] = i,
            this
        }
    }),
    sr.prototype = Object.assign(Object.create(e.prototype), {
        constructor: sr,
        _bindAction: function(t, e) {
            var i = t._localRoot || this._root
              , n = t._clip.tracks
              , r = n.length
              , a = t._propertyBindings;
            t = t._interpolants;
            var o = i.uuid
              , s = this._bindingsByRootAndName
              , c = s[o];
            for (void 0 === c && (c = {},
            s[o] = c),
            s = 0; s !== r; ++s) {
                var h = n[s]
                  , l = h.name
                  , u = c[l];
                if (void 0 === u) {
                    if (void 0 !== (u = a[s])) {
                        null === u._cacheIndex && (++u.referenceCount,
                        this._addInactiveBinding(u, o, l));
                        continue
                    }
                    ++(u = new ir(rr.create(i, l, e && e._propertyBindings[s].binding.parsedPath),h.ValueTypeName,h.getValueSize())).referenceCount,
                    this._addInactiveBinding(u, o, l)
                }
                a[s] = u,
                t[s].resultBuffer = u.buffer
            }
        },
        _activateAction: function(t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    var e = (t._localRoot || this._root).uuid
                      , i = t._clip.uuid
                      , n = this._actionsByClip[i];
                    this._bindAction(t, n && n.knownActions[0]),
                    this._addInactiveAction(t, i, e)
                }
                for (i = 0,
                n = (e = t._propertyBindings).length; i !== n; ++i) {
                    var r = e[i];
                    0 == r.useCount++ && (this._lendBinding(r),
                    r.saveOriginalState())
                }
                this._lendAction(t)
            }
        },
        _deactivateAction: function(t) {
            if (this._isActiveAction(t)) {
                for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                    var r = e[i];
                    0 == --r.useCount && (r.restoreOriginalState(),
                    this._takeBackBinding(r))
                }
                this._takeBackAction(t)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(t) {
            return null !== (t = t._cacheIndex) && t < this._nActiveActions
        },
        _addInactiveAction: function(t, e, i) {
            var n = this._actions
              , r = this._actionsByClip
              , a = r[e];
            void 0 === a ? (a = {
                knownActions: [t],
                actionByRoot: {}
            },
            t._byClipCacheIndex = 0,
            r[e] = a) : (e = a.knownActions,
            t._byClipCacheIndex = e.length,
            e.push(t)),
            t._cacheIndex = n.length,
            n.push(t),
            a.actionByRoot[i] = t
        },
        _removeInactiveAction: function(t) {
            var e = this._actions
              , i = e[e.length - 1]
              , n = t._cacheIndex;
            i._cacheIndex = n,
            e[n] = i,
            e.pop(),
            t._cacheIndex = null,
            e = t._clip.uuid;
            var r = (n = (i = this._actionsByClip)[e]).knownActions
              , a = r[r.length - 1]
              , o = t._byClipCacheIndex;
            a._byClipCacheIndex = o,
            r[o] = a,
            r.pop(),
            t._byClipCacheIndex = null,
            delete n.actionByRoot[(t._localRoot || this._root).uuid],
            0 === r.length && delete i[e],
            this._removeInactiveBindingsForAction(t)
        },
        _removeInactiveBindingsForAction: function(t) {
            for (var e = 0, i = (t = t._propertyBindings).length; e !== i; ++e) {
                var n = t[e];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        },
        _lendAction: function(t) {
            var e = this._actions
              , i = t._cacheIndex
              , n = this._nActiveActions++
              , r = e[n];
            t._cacheIndex = n,
            e[n] = t,
            r._cacheIndex = i,
            e[i] = r
        },
        _takeBackAction: function(t) {
            var e = this._actions
              , i = t._cacheIndex
              , n = --this._nActiveActions
              , r = e[n];
            t._cacheIndex = n,
            e[n] = t,
            r._cacheIndex = i,
            e[i] = r
        },
        _addInactiveBinding: function(t, e, i) {
            var n = this._bindingsByRootAndName
              , r = n[e]
              , a = this._bindings;
            void 0 === r && (r = {},
            n[e] = r),
            r[i] = t,
            t._cacheIndex = a.length,
            a.push(t)
        },
        _removeInactiveBinding: function(t) {
            var e = this._bindings
              , i = t.binding
              , n = i.rootNode.uuid;
            i = i.path;
            var r = this._bindingsByRootAndName
              , a = r[n]
              , o = e[e.length - 1];
            t = t._cacheIndex,
            o._cacheIndex = t,
            e[t] = o,
            e.pop(),
            delete a[i];
            t: {
                for (var s in a)
                    break t;
                delete r[n]
            }
        },
        _lendBinding: function(t) {
            var e = this._bindings
              , i = t._cacheIndex
              , n = this._nActiveBindings++
              , r = e[n];
            t._cacheIndex = n,
            e[n] = t,
            r._cacheIndex = i,
            e[i] = r
        },
        _takeBackBinding: function(t) {
            var e = this._bindings
              , i = t._cacheIndex
              , n = --this._nActiveBindings
              , r = e[n];
            t._cacheIndex = n,
            e[n] = t,
            r._cacheIndex = i,
            e[i] = r
        },
        _lendControlInterpolant: function() {
            var t = this._controlInterpolants
              , e = this._nActiveControlInterpolants++
              , i = t[e];
            return void 0 === i && ((i = new Hi(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex = e,
            t[e] = i),
            i
        },
        _takeBackControlInterpolant: function(t) {
            var e = this._controlInterpolants
              , i = t.__cacheIndex
              , n = --this._nActiveControlInterpolants
              , r = e[n];
            t.__cacheIndex = n,
            e[n] = t,
            r.__cacheIndex = i,
            e[i] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(t, e) {
            var i = e || this._root
              , n = i.uuid;
            t = null !== (i = "string" == typeof t ? tn.findByName(i, t) : t) ? i.uuid : t;
            var r = this._actionsByClip[t]
              , a = null;
            if (void 0 !== r) {
                if (void 0 !== (a = r.actionByRoot[n]))
                    return a;
                a = r.knownActions[0],
                null === i && (i = a._clip)
            }
            return null === i ? null : (e = new or(this,i,e),
            this._bindAction(e, a),
            this._addInactiveAction(e, t, n),
            e)
        },
        existingAction: function(t, e) {
            var i = e || this._root;
            return e = i.uuid,
            i = "string" == typeof t ? tn.findByName(i, t) : t,
            void 0 !== (t = this._actionsByClip[i ? i.uuid : t]) && t.actionByRoot[e] || null
        },
        stopAllAction: function() {
            for (var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== e; ++r)
                t[r].reset();
            for (r = 0; r !== n; ++r)
                i[r].useCount = 0;
            return this
        },
        update: function(t) {
            t *= this.timeScale;
            for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== i; ++o)
                e[o]._update(n, t, r, a);
            for (t = this._bindings,
            e = this._nActiveBindings,
            o = 0; o !== e; ++o)
                t[o].apply(a);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(t) {
            var e = this._actions;
            t = t.uuid;
            var i = this._actionsByClip
              , n = i[t];
            if (void 0 !== n) {
                for (var r = 0, a = (n = n.knownActions).length; r !== a; ++r) {
                    var o = n[r];
                    this._deactivateAction(o);
                    var s = o._cacheIndex
                      , c = e[e.length - 1];
                    o._cacheIndex = null,
                    o._byClipCacheIndex = null,
                    c._cacheIndex = s,
                    e[s] = c,
                    e.pop(),
                    this._removeInactiveBindingsForAction(o)
                }
                delete i[t]
            }
        },
        uncacheRoot: function(t) {
            t = t.uuid;
            var e = this._actionsByClip;
            for (n in e) {
                var i = e[n].actionByRoot[t];
                void 0 !== i && (this._deactivateAction(i),
                this._removeInactiveAction(i))
            }
            var n = this._bindingsByRootAndName[t];
            if (void 0 !== n)
                for (var r in n)
                    (t = n[r]).restoreOriginalState(),
                    this._removeInactiveBinding(t)
        },
        uncacheAction: function(t, e) {
            null !== (t = this.existingAction(t, e)) && (this._deactivateAction(t),
            this._removeInactiveAction(t))
        }
    }),
    cr.prototype.clone = function() {
        return new cr(void 0 === this.value.clone ? this.value : this.value.clone())
    }
    ,
    hr.prototype = Object.assign(Object.create(U.prototype), {
        constructor: hr,
        isInstancedBufferGeometry: !0,
        copy: function(t) {
            return U.prototype.copy.call(this, t),
            this.maxInstancedCount = t.maxInstancedCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    lr.prototype = Object.assign(Object.create(ue.prototype), {
        constructor: lr,
        isInstancedInterleavedBuffer: !0,
        copy: function(t) {
            return ue.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
    }),
    ur.prototype = Object.assign(Object.create(A.prototype), {
        constructor: ur,
        isInstancedBufferAttribute: !0,
        copy: function(t) {
            return A.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
    }),
    Object.assign(pr.prototype, {
        linePrecision: 1,
        set: function(t, e) {
            this.ray.set(t, e)
        },
        setFromCamera: function(t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera && (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
            this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld))
        },
        intersectObject: function(t, e, i) {
            return fr(t, this, i = i || [], e),
            i.sort(dr),
            i
        },
        intersectObjects: function(t, e, i) {
            if (i = i || [],
            !1 === Array.isArray(t))
                return i;
            for (var n = 0, r = t.length; n < r; n++)
                fr(t[n], this, i, e);
            return i.sort(dr),
            i
        }
    }),
    Object.assign(mr.prototype, {
        set: function(t, e, i) {
            return this.radius = t,
            this.phi = e,
            this.theta = i,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius,
            this.phi = t.phi,
            this.theta = t.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        },
        setFromCartesianCoords: function(t, e, i) {
            return this.radius = Math.sqrt(t * t + e * e + i * i),
            0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t, i),
            this.phi = Math.acos(Vr.clamp(e / this.radius, -1, 1))),
            this
        }
    }),
    Object.assign(gr.prototype, {
        set: function(t, e, i) {
            return this.radius = t,
            this.theta = e,
            this.y = i,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius,
            this.theta = t.theta,
            this.y = t.y,
            this
        },
        setFromVector3: function(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        },
        setFromCartesianCoords: function(t, e, i) {
            return this.radius = Math.sqrt(t * t + i * i),
            this.theta = Math.atan2(t, i),
            this.y = e,
            this
        }
    }),
    Object.assign(vr.prototype, {
        set: function(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, i = t.length; e < i; e++)
                this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new i;
            return function(e, i) {
                return i = t.copy(i).multiplyScalar(.5),
                this.min.copy(e).sub(i),
                this.max.copy(e).add(i),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(t) {
            return void 0 === t && (t = new i),
            this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (t = new i),
            this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        },
        expandByVector: function(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        },
        getParameter: function(t, e) {
            return void 0 === e && (e = new i),
            e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        },
        clampPoint: function(t, e) {
            return void 0 === e && (e = new i),
            e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new i;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this
        },
        union: function(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        },
        translate: function(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }),
    Object.assign(yr.prototype, {
        set: function(t, e) {
            return this.start.copy(t),
            this.end.copy(e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.start.copy(t.start),
            this.end.copy(t.end),
            this
        },
        getCenter: function(t) {
            return void 0 === t && (t = new r),
            t.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(t) {
            return void 0 === t && (t = new r),
            t.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(t, e) {
            return void 0 === e && (e = new r),
            this.delta(e).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: function() {
            var t = new r
              , e = new r;
            return function(i, n) {
                return t.subVectors(i, this.start),
                e.subVectors(this.end, this.start),
                i = e.dot(e),
                i = e.dot(t) / i,
                n && (i = Vr.clamp(i, 0, 1)),
                i
            }
        }(),
        closestPointToPoint: function(t, e, i) {
            return t = this.closestPointToPointParameter(t, e),
            void 0 === i && (i = new r),
            this.delta(i).multiplyScalar(t).add(this.start)
        },
        applyMatrix4: function(t) {
            return this.start.applyMatrix4(t),
            this.end.applyMatrix4(t),
            this
        },
        equals: function(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }),
    xr.prototype = Object.create(T.prototype),
    xr.prototype.constructor = xr,
    xr.prototype.isImmediateRenderObject = !0,
    br.prototype = Object.create(we.prototype),
    br.prototype.constructor = br,
    br.prototype.update = function() {
        var t = new r
          , e = new r
          , i = new a;
        return function() {
            var n = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0),
            i.getNormalMatrix(this.object.matrixWorld);
            var r = this.object.matrixWorld
              , a = this.geometry.attributes.position
              , o = this.object.geometry;
            if (o && o.isGeometry)
                for (var s = o.vertices, c = o.faces, h = o = 0, l = c.length; h < l; h++)
                    for (var u = c[h], p = 0, d = u.vertexNormals.length; p < d; p++) {
                        var f = u.vertexNormals[p];
                        t.copy(s[u[n[p]]]).applyMatrix4(r),
                        e.copy(f).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t),
                        a.setXYZ(o, t.x, t.y, t.z),
                        o += 1,
                        a.setXYZ(o, e.x, e.y, e.z),
                        o += 1
                    }
            else if (o && o.isBufferGeometry)
                for (n = o.attributes.position,
                s = o.attributes.normal,
                p = o = 0,
                d = n.count; p < d; p++)
                    t.set(n.getX(p), n.getY(p), n.getZ(p)).applyMatrix4(r),
                    e.set(s.getX(p), s.getY(p), s.getZ(p)),
                    e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t),
                    a.setXYZ(o, t.x, t.y, t.z),
                    o += 1,
                    a.setXYZ(o, e.x, e.y, e.z),
                    o += 1;
            a.needsUpdate = !0
        }
    }(),
    wr.prototype = Object.create(T.prototype),
    wr.prototype.constructor = wr,
    wr.prototype.dispose = function() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    ,
    wr.prototype.update = function() {
        var t = new r;
        return function() {
            this.light.updateMatrixWorld();
            var e = this.light.distance ? this.light.distance : 1e3
              , i = e * Math.tan(this.light.angle);
            this.cone.scale.set(i, i, e),
            t.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(t),
            void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }(),
    Mr.prototype = Object.create(we.prototype),
    Mr.prototype.constructor = Mr,
    Mr.prototype.updateMatrixWorld = function() {
        var t = new r
          , e = new g
          , i = new g;
        return function(n) {
            var r = this.bones
              , a = this.geometry
              , o = a.getAttribute("position");
            i.getInverse(this.root.matrixWorld);
            for (var s = 0, c = 0; s < r.length; s++) {
                var h = r[s];
                h.parent && h.parent.isBone && (e.multiplyMatrices(i, h.matrixWorld),
                t.setFromMatrixPosition(e),
                o.setXYZ(c, t.x, t.y, t.z),
                e.multiplyMatrices(i, h.parent.matrixWorld),
                t.setFromMatrixPosition(e),
                o.setXYZ(c + 1, t.x, t.y, t.z),
                c += 2)
            }
            a.getAttribute("position").needsUpdate = !0,
            T.prototype.updateMatrixWorld.call(this, n)
        }
    }(),
    _r.prototype = Object.create(J.prototype),
    _r.prototype.constructor = _r,
    _r.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    _r.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
    ,
    Sr.prototype = Object.create(be.prototype),
    Sr.prototype.constructor = Sr,
    Sr.prototype.update = function() {
        if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1),
        void 0 !== this.color)
            this.material.color.set(this.color),
            this.children[0].material.color.set(this.color);
        else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var t = this.material.color
              , e = Math.max(t.r, t.g, t.b);
            1 < e && t.multiplyScalar(1 / e),
            this.children[0].material.color.copy(this.material.color)
        }
    }
    ,
    Sr.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Tr.prototype = Object.create(T.prototype),
    Tr.prototype.constructor = Tr,
    Tr.prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Tr.prototype.update = function() {
        var t = new r
          , e = new x
          , i = new x;
        return function() {
            var n = this.children[0];
            if (void 0 !== this.color)
                this.material.color.set(this.color);
            else {
                var r = n.geometry.getAttribute("color");
                e.copy(this.light.color),
                i.copy(this.light.groundColor);
                for (var a = 0, o = r.count; a < o; a++) {
                    var s = a < o / 2 ? e : i;
                    r.setXYZ(a, s.r, s.g, s.b)
                }
                r.needsUpdate = !0
            }
            n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }(),
    Er.prototype = Object.assign(Object.create(we.prototype), {
        constructor: Er,
        copy: function(t) {
            return we.prototype.copy.call(this, t),
            this.geometry.copy(t.geometry),
            this.material.copy(t.material),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    Ar.prototype = Object.create(we.prototype),
    Ar.prototype.constructor = Ar,
    Lr.prototype = Object.create(be.prototype),
    Lr.prototype.constructor = Lr,
    Lr.prototype.update = function() {
        function t(t, n, a, o) {
            for (a = (n - t) / a,
            d.setXYZ(l, 0, 0, 0),
            u++,
            e = t; e < n; e += a)
                i = l + u,
                d.setXYZ(i, Math.sin(e) * r, 0, Math.cos(e) * r),
                d.setXYZ(i + 1, Math.sin(Math.min(e + a, n)) * r, 0, Math.cos(Math.min(e + a, n)) * r),
                d.setXYZ(i + 2, 0, 0, 0),
                u += 3;
            p.addGroup(l, u, o),
            l += u,
            u = 0
        }
        var e, i, n = this.audio, r = this.range, a = this.divisionsInnerAngle, o = this.divisionsOuterAngle, s = Vr.degToRad(n.panner.coneInnerAngle), c = s / 2, h = (n = Vr.degToRad(n.panner.coneOuterAngle)) / 2, l = 0, u = 0, p = this.geometry, d = p.attributes.position;
        p.clearGroups(),
        t(-h, -c, o, 0),
        t(-c, c, a, 1),
        t(c, h, o, 0),
        d.needsUpdate = !0,
        s === n && (this.material[0].visible = !1)
    }
    ,
    Lr.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material[0].dispose(),
        this.material[1].dispose()
    }
    ,
    Pr.prototype = Object.create(we.prototype),
    Pr.prototype.constructor = Pr,
    Pr.prototype.update = function() {
        var t = new r
          , e = new r
          , i = new a;
        return function() {
            this.object.updateMatrixWorld(!0),
            i.getNormalMatrix(this.object.matrixWorld);
            for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry, o = a.vertices, s = 0, c = 0, h = (a = a.faces).length; c < h; c++) {
                var l = a[c]
                  , u = l.normal;
                t.copy(o[l.a]).add(o[l.b]).add(o[l.c]).divideScalar(3).applyMatrix4(n),
                e.copy(u).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t),
                r.setXYZ(s, t.x, t.y, t.z),
                s += 1,
                r.setXYZ(s, e.x, e.y, e.z),
                s += 1
            }
            r.needsUpdate = !0
        }
    }(),
    Cr.prototype = Object.create(T.prototype),
    Cr.prototype.constructor = Cr,
    Cr.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    ,
    Cr.prototype.update = function() {
        var t = new r
          , e = new r
          , i = new r;
        return function() {
            t.setFromMatrixPosition(this.light.matrixWorld),
            e.setFromMatrixPosition(this.light.target.matrixWorld),
            i.subVectors(e, t),
            this.lightPlane.lookAt(e),
            void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
            this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(e),
            this.targetLine.scale.z = i.length()
        }
    }(),
    Ir.prototype = Object.create(we.prototype),
    Ir.prototype.constructor = Ir,
    Ir.prototype.update = function() {
        function t(t, r, o, s) {
            if (n.set(r, o, s).unproject(a),
            void 0 !== (t = i[t]))
                for (r = e.getAttribute("position"),
                o = 0,
                s = t.length; o < s; o++)
                    r.setXYZ(t[o], n.x, n.y, n.z)
        }
        var e, i, n = new r, a = new ee;
        return function() {
            e = this.geometry,
            i = this.pointMap,
            a.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            t("c", 0, 0, -1),
            t("t", 0, 0, 1),
            t("n1", -1, -1, -1),
            t("n2", 1, -1, -1),
            t("n3", -1, 1, -1),
            t("n4", 1, 1, -1),
            t("f1", -1, -1, 1),
            t("f2", 1, -1, 1),
            t("f3", -1, 1, 1),
            t("f4", 1, 1, 1),
            t("u1", .7, 1.1, -1),
            t("u2", -.7, 1.1, -1),
            t("u3", 0, 2, -1),
            t("cf1", -1, 0, 1),
            t("cf2", 1, 0, 1),
            t("cf3", 0, -1, 1),
            t("cf4", 0, 1, 1),
            t("cn1", -1, 0, -1),
            t("cn2", 1, 0, -1),
            t("cn3", 0, -1, -1),
            t("cn4", 0, 1, -1),
            e.getAttribute("position").needsUpdate = !0
        }
    }(),
    Rr.prototype = Object.create(we.prototype),
    Rr.prototype.constructor = Rr,
    Rr.prototype.update = function() {
        var t = new p;
        return function(e) {
            if (void 0 !== this.object && t.setFromObject(this.object),
            !t.isEmpty()) {
                e = t.min;
                var i = t.max
                  , n = this.geometry.attributes.position
                  , r = n.array;
                r[0] = i.x,
                r[1] = i.y,
                r[2] = i.z,
                r[3] = e.x,
                r[4] = i.y,
                r[5] = i.z,
                r[6] = e.x,
                r[7] = e.y,
                r[8] = i.z,
                r[9] = i.x,
                r[10] = e.y,
                r[11] = i.z,
                r[12] = i.x,
                r[13] = i.y,
                r[14] = e.z,
                r[15] = e.x,
                r[16] = i.y,
                r[17] = e.z,
                r[18] = e.x,
                r[19] = e.y,
                r[20] = e.z,
                r[21] = i.x,
                r[22] = e.y,
                r[23] = e.z,
                n.needsUpdate = !0,
                this.geometry.computeBoundingSphere()
            }
        }
    }(),
    Rr.prototype.setFromObject = function(t) {
        return this.object = t,
        this.update(),
        this
    }
    ,
    Rr.prototype.copy = function(t) {
        return we.prototype.copy.call(this, t),
        this.object = t.object,
        this
    }
    ,
    Rr.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    Or.prototype = Object.create(we.prototype),
    Or.prototype.constructor = Or,
    Or.prototype.updateMatrixWorld = function(t) {
        var e = this.box;
        e.isEmpty() || (e.getCenter(this.position),
        e.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        T.prototype.updateMatrixWorld.call(this, t))
    }
    ,
    Dr.prototype = Object.create(be.prototype),
    Dr.prototype.constructor = Dr,
    Dr.prototype.updateMatrixWorld = function(t) {
        var e = -this.plane.constant;
        1e-8 > Math.abs(e) && (e = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, e),
        this.children[0].material.side = 0 > e ? 1 : 0,
        this.lookAt(this.plane.normal),
        T.prototype.updateMatrixWorld.call(this, t)
    }
    ,
    zr.prototype = Object.create(T.prototype),
    zr.prototype.constructor = zr,
    zr.prototype.setDirection = function() {
        var t, e = new r;
        return function(i) {
            .99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (e.set(i.z, 0, -i.x).normalize(),
            t = Math.acos(i.y),
            this.quaternion.setFromAxisAngle(e, t))
        }
    }(),
    zr.prototype.setLength = function(t, e, i) {
        void 0 === e && (e = .2 * t),
        void 0 === i && (i = .2 * e),
        this.line.scale.set(1, Math.max(0, t - e), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, e, i),
        this.cone.position.y = t,
        this.cone.updateMatrix()
    }
    ,
    zr.prototype.setColor = function(t) {
        this.line.material.color.copy(t),
        this.cone.material.color.copy(t)
    }
    ,
    zr.prototype.copy = function(t) {
        return T.prototype.copy.call(this, t, !1),
        this.line.copy(t.line),
        this.cone.copy(t.cone),
        this
    }
    ,
    zr.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    Br.prototype = Object.create(we.prototype),
    Br.prototype.constructor = Br,
    un.create = function(t, e) {
        return t.prototype = Object.create(un.prototype),
        t.prototype.constructor = t,
        t.prototype.getPoint = e,
        t
    }
    ,
    Object.assign(En.prototype, {
        createPointsGeometry: function(t) {
            return t = this.getPoints(t),
            this.createGeometry(t)
        },
        createSpacedPointsGeometry: function(t) {
            return t = this.getSpacedPoints(t),
            this.createGeometry(t)
        },
        createGeometry: function(t) {
            for (var e = new E, i = 0, n = t.length; i < n; i++) {
                var a = t[i];
                e.vertices.push(new r(a.x,a.y,a.z || 0))
            }
            return e
        }
    }),
    Object.assign(An.prototype, {
        fromPoints: function(t) {
            this.setFromPoints(t)
        }
    }),
    Nr.prototype = Object.create(mn.prototype),
    kr.prototype = Object.create(mn.prototype),
    Ur.prototype = Object.create(mn.prototype),
    Object.assign(Ur.prototype, {
        initFromArray: function() {},
        getControlPointsArray: function() {},
        reparametrizeByArcLength: function() {}
    }),
    Er.prototype.setColors = function() {}
    ,
    Mr.prototype.update = function() {}
    ,
    Object.assign(qn.prototype, {
        extractUrlBase: function(t) {
            return Ca.extractUrlBase(t)
        }
    }),
    Object.assign(Vn.prototype, {
        setTexturePath: function(t) {
            return this.setResourcePath(t)
        }
    }),
    Object.assign(vr.prototype, {
        center: function(t) {
            return this.getCenter(t)
        },
        empty: function() {
            return this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return this.intersectsBox(t)
        },
        size: function(t) {
            return this.getSize(t)
        }
    }),
    Object.assign(p.prototype, {
        center: function(t) {
            return this.getCenter(t)
        },
        empty: function() {
            return this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return this.intersectsBox(t)
        },
        isIntersectionSphere: function(t) {
            return this.intersectsSphere(t)
        },
        size: function(t) {
            return this.getSize(t)
        }
    }),
    yr.prototype.center = function(t) {
        return this.getCenter(t)
    }
    ,
    Object.assign(Vr, {
        random16: function() {
            return Math.random()
        },
        nearestPowerOfTwo: function(t) {
            return Vr.floorPowerOfTwo(t)
        },
        nextPowerOfTwo: function(t) {
            return Vr.ceilPowerOfTwo(t)
        }
    }),
    Object.assign(a.prototype, {
        flattenToArrayOffset: function(t, e) {
            return this.toArray(t, e)
        },
        multiplyVector3: function(t) {
            return t.applyMatrix3(this)
        },
        multiplyVector3Array: function() {},
        applyToBuffer: function(t) {
            return this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {}
    }),
    Object.assign(g.prototype, {
        extractPosition: function(t) {
            return this.copyPosition(t)
        },
        flattenToArrayOffset: function(t, e) {
            return this.toArray(t, e)
        },
        getPosition: function() {
            var t;
            return function() {
                return void 0 === t && (t = new r),
                t.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(t) {
            return this.makeRotationFromQuaternion(t)
        },
        multiplyToArray: function() {},
        multiplyVector3: function(t) {
            return t.applyMatrix4(this)
        },
        multiplyVector4: function(t) {
            return t.applyMatrix4(this)
        },
        multiplyVector3Array: function() {},
        rotateAxis: function(t) {
            t.transformDirection(this)
        },
        crossVector: function(t) {
            return t.applyMatrix4(this)
        },
        translate: function() {},
        rotateX: function() {},
        rotateY: function() {},
        rotateZ: function() {},
        rotateByAxis: function() {},
        applyToBuffer: function(t) {
            return this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {},
        makeFrustum: function(t, e, i, n, r, a) {
            return this.makePerspective(t, e, n, i, r, a)
        }
    }),
    f.prototype.isIntersectionLine = function(t) {
        return this.intersectsLine(t)
    }
    ,
    n.prototype.multiplyVector3 = function(t) {
        return t.applyQuaternion(this)
    }
    ,
    Object.assign(X.prototype, {
        isIntersectionBox: function(t) {
            return this.intersectsBox(t)
        },
        isIntersectionPlane: function(t) {
            return this.intersectsPlane(t)
        },
        isIntersectionSphere: function(t) {
            return this.intersectsSphere(t)
        }
    }),
    Object.assign(q.prototype, {
        area: function() {
            return this.getArea()
        },
        barycoordFromPoint: function(t, e) {
            return this.getBarycoord(t, e)
        },
        midpoint: function(t) {
            return this.getMidpoint(t)
        },
        normal: function(t) {
            return this.getNormal(t)
        },
        plane: function(t) {
            return this.getPlane(t)
        }
    }),
    Object.assign(q, {
        barycoordFromPoint: function(t, e, i, n, r) {
            return q.getBarycoord(t, e, i, n, r)
        },
        normal: function(t, e, i, n) {
            return q.getNormal(t, e, i, n)
        }
    }),
    Object.assign(Ln.prototype, {
        extractAllPoints: function(t) {
            return this.extractPoints(t)
        },
        extrude: function(t) {
            return new ui(this,t)
        },
        makeGeometry: function(t) {
            return new Mi(this,t)
        }
    }),
    Object.assign(i.prototype, {
        fromAttribute: function(t, e, i) {
            return this.fromBufferAttribute(t, e, i)
        },
        distanceToManhattan: function(t) {
            return this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return this.manhattanLength()
        }
    }),
    Object.assign(r.prototype, {
        setEulerFromRotationMatrix: function() {},
        setEulerFromQuaternion: function() {},
        getPositionFromMatrix: function(t) {
            return this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return this.setFromMatrixColumn(e, t)
        },
        applyProjection: function(t) {
            return this.applyMatrix4(t)
        },
        fromAttribute: function(t, e, i) {
            return this.fromBufferAttribute(t, e, i)
        },
        distanceToManhattan: function(t) {
            return this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return this.manhattanLength()
        }
    }),
    Object.assign(s.prototype, {
        fromAttribute: function(t, e, i) {
            return this.fromBufferAttribute(t, e, i)
        },
        lengthManhattan: function() {
            return this.manhattanLength()
        }
    }),
    Object.assign(E.prototype, {
        computeTangents: function() {},
        computeLineDistances: function() {}
    }),
    Object.assign(T.prototype, {
        getChildByName: function(t) {
            return this.getObjectByName(t)
        },
        renderDepth: function() {},
        translate: function(t, e) {
            return this.translateOnAxis(e, t)
        },
        getWorldRotation: function() {}
    }),
    Object.defineProperties(T.prototype, {
        eulerOrder: {
            get: function() {
                return this.rotation.order
            },
            set: function(t) {
                this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {},
            set: function() {}
        }
    }),
    Object.defineProperties(me.prototype, {
        objects: {
            get: function() {
                return this.levels
            }
        }
    }),
    Object.defineProperty(ve.prototype, "useVertexTexture", {
        get: function() {},
        set: function() {}
    }),
    ge.prototype.initBones = function() {}
    ,
    Object.defineProperty(un.prototype, "__arcLengthDivisions", {
        get: function() {
            return this.arcLengthDivisions
        },
        set: function(t) {
            this.arcLengthDivisions = t
        }
    }),
    ie.prototype.setLens = function(t, e) {
        void 0 !== e && (this.filmGauge = e),
        this.setFocalLength(t)
    }
    ,
    Object.defineProperties(Pn.prototype, {
        onlyShadow: {
            set: function() {}
        },
        shadowCameraFov: {
            set: function(t) {
                this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {}
        },
        shadowBias: {
            set: function(t) {
                this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {}
        },
        shadowMapWidth: {
            set: function(t) {
                this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                this.shadow.mapSize.height = t
            }
        }
    }),
    Object.defineProperties(A.prototype, {
        length: {
            get: function() {
                return this.array.length
            }
        },
        copyIndicesArray: function() {}
    }),
    Object.assign(U.prototype, {
        addIndex: function(t) {
            this.setIndex(t)
        },
        addDrawCall: function(t, e) {
            this.addGroup(t, e)
        },
        clearDrawCalls: function() {
            this.clearGroups()
        },
        computeTangents: function() {},
        computeOffsets: function() {}
    }),
    Object.defineProperties(U.prototype, {
        drawcalls: {
            get: function() {
                return this.groups
            }
        },
        offsets: {
            get: function() {
                return this.groups
            }
        }
    }),
    Object.assign(pi.prototype, {
        getArrays: function() {},
        addShapeList: function() {},
        addShape: function() {}
    }),
    Object.defineProperties(cr.prototype, {
        dynamic: {
            set: function() {}
        },
        onUpdate: {
            value: function() {
                return this
            }
        }
    }),
    Object.defineProperties(H.prototype, {
        wrapAround: {
            get: function() {},
            set: function() {}
        },
        overdraw: {
            get: function() {},
            set: function() {}
        },
        wrapRGB: {
            get: function() {
                return new x
            }
        },
        shading: {
            get: function() {},
            set: function(t) {
                this.flatShading = 1 === t
            }
        }
    }),
    Object.defineProperties(Bi.prototype, {
        metal: {
            get: function() {
                return !1
            },
            set: function() {}
        }
    }),
    Object.defineProperties(W.prototype, {
        derivatives: {
            get: function() {
                return this.extensions.derivatives
            },
            set: function(t) {
                this.extensions.derivatives = t
            }
        }
    }),
    Object.assign(se.prototype, {
        clearTarget: function(t, e, i, n) {
            this.setRenderTarget(t),
            this.clear(e, i, n)
        },
        animate: function(t) {
            this.setAnimationLoop(t)
        },
        getCurrentRenderTarget: function() {
            return this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return this.capabilities.precision
        },
        resetGLState: function() {
            return this.state.reset()
        },
        supportsFloatTextures: function() {
            return this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(t) {
            this.setScissorTest(t)
        },
        initMaterial: function() {},
        addPrePlugin: function() {},
        addPostPlugin: function() {},
        updateShadowMap: function() {},
        setFaceCulling: function() {},
        allocTextureUnit: function() {},
        setTexture: function() {},
        setTexture2D: function() {},
        setTextureCube: function() {}
    }),
    Object.defineProperties(se.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {},
            set: function() {}
        }
    }),
    Object.defineProperties(Kt.prototype, {
        cullFace: {
            get: function() {},
            set: function() {}
        },
        renderReverseSided: {
            get: function() {},
            set: function() {}
        },
        renderSingleSided: {
            get: function() {},
            set: function() {}
        }
    }),
    Object.defineProperties(l.prototype, {
        activeCubeFace: {
            set: function() {}
        },
        activeMipMapLevel: {
            set: function() {}
        }
    }),
    Object.defineProperties(c.prototype, {
        wrapS: {
            get: function() {
                return this.texture.wrapS
            },
            set: function(t) {
                this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return this.texture.wrapT
            },
            set: function(t) {
                this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return this.texture.magFilter
            },
            set: function(t) {
                this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return this.texture.minFilter
            },
            set: function(t) {
                this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return this.texture.anisotropy
            },
            set: function(t) {
                this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return this.texture.offset
            },
            set: function(t) {
                this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return this.texture.repeat
            },
            set: function(t) {
                this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return this.texture.format
            },
            set: function(t) {
                this.texture.format = t
            }
        },
        type: {
            get: function() {
                return this.texture.type
            },
            set: function(t) {
                this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return this.texture.generateMipmaps
            },
            set: function(t) {
                this.texture.generateMipmaps = t
            }
        }
    }),
    Object.defineProperties(ae.prototype, {
        standing: {
            set: function() {}
        },
        userHeight: {
            set: function() {}
        }
    }),
    $n.prototype.load = function(t) {
        var e = this;
        return (new Yn).load(t, function(t) {
            e.setBuffer(t)
        }),
        this
    }
    ,
    er.prototype.getData = function() {
        return this.getFrequencyData()
    }
    ,
    Zn.prototype.updateCubeMap = function(t, e) {
        return this.update(t, e)
    }
    ,
    Hr.crossOrigin = void 0,
    Hr.loadTexture = function(t, e, i, n) {
        var r = new ln;
        return r.setCrossOrigin(this.crossOrigin),
        t = r.load(t, i, void 0, n),
        e && (t.mapping = e),
        t
    }
    ,
    Hr.loadTextureCube = function(t, e, i, n) {
        var r = new hn;
        return r.setCrossOrigin(this.crossOrigin),
        t = r.load(t, i, void 0, n),
        e && (t.mapping = e),
        t
    }
    ,
    Hr.loadCompressedTexture = function() {}
    ,
    Hr.loadCompressedTextureCube = function() {}
    ,
    t.WebGLMultisampleRenderTarget = h,
    t.WebGLRenderTargetCube = l,
    t.WebGLRenderTarget = c,
    t.WebGLRenderer = se,
    t.ShaderLib = Zr,
    t.UniformsLib = Jr,
    t.UniformsUtils = qr,
    t.ShaderChunk = Xr,
    t.FogExp2 = ce,
    t.Fog = he,
    t.Scene = le,
    t.Sprite = fe,
    t.LOD = me,
    t.SkinnedMesh = ge,
    t.Skeleton = ve,
    t.Bone = ye,
    t.Mesh = J,
    t.LineSegments = we,
    t.LineLoop = Me,
    t.Line = be,
    t.Points = Se,
    t.Group = te,
    t.VideoTexture = Te,
    t.DataTexture = u,
    t.DataTexture2DArray = et,
    t.DataTexture3D = it,
    t.CompressedTexture = Ee,
    t.CubeTexture = tt,
    t.CanvasTexture = Ae,
    t.DepthTexture = Le,
    t.Texture = o,
    t.AnimationLoader = an,
    t.CompressedTextureLoader = on,
    t.DataTextureLoader = sn,
    t.CubeTextureLoader = hn,
    t.TextureLoader = ln,
    t.ObjectLoader = Vn,
    t.MaterialLoader = Fn,
    t.BufferGeometryLoader = Gn,
    t.DefaultLoadingManager = _a,
    t.LoadingManager = nn,
    t.ImageLoader = cn,
    t.ImageBitmapLoader = jn,
    t.FontLoader = Xn,
    t.FileLoader = rn,
    t.Loader = qn,
    t.LoaderUtils = Ca,
    t.Cache = Ma,
    t.AudioLoader = Yn,
    t.SpotLightShadow = Rn,
    t.SpotLight = On,
    t.PointLight = Dn,
    t.RectAreaLight = Un,
    t.HemisphereLight = Cn,
    t.DirectionalLightShadow = Bn,
    t.DirectionalLight = Nn,
    t.AmbientLight = kn,
    t.LightShadow = In,
    t.Light = Pn,
    t.StereoCamera = Jn,
    t.PerspectiveCamera = ie,
    t.OrthographicCamera = zn,
    t.CubeCamera = Zn,
    t.ArrayCamera = ne,
    t.Camera = ee,
    t.AudioListener = Kn,
    t.PositionalAudio = tr,
    t.AudioContext = ka,
    t.AudioAnalyser = er,
    t.Audio = $n,
    t.VectorKeyframeTrack = $i,
    t.StringKeyframeTrack = Ki,
    t.QuaternionKeyframeTrack = Qi,
    t.NumberKeyframeTrack = Ji,
    t.ColorKeyframeTrack = Yi,
    t.BooleanKeyframeTrack = qi,
    t.PropertyMixer = ir,
    t.PropertyBinding = rr,
    t.KeyframeTrack = Xi,
    t.AnimationUtils = wa,
    t.AnimationObjectGroup = ar,
    t.AnimationMixer = sr,
    t.AnimationClip = tn,
    t.Uniform = cr,
    t.InstancedBufferGeometry = hr,
    t.BufferGeometry = U,
    t.Geometry = E,
    t.InterleavedBufferAttribute = pe,
    t.InstancedInterleavedBuffer = lr,
    t.InterleavedBuffer = ue,
    t.InstancedBufferAttribute = ur,
    t.Face3 = M,
    t.Object3D = T,
    t.Raycaster = pr,
    t.Layers = S,
    t.EventDispatcher = e,
    t.Clock = Qn,
    t.QuaternionLinearInterpolant = Zi,
    t.LinearInterpolant = Hi,
    t.DiscreteInterpolant = Wi,
    t.CubicInterpolant = ji,
    t.Interpolant = Vi,
    t.Triangle = q,
    t.Math = Vr,
    t.Spherical = mr,
    t.Cylindrical = gr,
    t.Plane = f,
    t.Frustum = m,
    t.Sphere = d,
    t.Ray = X,
    t.Matrix4 = g,
    t.Matrix3 = a,
    t.Box3 = p,
    t.Box2 = vr,
    t.Line3 = yr,
    t.Euler = _,
    t.Vector4 = s,
    t.Vector3 = r,
    t.Vector2 = i,
    t.Quaternion = n,
    t.Color = x,
    t.ImmediateRenderObject = xr,
    t.VertexNormalsHelper = br,
    t.SpotLightHelper = wr,
    t.SkeletonHelper = Mr,
    t.PointLightHelper = _r,
    t.RectAreaLightHelper = Sr,
    t.HemisphereLightHelper = Tr,
    t.GridHelper = Er,
    t.PolarGridHelper = Ar,
    t.PositionalAudioHelper = Lr,
    t.FaceNormalsHelper = Pr,
    t.DirectionalLightHelper = Cr,
    t.CameraHelper = Ir,
    t.BoxHelper = Rr,
    t.Box3Helper = Or,
    t.PlaneHelper = Dr,
    t.ArrowHelper = zr,
    t.AxesHelper = Br,
    t.Shape = Ln,
    t.Path = An,
    t.ShapePath = Hn,
    t.Font = Wn,
    t.CurvePath = En,
    t.Curve = un,
    t.ImageUtils = Hr,
    t.ShapeUtils = va,
    t.WebGLUtils = $t,
    t.WireframeGeometry = Pe,
    t.ParametricGeometry = Ce,
    t.ParametricBufferGeometry = Ie,
    t.TetrahedronGeometry = De,
    t.TetrahedronBufferGeometry = ze,
    t.OctahedronGeometry = Be,
    t.OctahedronBufferGeometry = Ne,
    t.IcosahedronGeometry = ke,
    t.IcosahedronBufferGeometry = Ue,
    t.DodecahedronGeometry = Fe,
    t.DodecahedronBufferGeometry = Ge,
    t.PolyhedronGeometry = Re,
    t.PolyhedronBufferGeometry = Oe,
    t.TubeGeometry = Ve,
    t.TubeBufferGeometry = je,
    t.TorusKnotGeometry = He,
    t.TorusKnotBufferGeometry = We,
    t.TorusGeometry = Xe,
    t.TorusBufferGeometry = qe,
    t.TextGeometry = fi,
    t.TextBufferGeometry = mi,
    t.SphereGeometry = gi,
    t.SphereBufferGeometry = vi,
    t.RingGeometry = yi,
    t.RingBufferGeometry = xi,
    t.PlaneGeometry = V,
    t.PlaneBufferGeometry = j,
    t.LatheGeometry = bi,
    t.LatheBufferGeometry = wi,
    t.ShapeGeometry = Mi,
    t.ShapeBufferGeometry = _i,
    t.ExtrudeGeometry = ui,
    t.ExtrudeBufferGeometry = pi,
    t.EdgesGeometry = Ti,
    t.ConeGeometry = Li,
    t.ConeBufferGeometry = Pi,
    t.CylinderGeometry = Ei,
    t.CylinderBufferGeometry = Ai,
    t.CircleGeometry = Ci,
    t.CircleBufferGeometry = Ii,
    t.BoxGeometry = F,
    t.CubeGeometry = F,
    t.BoxBufferGeometry = G,
    t.ShadowMaterial = Ri,
    t.SpriteMaterial = de,
    t.RawShaderMaterial = Oi,
    t.ShaderMaterial = W,
    t.PointsMaterial = _e,
    t.MeshPhysicalMaterial = zi,
    t.MeshStandardMaterial = Di,
    t.MeshPhongMaterial = Bi,
    t.MeshToonMaterial = Ni,
    t.MeshNormalMaterial = ki,
    t.MeshLambertMaterial = Ui,
    t.MeshDepthMaterial = Zt,
    t.MeshDistanceMaterial = Qt,
    t.MeshBasicMaterial = Y,
    t.MeshMatcapMaterial = Fi,
    t.LineDashedMaterial = Gi,
    t.LineBasicMaterial = xe,
    t.Material = H,
    t.Float64BufferAttribute = B,
    t.Float32BufferAttribute = z,
    t.Uint32BufferAttribute = D,
    t.Int32BufferAttribute = O,
    t.Uint16BufferAttribute = R,
    t.Int16BufferAttribute = I,
    t.Uint8ClampedBufferAttribute = C,
    t.Uint8BufferAttribute = P,
    t.Int8BufferAttribute = L,
    t.BufferAttribute = A,
    t.ArcCurve = dn,
    t.CatmullRomCurve3 = mn,
    t.CubicBezierCurve = xn,
    t.CubicBezierCurve3 = bn,
    t.EllipseCurve = pn,
    t.LineCurve = wn,
    t.LineCurve3 = Mn,
    t.QuadraticBezierCurve = _n,
    t.QuadraticBezierCurve3 = Sn,
    t.SplineCurve = Tn,
    t.REVISION = "103",
    t.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    },
    t.CullFaceNone = 0,
    t.CullFaceBack = 1,
    t.CullFaceFront = 2,
    t.CullFaceFrontBack = 3,
    t.FrontFaceDirectionCW = 0,
    t.FrontFaceDirectionCCW = 1,
    t.BasicShadowMap = 0,
    t.PCFShadowMap = 1,
    t.PCFSoftShadowMap = 2,
    t.FrontSide = 0,
    t.BackSide = 1,
    t.DoubleSide = 2,
    t.FlatShading = 1,
    t.SmoothShading = 2,
    t.NoColors = 0,
    t.FaceColors = 1,
    t.VertexColors = 2,
    t.NoBlending = 0,
    t.NormalBlending = 1,
    t.AdditiveBlending = 2,
    t.SubtractiveBlending = 3,
    t.MultiplyBlending = 4,
    t.CustomBlending = 5,
    t.AddEquation = 100,
    t.SubtractEquation = 101,
    t.ReverseSubtractEquation = 102,
    t.MinEquation = 103,
    t.MaxEquation = 104,
    t.ZeroFactor = 200,
    t.OneFactor = 201,
    t.SrcColorFactor = 202,
    t.OneMinusSrcColorFactor = 203,
    t.SrcAlphaFactor = 204,
    t.OneMinusSrcAlphaFactor = 205,
    t.DstAlphaFactor = 206,
    t.OneMinusDstAlphaFactor = 207,
    t.DstColorFactor = 208,
    t.OneMinusDstColorFactor = 209,
    t.SrcAlphaSaturateFactor = 210,
    t.NeverDepth = 0,
    t.AlwaysDepth = 1,
    t.LessDepth = 2,
    t.LessEqualDepth = 3,
    t.EqualDepth = 4,
    t.GreaterEqualDepth = 5,
    t.GreaterDepth = 6,
    t.NotEqualDepth = 7,
    t.MultiplyOperation = 0,
    t.MixOperation = 1,
    t.AddOperation = 2,
    t.NoToneMapping = 0,
    t.LinearToneMapping = 1,
    t.ReinhardToneMapping = 2,
    t.Uncharted2ToneMapping = 3,
    t.CineonToneMapping = 4,
    t.ACESFilmicToneMapping = 5,
    t.UVMapping = 300,
    t.CubeReflectionMapping = 301,
    t.CubeRefractionMapping = 302,
    t.EquirectangularReflectionMapping = 303,
    t.EquirectangularRefractionMapping = 304,
    t.SphericalReflectionMapping = 305,
    t.CubeUVReflectionMapping = 306,
    t.CubeUVRefractionMapping = 307,
    t.RepeatWrapping = 1e3,
    t.ClampToEdgeWrapping = 1001,
    t.MirroredRepeatWrapping = 1002,
    t.NearestFilter = 1003,
    t.NearestMipMapNearestFilter = 1004,
    t.NearestMipMapLinearFilter = 1005,
    t.LinearFilter = 1006,
    t.LinearMipMapNearestFilter = 1007,
    t.LinearMipMapLinearFilter = 1008,
    t.UnsignedByteType = 1009,
    t.ByteType = 1010,
    t.ShortType = 1011,
    t.UnsignedShortType = 1012,
    t.IntType = 1013,
    t.UnsignedIntType = 1014,
    t.FloatType = 1015,
    t.HalfFloatType = 1016,
    t.UnsignedShort4444Type = 1017,
    t.UnsignedShort5551Type = 1018,
    t.UnsignedShort565Type = 1019,
    t.UnsignedInt248Type = 1020,
    t.AlphaFormat = 1021,
    t.RGBFormat = 1022,
    t.RGBAFormat = 1023,
    t.LuminanceFormat = 1024,
    t.LuminanceAlphaFormat = 1025,
    t.RGBEFormat = 1023,
    t.DepthFormat = 1026,
    t.DepthStencilFormat = 1027,
    t.RedFormat = 1028,
    t.RGB_S3TC_DXT1_Format = 33776,
    t.RGBA_S3TC_DXT1_Format = 33777,
    t.RGBA_S3TC_DXT3_Format = 33778,
    t.RGBA_S3TC_DXT5_Format = 33779,
    t.RGB_PVRTC_4BPPV1_Format = 35840,
    t.RGB_PVRTC_2BPPV1_Format = 35841,
    t.RGBA_PVRTC_4BPPV1_Format = 35842,
    t.RGBA_PVRTC_2BPPV1_Format = 35843,
    t.RGB_ETC1_Format = 36196,
    t.RGBA_ASTC_4x4_Format = 37808,
    t.RGBA_ASTC_5x4_Format = 37809,
    t.RGBA_ASTC_5x5_Format = 37810,
    t.RGBA_ASTC_6x5_Format = 37811,
    t.RGBA_ASTC_6x6_Format = 37812,
    t.RGBA_ASTC_8x5_Format = 37813,
    t.RGBA_ASTC_8x6_Format = 37814,
    t.RGBA_ASTC_8x8_Format = 37815,
    t.RGBA_ASTC_10x5_Format = 37816,
    t.RGBA_ASTC_10x6_Format = 37817,
    t.RGBA_ASTC_10x8_Format = 37818,
    t.RGBA_ASTC_10x10_Format = 37819,
    t.RGBA_ASTC_12x10_Format = 37820,
    t.RGBA_ASTC_12x12_Format = 37821,
    t.LoopOnce = 2200,
    t.LoopRepeat = 2201,
    t.LoopPingPong = 2202,
    t.InterpolateDiscrete = 2300,
    t.InterpolateLinear = 2301,
    t.InterpolateSmooth = 2302,
    t.ZeroCurvatureEnding = 2400,
    t.ZeroSlopeEnding = 2401,
    t.WrapAroundEnding = 2402,
    t.TrianglesDrawMode = 0,
    t.TriangleStripDrawMode = 1,
    t.TriangleFanDrawMode = 2,
    t.LinearEncoding = 3e3,
    t.sRGBEncoding = 3001,
    t.GammaEncoding = 3007,
    t.RGBEEncoding = 3002,
    t.LogLuvEncoding = 3003,
    t.RGBM7Encoding = 3004,
    t.RGBM16Encoding = 3005,
    t.RGBDEncoding = 3006,
    t.BasicDepthPacking = 3200,
    t.RGBADepthPacking = 3201,
    t.TangentSpaceNormalMap = 0,
    t.ObjectSpaceNormalMap = 1,
    t.Face4 = function(t, e, i, n, r, a, o) {
        return new M(t,e,i,r,a,o)
    }
    ,
    t.LineStrip = 0,
    t.LinePieces = 1,
    t.MeshFaceMaterial = function(t) {
        return t
    }
    ,
    t.MultiMaterial = function(t) {
        return void 0 === t && (t = []),
        t.isMultiMaterial = !0,
        t.materials = t,
        t.clone = function() {
            return t.slice()
        }
        ,
        t
    }
    ,
    t.PointCloud = function(t, e) {
        return new Se(t,e)
    }
    ,
    t.Particle = function(t) {
        return new fe(t)
    }
    ,
    t.ParticleSystem = function(t, e) {
        return new Se(t,e)
    }
    ,
    t.PointCloudMaterial = function(t) {
        return new _e(t)
    }
    ,
    t.ParticleBasicMaterial = function(t) {
        return new _e(t)
    }
    ,
    t.ParticleSystemMaterial = function(t) {
        return new _e(t)
    }
    ,
    t.Vertex = function(t, e, i) {
        return new r(t,e,i)
    }
    ,
    t.DynamicBufferAttribute = function(t, e) {
        return new A(t,e).setDynamic(!0)
    }
    ,
    t.Int8Attribute = function(t, e) {
        return new L(t,e)
    }
    ,
    t.Uint8Attribute = function(t, e) {
        return new P(t,e)
    }
    ,
    t.Uint8ClampedAttribute = function(t, e) {
        return new C(t,e)
    }
    ,
    t.Int16Attribute = function(t, e) {
        return new I(t,e)
    }
    ,
    t.Uint16Attribute = function(t, e) {
        return new R(t,e)
    }
    ,
    t.Int32Attribute = function(t, e) {
        return new O(t,e)
    }
    ,
    t.Uint32Attribute = function(t, e) {
        return new D(t,e)
    }
    ,
    t.Float32Attribute = function(t, e) {
        return new z(t,e)
    }
    ,
    t.Float64Attribute = function(t, e) {
        return new B(t,e)
    }
    ,
    t.ClosedSplineCurve3 = Nr,
    t.SplineCurve3 = kr,
    t.Spline = Ur,
    t.AxisHelper = function(t) {
        return new Br(t)
    }
    ,
    t.BoundingBoxHelper = function(t, e) {
        return new Rr(t,e)
    }
    ,
    t.EdgesHelper = function(t, e) {
        return new we(new Ti(t.geometry),new xe({
            color: void 0 !== e ? e : 16777215
        }))
    }
    ,
    t.WireframeHelper = function(t, e) {
        return new we(new Pe(t.geometry),new xe({
            color: void 0 !== e ? e : 16777215
        }))
    }
    ,
    t.XHRLoader = function(t) {
        return new rn(t)
    }
    ,
    t.BinaryTextureLoader = function(t) {
        return new sn(t)
    }
    ,
    t.GeometryUtils = {
        merge: function(t, e, i) {
            if (e.isMesh) {
                e.matrixAutoUpdate && e.updateMatrix();
                var n = e.matrix;
                e = e.geometry
            }
            t.merge(e, n, i)
        },
        center: function(t) {
            return t.center()
        }
    },
    t.Projector = function() {
        this.projectVector = function(t, e) {
            t.project(e)
        }
        ,
        this.unprojectVector = function(t, e) {
            t.unproject(e)
        }
        ,
        this.pickingRay = function() {}
    }
    ,
    t.CanvasRenderer = function() {}
    ,
    t.JSONLoader = function() {}
    ,
    t.SceneUtils = {
        createMultiMaterialObject: function() {},
        detach: function() {},
        attach: function() {}
    },
    t.LensFlare = function() {}
    ,
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}
,
"object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).THREE = {}),
THREE.EffectComposer = function(t, e) {
    if (this.renderer = t,
    void 0 === e) {
        var i = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            stencilBuffer: !1
        }
          , n = t.getDrawingBufferSize(new THREE.Vector2);
        (e = new THREE.WebGLRenderTarget(n.width,n.height,i)).texture.name = "EffectComposer.rt1"
    }
    this.renderTarget1 = e,
    this.renderTarget2 = e.clone(),
    this.renderTarget2.texture.name = "EffectComposer.rt2",
    this.writeBuffer = this.renderTarget1,
    this.readBuffer = this.renderTarget2,
    this.renderToScreen = !0,
    this.passes = [],
    THREE.CopyShader,
    THREE.ShaderPass,
    this.copyPass = new THREE.ShaderPass(THREE.CopyShader),
    this._previousFrameTime = Date.now()
}
,
Object.assign(THREE.EffectComposer.prototype, {
    swapBuffers: function() {
        var t = this.readBuffer;
        this.readBuffer = this.writeBuffer,
        this.writeBuffer = t
    },
    addPass: function(t) {
        this.passes.push(t);
        var e = this.renderer.getDrawingBufferSize(new THREE.Vector2);
        t.setSize(e.width, e.height)
    },
    insertPass: function(t, e) {
        this.passes.splice(e, 0, t)
    },
    isLastEnabledPass: function(t) {
        for (var e = t + 1; e < this.passes.length; e++)
            if (this.passes[e].enabled)
                return !1;
        return !0
    },
    render: function(t) {
        void 0 === t && (t = .001 * (Date.now() - this._previousFrameTime)),
        this._previousFrameTime = Date.now();
        var e, i, n = this.renderer.getRenderTarget(), r = !1, a = this.passes.length;
        for (i = 0; i < a; i++)
            if (!1 !== (e = this.passes[i]).enabled) {
                if (e.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i),
                e.render(this.renderer, this.writeBuffer, this.readBuffer, t, r),
                e.needsSwap) {
                    if (r) {
                        var o = this.renderer.context;
                        o.stencilFunc(o.NOTEQUAL, 1, 4294967295),
                        this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t),
                        o.stencilFunc(o.EQUAL, 1, 4294967295)
                    }
                    this.swapBuffers()
                }
                void 0 !== THREE.MaskPass && (e instanceof THREE.MaskPass ? r = !0 : e instanceof THREE.ClearMaskPass && (r = !1))
            }
        this.renderer.setRenderTarget(n)
    },
    reset: function(t) {
        if (void 0 === t) {
            var e = this.renderer.getDrawingBufferSize(new THREE.Vector2);
            (t = this.renderTarget1.clone()).setSize(e.width, e.height)
        }
        this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        this.renderTarget1 = t,
        this.renderTarget2 = t.clone(),
        this.writeBuffer = this.renderTarget1,
        this.readBuffer = this.renderTarget2
    },
    setSize: function(t, e) {
        this.renderTarget1.setSize(t, e),
        this.renderTarget2.setSize(t, e);
        for (var i = 0; i < this.passes.length; i++)
            this.passes[i].setSize(t, e)
    }
}),
THREE.Pass = function() {
    this.enabled = !0,
    this.needsSwap = !0,
    this.clear = !1,
    this.renderToScreen = !1
}
,
Object.assign(THREE.Pass.prototype, {
    setSize: function() {},
    render: function() {}
}),
THREE.Pass.FullScreenQuad = function() {
    var t = new THREE.OrthographicCamera(-1,1,1,-1,0,1)
      , e = new THREE.PlaneBufferGeometry(2,2)
      , i = function(t) {
        this._mesh = new THREE.Mesh(e,t)
    };
    return Object.defineProperty(i.prototype, "material", {
        get: function() {
            return this._mesh.material
        },
        set: function(t) {
            this._mesh.material = t
        }
    }),
    Object.assign(i.prototype, {
        render: function(e) {
            e.render(this._mesh, t)
        }
    }),
    i
}(),
THREE.RenderPass = function(t, e, i, n, r) {
    THREE.Pass.call(this),
    this.scene = t,
    this.camera = e,
    this.overrideMaterial = i,
    this.clearColor = n,
    this.clearAlpha = void 0 !== r ? r : 0,
    this.clear = !0,
    this.clearDepth = !1,
    this.needsSwap = !1
}
,
THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.RenderPass,
    render: function(t, e, i) {
        var n, r, a = t.autoClear;
        t.autoClear = !1,
        this.scene.overrideMaterial = this.overrideMaterial,
        this.clearColor && (n = t.getClearColor().getHex(),
        r = t.getClearAlpha(),
        t.setClearColor(this.clearColor, this.clearAlpha)),
        this.clearDepth && t.clearDepth(),
        t.setRenderTarget(this.renderToScreen ? null : i),
        this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
        t.render(this.scene, this.camera),
        this.clearColor && t.setClearColor(n, r),
        this.scene.overrideMaterial = null,
        t.autoClear = a
    }
}),
THREE.ShaderPass = function(t, e) {
    THREE.Pass.call(this),
    this.textureID = void 0 !== e ? e : "tDiffuse",
    t instanceof THREE.ShaderMaterial ? (this.uniforms = t.uniforms,
    this.material = t) : t && (this.uniforms = THREE.UniformsUtils.clone(t.uniforms),
    this.material = new THREE.ShaderMaterial({
        defines: Object.assign({}, t.defines),
        uniforms: this.uniforms,
        vertexShader: t.vertexShader,
        fragmentShader: t.fragmentShader
    })),
    this.fsQuad = new THREE.Pass.FullScreenQuad(this.material)
}
,
THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.ShaderPass,
    render: function(t, e, i) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture),
        this.fsQuad.material = this.material,
        this.renderToScreen ? (t.setRenderTarget(null),
        this.fsQuad.render(t)) : (t.setRenderTarget(e),
        this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
        this.fsQuad.render(t))
    }
}),
THREE.CopyShader = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        opacity: {
            value: 1
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
},
THREE.LuminosityHighPassShader = {
    shaderID: "luminosityHighPass",
    uniforms: {
        tDiffuse: {
            value: null
        },
        luminosityThreshold: {
            value: 1
        },
        smoothWidth: {
            value: 1
        },
        defaultColor: {
            value: new THREE.Color(0)
        },
        defaultOpacity: {
            value: 0
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float v = dot( texel.xyz, luma );", "vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "gl_FragColor = mix( outputColor, texel, alpha );", "}"].join("\n")
},
THREE.UnrealBloomPass = function(t, e, i, n) {
    THREE.Pass.call(this),
    this.strength = void 0 !== e ? e : 1,
    this.radius = i,
    this.threshold = n,
    this.resolution = void 0 !== t ? new THREE.Vector2(t.x,t.y) : new THREE.Vector2(256,256),
    this.clearColor = new THREE.Color(0,0,0);
    var r = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
    };
    this.renderTargetsHorizontal = [],
    this.renderTargetsVertical = [],
    this.nMips = 5;
    var a = Math.round(this.resolution.x / 2)
      , o = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new THREE.WebGLRenderTarget(a,o,r),
    this.renderTargetBright.texture.name = "UnrealBloomPass.bright",
    this.renderTargetBright.texture.generateMipmaps = !1;
    for (var s = 0; s < this.nMips; s++) {
        var c = new THREE.WebGLRenderTarget(a,o,r);
        c.texture.name = "UnrealBloomPass.h" + s,
        c.texture.generateMipmaps = !1,
        this.renderTargetsHorizontal.push(c);
        var h = new THREE.WebGLRenderTarget(a,o,r);
        h.texture.name = "UnrealBloomPass.v" + s,
        h.texture.generateMipmaps = !1,
        this.renderTargetsVertical.push(h),
        a = Math.round(a / 2),
        o = Math.round(o / 2)
    }
    THREE.LuminosityHighPassShader;
    var l = THREE.LuminosityHighPassShader;
    this.highPassUniforms = THREE.UniformsUtils.clone(l.uniforms),
    this.highPassUniforms.luminosityThreshold.value = n,
    this.highPassUniforms.smoothWidth.value = .01,
    this.materialHighPassFilter = new THREE.ShaderMaterial({
        uniforms: this.highPassUniforms,
        vertexShader: l.vertexShader,
        fragmentShader: l.fragmentShader,
        defines: {}
    }),
    this.separableBlurMaterials = [];
    var u = [3, 5, 7, 9, 11];
    for (a = Math.round(this.resolution.x / 2),
    o = Math.round(this.resolution.y / 2),
    s = 0; s < this.nMips; s++)
        this.separableBlurMaterials.push(this.getSeperableBlurMaterial(u[s])),
        this.separableBlurMaterials[s].uniforms.texSize.value = new THREE.Vector2(a,o),
        a = Math.round(a / 2),
        o = Math.round(o / 2);
    this.compositeMaterial = this.getCompositeMaterial(this.nMips),
    this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture,
    this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture,
    this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture,
    this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture,
    this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture,
    this.compositeMaterial.uniforms.bloomStrength.value = e,
    this.compositeMaterial.uniforms.bloomRadius.value = .1,
    this.compositeMaterial.needsUpdate = !0;
    this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2],
    this.bloomTintColors = [new THREE.Vector3(1,1,1), new THREE.Vector3(1,1,1), new THREE.Vector3(1,1,1), new THREE.Vector3(1,1,1), new THREE.Vector3(1,1,1)],
    this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors,
    THREE.CopyShader;
    var p = THREE.CopyShader;
    this.copyUniforms = THREE.UniformsUtils.clone(p.uniforms),
    this.copyUniforms.opacity.value = 1,
    this.materialCopy = new THREE.ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: p.vertexShader,
        fragmentShader: p.fragmentShader,
        blending: THREE.AdditiveBlending,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
    }),
    this.enabled = !0,
    this.needsSwap = !1,
    this.oldClearColor = new THREE.Color,
    this.oldClearAlpha = 1,
    this.basic = new THREE.MeshBasicMaterial,
    this.fsQuad = new THREE.Pass.FullScreenQuad(null)
}
,
THREE.UnrealBloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.UnrealBloomPass,
    dispose: function() {
        for (var t = 0; t < this.renderTargetsHorizontal.length; t++)
            this.renderTargetsHorizontal[t].dispose();
        for (t = 0; t < this.renderTargetsVertical.length; t++)
            this.renderTargetsVertical[t].dispose();
        this.renderTargetBright.dispose()
    },
    setSize: function(t, e) {
        var i = Math.round(t / 2)
          , n = Math.round(e / 2);
        this.renderTargetBright.setSize(i, n);
        for (var r = 0; r < this.nMips; r++)
            this.renderTargetsHorizontal[r].setSize(i, n),
            this.renderTargetsVertical[r].setSize(i, n),
            this.separableBlurMaterials[r].uniforms.texSize.value = new THREE.Vector2(i,n),
            i = Math.round(i / 2),
            n = Math.round(n / 2)
    },
    render: function(t, e, i, n, r) {
        this.oldClearColor.copy(t.getClearColor()),
        this.oldClearAlpha = t.getClearAlpha();
        var a = t.autoClear;
        t.autoClear = !1,
        t.setClearColor(this.clearColor, 0),
        r && t.context.disable(t.context.STENCIL_TEST),
        this.renderToScreen && (this.fsQuad.material = this.basic,
        this.basic.map = i.texture,
        t.setRenderTarget(null),
        t.clear(),
        this.fsQuad.render(t)),
        this.highPassUniforms.tDiffuse.value = i.texture,
        this.highPassUniforms.luminosityThreshold.value = this.threshold,
        this.fsQuad.material = this.materialHighPassFilter,
        t.setRenderTarget(this.renderTargetBright),
        t.clear(),
        this.fsQuad.render(t);
        for (var o = this.renderTargetBright, s = 0; s < this.nMips; s++)
            this.fsQuad.material = this.separableBlurMaterials[s],
            this.separableBlurMaterials[s].uniforms.colorTexture.value = o.texture,
            this.separableBlurMaterials[s].uniforms.direction.value = THREE.UnrealBloomPass.BlurDirectionX,
            t.setRenderTarget(this.renderTargetsHorizontal[s]),
            t.clear(),
            this.fsQuad.render(t),
            this.separableBlurMaterials[s].uniforms.colorTexture.value = this.renderTargetsHorizontal[s].texture,
            this.separableBlurMaterials[s].uniforms.direction.value = THREE.UnrealBloomPass.BlurDirectionY,
            t.setRenderTarget(this.renderTargetsVertical[s]),
            t.clear(),
            this.fsQuad.render(t),
            o = this.renderTargetsVertical[s];
        this.fsQuad.material = this.compositeMaterial,
        this.compositeMaterial.uniforms.bloomStrength.value = this.strength,
        this.compositeMaterial.uniforms.bloomRadius.value = this.radius,
        this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors,
        t.setRenderTarget(this.renderTargetsHorizontal[0]),
        t.clear(),
        this.fsQuad.render(t),
        this.fsQuad.material = this.materialCopy,
        this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture,
        r && t.context.enable(t.context.STENCIL_TEST),
        this.renderToScreen ? (t.setRenderTarget(null),
        this.fsQuad.render(t)) : (t.setRenderTarget(i),
        this.fsQuad.render(t)),
        t.setClearColor(this.oldClearColor, this.oldClearAlpha),
        t.autoClear = a
    },
    getSeperableBlurMaterial: function(t) {
        return new THREE.ShaderMaterial({
            defines: {
                KERNEL_RADIUS: t,
                SIGMA: t
            },
            uniforms: {
                colorTexture: {
                    value: null
                },
                texSize: {
                    value: new THREE.Vector2(.5,.5)
                },
                direction: {
                    value: new THREE.Vector2(.5,.5)
                }
            },
            vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader: "#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"
        })
    },
    getCompositeMaterial: function(t) {
        return new THREE.ShaderMaterial({
            defines: {
                NUM_MIPS: t
            },
            uniforms: {
                blurTexture1: {
                    value: null
                },
                blurTexture2: {
                    value: null
                },
                blurTexture3: {
                    value: null
                },
                blurTexture4: {
                    value: null
                },
                blurTexture5: {
                    value: null
                },
                dirtTexture: {
                    value: null
                },
                bloomStrength: {
                    value: 1
                },
                bloomFactors: {
                    value: null
                },
                bloomTintColors: {
                    value: null
                },
                bloomRadius: {
                    value: 0
                }
            },
            vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader: "varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"
        })
    }
}),
THREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1,0),
THREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0,1),
localStorage.getItem("[yesnt] options") || (window.location = "./settings.html");
const i = new URL(window.location).searchParams
  , n = window.location.search.length > 1;
function r(t) {
    const e = document.createElement("div");
    e.classList.add("error"),
    e.textContent = t,
    document.body ? document.body.appendChild(e) : document.addEventListener("DOMContentLoaded", ()=>{
        document.body.appendChild(e)
    }
    )
}
window.addEventListener("error", t=>r(t.message)),
window.addEventListener("unhandledrejection", t=>r(t.reason));
const a = {
    fov: 75,
    sensitivity: 700,
    touchSensitivity: 200,
    controls: {
        default: !0,
        87: "forth",
        65: "left",
        83: "back",
        68: "right",
        16: "get-up",
        70: "phone",
        13: "skip-intro",
        8: "del-code-digit",
        82: "reset",
        79: "om",
        81: "inhale",
        69: "exhale",
        32: "trip",
        37: "exp-down",
        38: "power-up",
        39: "exp-up",
        40: "power-down",
        90: "pick-up"
    },
    keyNames: {
        87: "w",
        65: "a",
        83: "s",
        68: "d",
        16: "Shift",
        70: "f",
        13: "Enter",
        8: "Backspace",
        82: "r",
        79: "o",
        81: "q",
        69: "e",
        32: "Space",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        90: "z"
    },
    material: 0,
    abridged: !0,
    audio: 2
};
let o;
try {
    if (null === (o = JSON.parse(localStorage.getItem("[yesnt] options"))) || "object" != typeof o)
        throw new Error
} catch (t) {
    o = JSON.parse(JSON.stringify(a))
}
function s() {
    localStorage.setItem("[yesnt] options", JSON.stringify(o))
}
Object.keys(a).filter(t=>{
    if (!o.hasOwnProperty(t))
        return o[t] = a[t],
        !0
}
).length && s();
const c = {
    intro1: ["My plan to escape: While the instructor isn’t looking,", "./sounds/intro1.mp3"],
    intro2: ["I sneak out my phone and decode the passcode on the secret Admin broadcast.", "./sounds/intro2.mp3"],
    intro3: ["I then get up and try the code on all the doors until it works.", "./sounds/intro3.mp3"],
    intro: ["Anyone remember the first one we do, the breathing?", "./sounds/tts/Anyone-remember-the-first-one-we-do-the-breathing-.mp3"],
    introStraw: ["We’ll do the straw breath five times.", "./sounds/tts/We-ll-do-the-straw-breath-five-times-.mp3"],
    introExpansion1: ["And then we’ll do the expansion breath.", "./sounds/tts/And-then-we-ll-do-the-expansion-breath-.mp3"],
    introExpansion2: ["This one, using both of our arms.", "./sounds/tts/This-one-using-both-of-our-arms-.mp3"],
    introExpansion3: ["So breathe in for six, hold for four, breathe out for six, and hold for two.", "./sounds/tts/So-breathe-in-for-six-hold-for-four-breathe-out-for-six-and-hold-for-two-.mp3"],
    introExpansion4: ["We use victory breath for that.", "./sounds/tts/We-use-victory-breath-for-that-.mp3"],
    introPower1: ["And then we’ll do the power breath.", "./sounds/tts/And-then-we-ll-do-the-power-breath-.mp3"],
    introPower2: ["Three rounds of fifteen times each.", "./sounds/tts/Three-rounds-of-fifteen-times-each-.mp3"],
    introOm: ["And then we say the OM sound three times", "./sounds/tts/And-then-we-say-the-OM-sound-three-times.mp3"],
    introSohum1: ["And then I play the audio.", "./sounds/tts/And-then-I-play-the-audio-.mp3"],
    introSohum2: ["The audio has two sounds: when you hear SO you inhale normally, when you hear HUM you exhale normally.", "./sounds/tts/The-audio-has-two-sounds-when-you-hear-SO-you-inhale-normally-when-you-hear-HUM-you-exhale-normally-.mp3"],
    introSohum3: ["The whole breathing thing happens for just about ten to twelve minutes maximum,", "./sounds/tts/The-whole-breathing-thing-happens-for-just-about-ten-to-twelve-minutes-maximum-.mp3"],
    introSohum4: ["and after that you get to lie down and rest for the rest of the period.", "./sounds/tts/and-after-that-you-get-to-lie-down-and-rest-for-the-rest-of-the-period-.mp3"],
    introStagger: ["I invite you to stagger front and back so you can move your arms comfortably without hitting your neighbors.", "./sounds/tts/I-invite-you-to-stagger-front-and-back-so-you-can-move-your-arms-comfortably-without-hitting-your-neighbors-.mp3"],
    introThreat1: ["And gentle reminder, you know if you are disruptive, if you are not participating,", "./sounds/tts/And-gentle-reminder-you-know-if-you-are-disruptive-if-you-are-not-participating-.mp3"],
    introThreat2: ["then I will just ask your teacher to remove you.", "./sounds/tts/then-I-will-just-ask-your-teacher-to-remove-you-.mp3"],
    eyesClosed: ["Alright, so eyes closed from this point on.", "./sounds/tts/Alright-so-eyes-closed-from-this-point-on-.mp3"],
    straw1: ["Let’s start with five straw breaths,", "./sounds/tts/Let-s-start-with-five-straw-breaths-.mp3"],
    straw2: ["Let’s do that four more times,", "./sounds/tts/Let-s-do-that-four-more-times-.mp3"],
    straw: ["breathing in through the nose, out through the pretend straw in your mouth.", "./sounds/tts/breathing-in-through-the-nose-out-through-the-pretend-straw-in-your-mouth-.mp3"],
    strawUseless: ["Keep your attention inward, don’t distract your mind.", "./sounds/tts/Keep-your-attention-inward-don-t-distract-your-mind-.mp3"],
    straw3: ["Deep breath in, and exhale through the pretend straw.", "./sounds/tts/Deep-breath-in-and-exhale-through-the-pretend-straw-.mp3"],
    straw4: ["One more time.", "./sounds/tts/One-more-time-.mp3"],
    strawClosing: ["Center yourself, relax your shoulders, relax your neck.", "./sounds/tts/Center-yourself-relax-your-shoulders-relax-your-neck-.mp3"],
    expansionOpening: ["Hands by your side for the expansion breath.", "./sounds/tts/Hands-by-your-side-for-the-expansion-breath-.mp3"],
    normalBreath: ["Let’s take a normal breath in, and breathe out.", "./sounds/tts/Let-s-take-a-normal-breath-in-and-breathe-out-.mp3"],
    expansionInstruct: ["Using victory breath from the back of the throat,", "./sounds/tts/Using-victory-breath-from-the-back-of-the-throat-.mp3"],
    expansionArmsUp: ["breathe in, arms come up slowly, activate your vagus nerve,", "./sounds/tts/breathe-in-arms-come-up-slowly-activate-your-vagus-nerve-.mp3"],
    expansionArmsDown: ["breathe out using victory, arms come down slowly", "./sounds/tts/breathe-out-using-victory-arms-come-down-slowly.mp3"],
    breatheIn: ["breathe in,", "./sounds/tts/breathe-in-comma.mp3"],
    breatheOut: ["breathe out,", "./sounds/tts/breathe-out-.mp3"],
    holdBreath: ["hold your breath,", "./sounds/tts/hold-your-breath-.mp3"],
    hold: ["hold,", "./sounds/tts/hold-.mp3"],
    two: ["two,", "./sounds/tts/two-.mp3"],
    three: ["three,", "./sounds/tts/three-.mp3"],
    four: ["four,", "./sounds/tts/four-.mp3"],
    five: ["five,", "./sounds/tts/five-.mp3"],
    six: ["six,", "./sounds/tts/six-.mp3"],
    relaxLong: ["Relax your hands on your lap, palms facing the ceiling.", "./sounds/tts/Relax-your-hands-on-your-lap-palms-facing-the-ceiling-.mp3"],
    relaxShort: ["Relax your hands.", "./sounds/tts/Relax-your-hands-.mp3"],
    powerKleenex1: ["Raise your hand if you need Kleenex® before we start power breath.", "./sounds/tts/Raise-your-hand-if-you-need-Kleenex-before-we-start-power-breath-.mp3"],
    powerKleenex2: ["Second round, power breath, raise your hand if you need Kleenex®.", "./sounds/tts/Second-round-power-breath-raise-your-hand-if-you-need-Kleenex-.mp3"],
    powerKleenex3: ["Raise your hand if you need Kleenex®.", "./sounds/tts/Raise-your-hand-if-you-need-Kleenex-.mp3"],
    powerLastRound: ["Last round of power breath, hands in position.", "./sounds/tts/Last-round-of-power-breath-hands-in-position-.mp3"],
    powerOpening: ["And loose fists by your shoulders, elbows by your body.", "./sounds/tts/And-loose-fists-by-your-shoulders-elbows-by-your-body-.mp3"],
    powerStart: ["Take a normal breath in, and breathe out, and together:", "./sounds/tts/Take-a-normal-breath-in-and-breathe-out-and-together-.mp3"],
    up: ["up,", "./sounds/tts/up-.mp3"],
    down: ["down,", "./sounds/tts/down-.mp3"],
    powerClosing: ["Let’s take a deep breath in, as we breathe out let’s relax our breath, relax our whole body.", "./sounds/tts/Let-s-take-a-deep-breath-in-as-we-breathe-out-let-s-relax-our-breath-relax-our-whole-body-.mp3"],
    omOpening: ["Let’s take a deep breath in for the OM sound.", "./sounds/tts/Let-s-take-a-deep-breath-in-for-the-om-sound-.mp3"],
    om: ["Ommm...", null],
    omBreathe: ["Breathe in.", "./sounds/tts/breathe-in-.mp3"],
    stopRunning: ["Stop! Your vagus nerve is not fully activated!", "./sounds/tts/Stop-Your-vagus-nerve-is-not-fully-activated-.mp3"]
}
  , h = void 0 !== window.speechSynthesis.onvoiceschanged && "false" !== i.get("use-tts") && o.audio >= 1
  , l = i.get("fast-guess") ? 5 : 70
  , u = "false" !== i.get("load-audio") && 2 === o.audio;
let p, d, f;
function m(t) {
    let e = null
      , i = null;
    return t.onEnded = function() {
        e && e(),
        this.isPlaying = !1
    }
    ,
    {
        speak: (n,r=null)=>new Promise(async(a,o)=>{
            let s;
            const f = new Promise(t=>s = window.requestAnimationFrame(t));
            i = (()=>{
                window.cancelAnimationFrame(s),
                a(!0)
            }
            ),
            await f,
            i = null;
            const m = c[n];
            if (!m)
                return o("Line doesn't exist.");
            if (m[1] && u)
                t.setBuffer(m[1]),
                t.play(),
                r || (e = (()=>a())),
                i = (()=>t.stop());
            else if (h) {
                const t = d(m[0]);
                r || (t.onend = (()=>a())),
                i = (()=>window.speechSynthesis.cancel())
            } else
                r || (r = m[0].length * l);
            p.textContent = m[0];
            const g = i;
            if (r) {
                const t = setTimeout(()=>a(), r);
                i = (()=>{
                    g && g(),
                    clearTimeout(t),
                    a(!0)
                }
                )
            } else
                i = (()=>{
                    g && g(),
                    a(!0)
                }
                )
        }
        ).then(t=>(p.textContent = "",
        e = null,
        i = null,
        !t)),
        interrupt: ()=>{
            i && i()
        }
    }
}
h && (f = new Promise(async t=>{
    let e = window.speechSynthesis.getVoices();
    e.length || (await new Promise(t=>{
        window.speechSynthesis.addEventListener("voiceschanged", t, {
            once: !0
        })
    }
    ),
    e = window.speechSynthesis.getVoices());
    const i = e.find(t=>t.lang.includes("IN")) || e[0];
    d = (t=>{
        window.speechSynthesis.cancel();
        const e = new SpeechSynthesisUtterance(t);
        return e.voice = i,
        window.speechSynthesis.speak(e),
        e
    }
    ),
    t()
}
));
const g = 10
  , v = 20
  , y = 5
  , x = -450
  , b = [13207608, 12537165, 12537165, 12537165, 12282488, 4665448, 3620463];
function w(t, e) {
    const i = new THREE.Mesh(new THREE.BoxBufferGeometry(g,.4,v),Oe(b[Math.floor(Math.random() * b.length)], 0, .9, .5));
    return i.position.set(t, 0, e),
    i
}
let M, _, S;
function T(t=M) {
    const e = new THREE.Group
      , i = new THREE.Mesh(new THREE.BoxBufferGeometry(8.5,4.5,1),Oe(13421772, 0, .1, .1));
    e.add(i);
    const n = new THREE.Mesh(new THREE.PlaneBufferGeometry(8,4),new THREE.MeshBasicMaterial({
        map: t,
        transparent: !0
    }));
    return n.position.z = .55,
    e.add(n),
    e
}
function E() {
    const t = new THREE.Group
      , e = new THREE.Mesh(new THREE.BoxBufferGeometry(14,24,1),Oe(8420473, 0, .3, .9));
    e.position.set(7, 12, 0),
    t.add(e);
    const i = new THREE.Mesh(new THREE.BoxBufferGeometry(12,1,2),Oe(12960191, 0, .3, .9));
    return i.position.set(7, 12, 0),
    t.add(i),
    t
}
function A(t={
    type: "no code"
}, e=M) {
    const i = new THREE.Group;
    if (i.isDoors = !0,
    i.metadata = t,
    null !== e) {
        const t = T(e);
        t.position.y = 30,
        i.add(t)
    }
    const n = E();
    n.position.x = -14,
    i.left = n,
    i.add(n);
    const r = E();
    return r.rotation.y = Math.PI,
    r.position.x = 14,
    i.right = r,
    i.add(r),
    i
}
function L(t={
    type: "no code"
}, e=M) {
    const i = new THREE.Group;
    if (i.isDoors = !0,
    i.metadata = t,
    e) {
        const t = T(e);
        t.position.y = 30,
        i.add(t)
    }
    const n = E();
    return n.position.x = -7,
    i.add(n),
    i
}
const P = [];
const C = 30
  , I = 100
  , R = 500;
const O = .5
  , D = .1
  , z = .7
  , B = 2;
function N(t, e, i=0, n=16777215) {
    const r = new THREE.Group;
    if (i) {
        const t = new THREE.Mesh(new THREE.BoxBufferGeometry(z,i,z),Oe(n, 0, .9, .5));
        t.position.set(0, i / 2 - D, 0),
        r.add(t)
    }
    const a = new THREE.Mesh(new THREE.BoxBufferGeometry(O,t,O),Oe(e, 0, .9, .5));
    a.position.set(0, t / 2, 0),
    r.add(a);
    const o = new THREE.BoxBufferGeometry(O,t,O);
    o.applyMatrix((new THREE.Matrix4).makeTranslation(0, t / 2, 0));
    const s = new THREE.Mesh(o,Oe(e, 0, .9, .5));
    s.position.set(0, t - O / 2, 0),
    r.add(s),
    r.idealRot = new THREE.Euler,
    s.idealRot = new THREE.Euler;
    const c = {
        limb: r,
        forearm: s,
        setPos: (...t)=>(r.position.set(...t),
        c)
    };
    return c
}
function k(t) {
    t.limb.rotation.x = -Math.PI / 2 - .3,
    t.forearm.rotation.x = Math.PI + .3
}
function U(t, e, i=2.5, n=!0, r=15658734, a=3355443) {
    const o = new THREE.Group
      , s = new THREE.Group
      , c = new THREE.Mesh(new THREE.BoxBufferGeometry(2.5,2.5,2.5),Oe(t, 0, .9, .5));
    s.add(c);
    const h = new THREE.Mesh(new THREE.BoxBufferGeometry(2.7,i,2.6),Oe(e, 0, .9, .5));
    h.position.set(0, 1.35 - i / 2, .1),
    s.add(h);
    let l = null;
    if (n) {
        l = new THREE.MeshBasicMaterial({
            transparent: !0
        });
        const t = new THREE.Mesh(new THREE.PlaneBufferGeometry(2.5,2.5),l);
        t.position.set(0, 0, -1.26),
        t.rotation.y = Math.PI,
        s.add(t)
    }
    s.position.set(0, 11, 0),
    o.add(s);
    const u = new THREE.Mesh(new THREE.BoxBufferGeometry(3,4,1),Oe(r, 0, .9, .5));
    u.position.set(0, 8, 0),
    o.add(u);
    const p = [N(2.5, t, 1, r).setPos(-1.8, 9.8, 0), N(2.5, t, 1, r).setPos(1.8, 9.8, 0), N(3, t, 2, a).setPos(-1, 6, 0), N(3, t, 2, a).setPos(1, 6, 0)];
    return p.forEach(t=>{
        t.limb.rotation.x = Math.PI,
        o.add(t.limb)
    }
    ),
    o.isPerson = !0,
    {
        person: o,
        limbs: p,
        head: s,
        face: l
    }
}
function F(t) {
    return Math.sin(t * Math.PI / 2)
}
function G() {
    const t = 6 * Math.random() - 3;
    return 65536 * Math.floor(224.3 + 9.6 * t) + 256 * Math.floor(193.1 + 17 * t) + Math.floor(177.6 + 21 * t)
}
function V() {
    const t = 2 * -Math.random() - 1.6768;
    return 65536 * Math.floor(168.8 + 38.5 * t) + 256 * Math.floor(122.5 + 32.1 * t) + Math.floor(96.7 + 26.3 * t)
}
const j = 500;
function H(t, e) {
    e(t.limbs[0].limb, 0),
    e(t.limbs[0].forearm, 1),
    e(t.limbs[1].limb, 2),
    e(t.limbs[1].forearm, 3)
}
const W = [[Math.PI, 0, 0], [0, 0, .1], [Math.PI, 0, 0], [0, 0, -.1]]
  , X = [[Math.PI, 0, .1], [0, 0, .1], [Math.PI, 0, -.1], [0, 0, -.1]]
  , q = [[Math.PI + .3, Math.PI / 2, 0], [Math.PI / 9, 0, Math.PI / 10], [Math.PI + .3, -Math.PI / 2, 0], [Math.PI / 9, 0, -Math.PI / 10]]
  , Y = [[0, 0, 2 * Math.PI / 3], [0, 0, 2 * Math.PI / 3], [0, 0, 2 * -Math.PI / 3], [0, 0, 2 * -Math.PI / 3]]
  , J = [[5 * Math.PI / 4, Math.PI / 2, 0], [Math.PI / 4, 0, .2 * Math.PI], [5 * Math.PI / 4, -Math.PI / 2, 0], [Math.PI / 4, 0, .2 * -Math.PI]]
  , Z = [[Math.PI, 0, .2], [0, 0, Math.PI - .4], [Math.PI, 0, -.2], [0, 0, .4 - Math.PI]]
  , Q = [[Math.PI, 0, Math.PI], [0, 0, 0], [Math.PI, 0, -Math.PI], [0, 0, 0]];
function K(t, e=!0, i=W) {
    H(t, (t,n)=>{
        e && (t.origRot = t.rotation.clone()),
        t.idealRot.set(...i[n])
    }
    ),
    i === q && (t.mode = "rest"),
    e && (t.rotationTransition = Date.now())
}
function $(t) {
    if (t.rotationTransition) {
        const e = (Date.now() - t.rotationTransition) / j;
        if (e < 1) {
            const i = Fi(e);
            H(t, t=>{
                t.rotation.x = i * (t.idealRot.x - t.origRot.x) + t.origRot.x,
                t.rotation.y = i * (t.idealRot.y - t.origRot.y) + t.origRot.y,
                t.rotation.z = i * (t.idealRot.z - t.origRot.z) + t.origRot.z
            }
            )
        } else
            t.rotationTransition = null
    } else
        H(t, t=>{
            t.rotation.copy(t.idealRot)
        }
        )
}
function tt(t, e) {
    const i = Math.max((e - t.delay) / 1e3, 0);
    i < 6 ? (t.limbs[0].limb.idealRot.z = F(i / 6) * (Math.PI - .2) + .1,
    t.limbs[1].limb.idealRot.z = -F(i / 6) * (Math.PI - .2) - .1) : (t.limbs[0].limb.idealRot.z = Math.PI - .1,
    t.limbs[1].limb.idealRot.z = .1 - Math.PI)
}
function et(t, e) {
    const i = Math.max((e - t.delay) / 1e3, 0);
    i < 6 ? (t.limbs[0].limb.idealRot.z = (1 - F(i / 6)) * (Math.PI - .2) + .1,
    t.limbs[1].limb.idealRot.z = -(1 - F(i / 6)) * (Math.PI - .2) - .1) : (t.limbs[0].limb.idealRot.z = .1,
    t.limbs[1].limb.idealRot.z = -.1)
}
let it, nt, rt;
let at, ot = !1, st = null;
const ct = 6
  , ht = 11
  , lt = .05
  , ut = 1
  , pt = -500 + ut
  , dt = 500 - ut
  , ft = -500 + ut
  , mt = 500 - ut
  , gt = 2.5 + ut
  , vt = 1.75 + ut
  , yt = 2.75 + ut
  , xt = .04
  , bt = 5e-4
  , wt = 1200
  , Mt = 3250
  , _t = 1 / 0
  , St = 450
  , Tt = 300
  , Et = 200
  , At = +i.get("INHALE_OXYGEN_SPEED") || .3
  , Lt = +i.get("BREATHING_SPEED") || 1e-5
  , Pt = +i.get("BREATHING_BOOST_SPEED") || .003
  , Ct = +i.get("MAX_OXYGEN") || 1
  , It = +i.get("LUNG_RANGE") || 1
  , Rt = +i.get("LIVING_OXYGEN_USAGE") || 3e-5
  , Ot = +i.get("RUNNING_OXYGEN_USAGE") || 1e-4
  , Dt = +i.get("LOW_OXYGEN") || .4
  , zt = +i.get("ASPHYXIATION") || .1
  , Bt = 4
  , Nt = 5e3;
let kt, Ut, Ft, Gt, Vt, jt, Ht, Wt, Xt;
try {
    if (null === (kt = JSON.parse(localStorage.getItem("[yesnt] stats"))) || "object" != typeof kt)
        throw new Error
} catch (t) {
    kt = JSON.parse(JSON.stringify({
        attempts: 0,
        runDistance: 0,
        breaths: 0,
        powerBreaths: 0,
        expansionBreaths: 0,
        time: 0,
        checks: 0,
        fails: 0,
        codeEntries: 0,
        escapes: 0,
        abridgedCompletions: 0,
        completions: 0
    }))
}
const qt = /[^A-Z0-9]/i
  , Yt = /^(https?):\/\/[\-A-Za-z0-9+&@#\/%?=~_|!:,.;]*[\-A-Za-z0-9+&@#\/%=~_|]$/;
function Jt([t,e]) {
    const i = document.createElement("div");
    i.classList.add("stat-row");
    const n = document.createElement("div");
    n.classList.add("stat-label"),
    n.textContent = t,
    i.appendChild(n);
    const r = document.createElement("div");
    return r.classList.add("stat-value"),
    r.textContent = e,
    i.appendChild(r),
    i
}
function Zt() {
    const t = Math.floor(Ut.duration / 6e4) + ":" + (Ut.duration / 1e3).toFixed(3).padStart(6, "0");
    Ft.innerHTML = "",
    "escape" === Ut.winMode ? [["Time taken", t], ["Breaths taken", Ut.breaths], ["Distance run", Ut.runDistance.toFixed(2)], ["Codes entered", Ut.codeEntries]].forEach(t=>Ft.appendChild(Jt(t))) : [["Time taken", t], ["Breaths taken", Ut.breaths], ["Power breaths", Ut.powerBreaths], ["Expansion breaths", Ut.expansionBreaths], ["Accuracy", (100 * Ut.accuracy).toFixed(2) + "%"]].forEach(t=>Ft.appendChild(Jt(t)))
}
function Qt() {
    const t = Math.floor(kt.time / 36e5) + ":" + (Math.floor(kt.time / 6e4 % 60) + "").padStart(2, "0") + ":" + (kt.time / 1e3).toFixed(3).padStart(6, "0")
      , e = kt.checks ? (100 * (1 - kt.fails / kt.checks)).toFixed(2) + "%" : "--";
    Gt.innerHTML = "",
    [["Attempts", kt.attempts], ["Escapes", kt.escapes], ["Completions", kt.completions], ["Abridged completions", kt.abridgedCompletions], ["Time played", t], ["Breaths taken", kt.breaths], ["Power breaths", kt.powerBreaths], ["Expansion breaths", kt.expansionBreaths], ["YES program accuracy", e], ["Distance run", kt.runDistance.toFixed(2)], ["Codes entered", kt.codeEntries]].forEach(t=>Gt.appendChild(Jt(t)))
}
function Kt(t, e, i) {
    Xt.innerHTML = "";
    const n = {};
    e.forEach(([t,e,i])=>{
        const r = document.createElement("div");
        r.classList.add("column"),
        Xt.appendChild(r),
        n[t] = r;
        const a = document.createElement("span");
        a.classList.add("leaderboard-entry"),
        a.classList.add("heading"),
        a.textContent = e,
        a.title = i,
        r.appendChild(a)
    }
    );
    let r = !1;
    if (t.slice(0, 10).forEach((t,a)=>{
        e.forEach(([e])=>{
            const o = document.createElement("name" === e ? "a" : "span");
            o.classList.add("leaderboard-entry"),
            t.id === i && (o.classList.add("mine"),
            r = !0),
            "name" === e ? (o.classList.add("entry-name"),
            t.url && (o.href = t.url,
            o.setAttribute("target", "_blank"),
            o.setAttribute("rel", "noopener noreferrer"))) : o.classList.add("entry-data"),
            o.textContent = "accuracy" === e ? (100 * t.accuracy).toFixed(2) + "%" : "distance" === e ? t.distance.toFixed(2) : "duration" === e ? (t.duration / 1e3).toFixed(3) : "index" === e ? a + 1 : t[e],
            n[e].appendChild(o)
        }
        )
    }
    ),
    !r) {
        const r = t.findIndex(t=>t.id === i);
        if (!~r)
            return "okn't";
        const a = t[r];
        e.forEach(([t])=>{
            const e = document.createElement("span");
            e.classList.add("leaderboard-entry"),
            e.classList.add("ellipsis"),
            n[t].appendChild(e);
            const i = document.createElement("name" === t ? "a" : "span");
            i.classList.add("leaderboard-entry"),
            i.classList.add("mine"),
            "name" === t ? (i.classList.add("entry-name"),
            a.url && (i.href = a.url,
            i.setAttribute("target", "_blank"),
            i.setAttribute("rel", "noopener noreferrer"))) : i.classList.add("entry-data"),
            i.textContent = "accuracy" === t ? (100 * a.accuracy).toFixed(2) + "%" : "index" === t ? r + 1 : a[t],
            n[t].appendChild(i)
        }
        )
    }
    return "ok"
}
const $t = {
    left: [-500 + C + ut, -500 + C + I - ut],
    right: [500 - C - I + ut, 500 - C - ut]
}
  , te = mt + R - ut
  , ee = "false" !== i.get("shaders") && 2 !== o.material
  , ie = "please" !== i.get("freeze-instructor")
  , ne = !i.get("override-player-check")
  , re = "omniscient" === i.get("override-player-check")
  , ae = "true" !== i.get("unrealistic-breathing")
  , oe = i.get("abridged") || (o.abridged ? "some" : null)
  , se = "some" === oe ? 10 : "very" === oe ? 2 : 15
  , ce = "very" === oe ? 1 : 3
  , he = new THREE.PerspectiveCamera(o.fov,window.innerWidth / window.innerHeight,.1,1e3);
he.rotation.order = "YXZ";
const le = "0123456789"
  , ue = "零壹貳贰叄叁肆伍陸陆柒捌玖拾佰仟萬億"
  , pe = "０１２３４５６７８９";
function de(t=!1) {
    if (oi && clearInterval(oi),
    Ge.isPlaying && Ge.stop(),
    ke() && (Ne(),
    Ye(it),
    Xe.face.map = it),
    Xe.head.rotation.set(0, 0, 0),
    Xe.person.rotation.y = Math.PI,
    Xe.person.position.x = 0,
    Xe.person.position.z = -475,
    Xe.limbs[0].limb.rotation.x = Xe.limbs[1].limb.rotation.x = Math.PI,
    Xe.limbs[0].forearm.rotation.x = Xe.limbs[1].forearm.rotation.x = 0,
    Xe.limbs[2].limb.rotation.x = Math.PI,
    Xe.limbs[3].limb.rotation.x = Math.PI,
    Xe.limbs[2].forearm.rotation.x = 0,
    Xe.limbs[3].forearm.rotation.x = 0,
    t || (he.position.set(0, ct, x - .7),
    he.rotation.set(0, 0, 0),
    Pi.set(he.rotation.y),
    De.add(ti.person),
    tn.push({
        type: "start",
        start: Date.now(),
        duration: 1e3
    }),
    Ki = "sitting",
    document.body.classList.remove("hide-pose"),
    document.body.classList.remove("escaped"),
    document.body.classList.remove("completed")),
    Ze.needsDown = !1,
    Ze.phoneOut && ni(!1),
    Ze.canDie = !1,
    K(ti, !1, q),
    Qe("rest"),
    Ze.canBreathe && $e(!1),
    Ze.canAsphyxiate = !0,
    _i.children.length && Ve.get(_i.children[0]).add(_i.children[0]),
    at([]),
    Ni(!0),
    fi && (fi.remove(ui),
    fi = null),
    t)
        return;
    document.body.classList.contains("hide-dev") && (Ht.classList.add("hidden"),
    Wt.disabled = !1),
    ai = "";
    const e = le.split("")
      , n = ue.split("")
      , r = new Map;
    let a;
    for (a = 0; a < le.length; a++) {
        const t = Math.floor(Math.random() * (10 - a))
          , i = Math.floor(Math.random() * (10 - a));
        a < Bt && (ai += e[t]),
        r.set(e[t], n[i]),
        e[t] = e[e.length - 1 - a],
        n[i] = n[n.length - 1 - a]
    }
    let o = 0;
    oi = setInterval(()=>{
        if (ri.fillStyle = "#666",
        ri.fillRect(0, 30, 128, 226),
        ri.fillStyle = "black",
        o % 16 > 11)
            ri.font = "64px monospace",
            ri.fillText(r.get(ai[0]), 0, 90),
            ri.fillText(r.get(ai[1]), 64, 180),
            ri.fillText(r.get(ai[2]), 0, 180),
            ri.fillText(r.get(ai[3]), 64, 90);
        else if (o % 16 == 11)
            ri.font = "64px monospace",
            ri.fillText(pe[0], 0, 90),
            ri.fillText(pe[1], 64, 180),
            ri.fillText(pe[2], 0, 180),
            ri.fillText(pe[3], 64, 90);
        else if (o % 16 == 10) {
            ri.font = "32px monospace";
            for (let t = 0; t < 4; t++)
                ri.strokeRect(32 * t + 2, 50, 28, 50),
                ri.fillText("#", 32 * t + 5, 90),
                ri.fillText(pe[t], 32 * t, 130);
            ri.font = "16px monospace",
            ri.fillText("Symbols not in", 0, 160),
            ri.fillText("Chinese! -L.M.", 0, 180)
        } else {
            const t = o % 16 + "";
            ri.font = "44px monospace",
            ri.fillText(r.get(t) + "＝" + pe[t], 0, 90)
        }
        o++,
        ei.update()
    }
    , 500),
    Fe.forEach(t=>{
        t.wrong = !1
    }
    ),
    si = "true" === i.get("one-door-only")
}
let fe = null;
const me = "expansion" === i.get("skip-to") ? ["expansionOpening"] : ["straw1", "straw", "straw2", "straw", "strawUseless", "straw3", "straw4", "strawClosing", "expansionOpening", "normalBreath", "expansionInstruct"]
  , ge = "power" === i.get("skip-to") || "om" === i.get("skip-to")
  , ve = "om" === i.get("skip-to")
  , ye = "true" === i.get("skip-eyes-closed");
let xe, be = null;
async function we() {
    if (fe)
        throw new Error("A game is still ongoing it seems.");
    Ut = {
        startTime: Date.now(),
        runDistance: 0,
        breaths: 0,
        powerBreaths: 0,
        expansionBreaths: 0,
        checks: 0,
        fails: 0,
        codeEntries: 0
    };
    const {speak: t, interrupt: e} = m(qe);
    let i = !1
      , n = !1
      , r = !1
      , a = {
        type: "instructor-start-walking",
        duration: 500,
        ended: !1
    };
    fe = (o=>{
        if ("getting up" === o ? (n = !0,
        r && t("stopRunning")) : "caught" === o && (n = i = !0),
        e(),
        !a.ended) {
            const t = tn.indexOf(a);
            ~t && tn.splice(t, 1),
            Xe.walkOffsetTime = Date.now()
        }
    }
    ),
    ye || await t("eyesClosed"),
    n || (a.start = Date.now(),
    tn.push(a));
    const o = new THREE.Audio(Me);
    if (o.setBuffer(Ce.lights),
    o.play(),
    Ne(),
    Ye(nt),
    Xe.face.map = rt,
    Ze.canDie = !0,
    $e(!0),
    at(["get-up", "phone", "arms"]),
    Bi("phone"),
    Bi("get-up"),
    !ge) {
        for (const e of me) {
            if (n)
                break;
            "expansionOpening" === e && (be = {
                type: "expansion-ready"
            },
            Bi("expansion")),
            await t(e)
        }
        n || (be = {
            type: "expansion",
            mode: "up",
            start: Date.now(),
            first: !0
        },
        await t("expansionArmsUp", 4e3) && await t("five", 1e3) && await t("six", 1e3) && await t("holdBreath", 2e3) && await t("three", 1e3) && await t("four", 1e3) && (be = {
            type: "expansion",
            mode: "down",
            start: Date.now()
        }) && await t("expansionArmsDown", 4e3) && await t("five", 1e3) && await t("six", 1e3) && await t("holdBreath", 2e3));
        const e = "some" === oe ? 1 : "very" === oe ? 0 : 3;
        for (let i = 0; i < e && !n; i++)
            be = {
                type: "expansion",
                mode: "up",
                start: Date.now()
            },
            await t("breatheIn", 1e3) && await t("two", 1e3) && await t("three", 1e3) && await t("four", 1e3) && await t("five", 1e3) && await t("six", 1e3) && await t("hold", 1e3) && await t("two", 1e3) && await t("three", 1e3) && await t("four", 1e3) && (be = {
                type: "expansion",
                mode: "down",
                start: Date.now()
            }) && await t("breatheOut", 1e3) && await t("two", 1e3) && await t("three", 1e3) && await t("four", 1e3) && await t("five", 1e3) && await t("six", 1e3) && await t("hold", 1e3) && await t("two", 1e3);
        for (let i = 0; i < e && !n; i++)
            be = {
                type: "expansion",
                mode: "up",
                start: Date.now()
            },
            await t("breatheIn", 6e3) && await t("hold", 4e3) && (be = {
                type: "expansion",
                mode: "down",
                start: Date.now()
            }) && await t("breatheOut", 6e3) && await t("hold", 2e3);
        be = null,
        Ni("expansion")
    }
    if (!ve) {
        async function s() {
            be = {
                type: "power-down",
                start: Date.now()
            },
            n || await t("powerStart");
            for (let e = 0; e < se && !n; e++)
                be = {
                    type: "power-up",
                    start: Date.now()
                },
                await t("up", 800) && (be = {
                    type: "power-down",
                    start: Date.now()
                }) && await t("down", 800);
            be = null
        }
        n || await t("relaxLong") && await t("powerKleenex1") && (Bi("power"),
        await t("powerOpening")),
        await s(),
        n || await t("relaxShort") && await t("powerKleenex2"),
        await s(),
        n || await t("relaxShort") && await t("powerLastRound"),
        await s(),
        n || await t("relaxShort") && await t("powerClosing") && await t("powerKleenex3") && await t("omOpening"),
        Ni("power")
    }
    for (let e = 0; e < ce && !n; e++)
        e > 0 && await t("omBreathe"),
        n || (tn.push({
            type: "intense-om",
            start: Date.now(),
            duration: 3e3,
            anchorY: he.position.y
        }),
        await t("om", 3e3));
    n ? i || await t("stopRunning") : (oe ? (kt.abridgedCompletions++,
    Ut.winMode = "abridged") : (kt.completions++,
    Ut.winMode = "complete"),
    Vi(),
    Zt(),
    Xe.moving = !0,
    await new Promise(t=>{
        const e = Xe.person.position.clone()
          , i = Ge.parent.position.clone().setZ(-490);
        tn.push({
            type: "run-to-cassette",
            start: Date.now(),
            duration: e.distanceTo(i) / xt,
            done: t,
            startPos: e,
            dest: i,
            initCamRot: he.rotation.clone()
        })
    }
    ),
    Xe.moving = !1,
    Xe.limbs[2].limb.rotation.x = Math.PI,
    Xe.limbs[3].limb.rotation.x = Math.PI,
    Xe.limbs[2].forearm.rotation.x = 0,
    Xe.limbs[3].forearm.rotation.x = 0,
    Ge.play(),
    r = !0,
    document.body.classList.remove("hide-end"),
    document.body.classList.add("completed"),
    document.exitPointerLock()),
    fe = null
}
const Me = new THREE.AudioListener;
he.add(Me),
THREE.Cache.enabled = !0;
i.get("log-loading");
const _e = new THREE.LoadingManager
  , Se = new Promise(t=>_e.onLoad = t);
let Te;
_e.onProgress = ((t,e,i)=>{
    Te && (Te.style.width = e / i * 100 + "%")
}
);
const Ee = new THREE.TextureLoader(_e)
  , Ae = new THREE.ObjectLoader(_e)
  , Le = new THREE.AudioLoader(_e);
function Pe(t) {
    const e = Ee.load(t);
    return e.magFilter = THREE.NearestFilter,
    e.minFilter = THREE.NearestFilter,
    e
}
const Ce = {};
Le.load("./sounds/lights-sound.mp3", t=>Ce.lights = t),
Le.load("./sounds/floor-creak.mp3", t=>Ce.creak = t),
Le.load("./sounds/keypress.mp3", t=>Ce.keypress = t),
Le.load("./sounds/wrong.mp3", t=>Ce.wrong = t),
Le.load("./sounds/correct.mp3", t=>Ce.correct = t),
Le.load("./sounds/caught.mp3", t=>Ce.caught = t);
const Ie = "true" === i.get("lambert") || 1 === o.material
  , Re = "true" === i.get("wireframe")
  , Oe = "true" === i.get("emissive") || 2 === o.material ? (t,e)=>new THREE.MeshBasicMaterial({
    color: e || t,
    wireframe: Re
}) : Ie ? (t,e)=>new THREE.MeshLambertMaterial({
    color: t,
    emissive: e,
    wireframe: Re
}) : (t,e,i,n)=>new THREE.MeshStandardMaterial({
    color: t,
    emissive: e,
    roughness: i,
    metalness: n,
    wireframe: Re
})
  , De = new THREE.Scene;
De.add(he);
const ze = []
  , Be = []
  , {swap: Ne, isDark: ke, darkPhongFloor: Ue, doors: Fe, cassette: Ge, lights: Ve, outsideLight: je, entranceDoors: He} = function(t, e, i) {
    S = Oe(16777215, 0, .9, .1),
    M = Pe("./textures/exit.png"),
    _ = Pe("./textures/exit-green.png");
    const n = new THREE.Mesh(new THREE.PlaneBufferGeometry(1e3,1e3),Oe(15844238, 0, .6, .2));
    let r;
    n.rotation.x = -Math.PI / 2,
    t.add(n),
    Ie && ((r = new THREE.Mesh(new THREE.PlaneBufferGeometry(100,100),new THREE.MeshPhongMaterial({
        color: 15844238,
        shininess: 50
    }))).rotation.x = -Math.PI / 2);
    const a = new THREE.Mesh(new THREE.PlaneBufferGeometry(1e3,200),S);
    a.position.set(0, 100, -500),
    t.add(a);
    let o = !1;
    const {darkRoom: s, doors: c} = function() {
        const t = []
          , e = new THREE.Group
          , i = new THREE.Mesh(new THREE.PlaneBufferGeometry(1e3,200),S);
        i.rotation.y = Math.PI,
        i.position.set(0, 100, 500),
        e.add(i);
        const n = new THREE.Mesh(new THREE.PlaneBufferGeometry(1e3,200),S);
        n.rotation.y = Math.PI / 2,
        n.position.set(-500, 100, 0),
        e.add(n);
        const r = C
          , a = I
          , o = new THREE.Mesh(new THREE.PlaneBufferGeometry(1e3,140),S);
        o.rotation.y = -Math.PI / 2,
        o.position.set(500, 130, 0),
        e.add(o);
        const s = new THREE.Mesh(new THREE.PlaneBufferGeometry(r,60),S);
        s.rotation.y = -Math.PI / 2,
        s.position.set(500, 30, r / 2 - 500),
        e.add(s);
        const c = new THREE.Mesh(new THREE.PlaneBufferGeometry(1e3 - 2 * (r + a),60),S);
        c.rotation.y = -Math.PI / 2,
        c.position.set(500, 30, 0),
        e.add(c);
        const h = new THREE.Mesh(new THREE.PlaneBufferGeometry(r,60),S);
        h.rotation.y = -Math.PI / 2,
        h.position.set(500, 30, 500 - r / 2),
        e.add(h);
        const l = Oe(7090193, 0, .9, .1)
          , u = R;
        [-500 + r + a / 2, 500 - r - a / 2].forEach(i=>{
            const n = new THREE.Mesh(new THREE.PlaneBufferGeometry(u,60),l);
            n.position.set(500 + u / 2, 30, i - a / 2),
            e.add(n);
            const r = new THREE.Mesh(new THREE.PlaneBufferGeometry(u,60),l);
            r.rotation.y = Math.PI,
            r.position.set(500 + u / 2, 30, i + a / 2),
            e.add(r);
            const o = new THREE.Mesh(new THREE.PlaneBufferGeometry(u,a),S);
            if (o.rotation.x = Math.PI / 2,
            o.position.set(500 + u / 2, 60, i),
            e.add(o),
            !Ie) {
                const t = new THREE.Mesh(new THREE.PlaneBufferGeometry(u,a),Oe(7434870, 0, .9, .1));
                t.rotation.x = -Math.PI / 2,
                t.position.set(500 + u / 2, 0, i),
                e.add(t)
            }
            const s = new THREE.Mesh(new THREE.PlaneBufferGeometry(a,60),l);
            s.rotation.y = -Math.PI / 2,
            s.position.set(500 + u, 30, i),
            e.add(s);
            const c = T();
            c.rotation.y = -Math.PI / 2,
            c.position.set(499.9, 65, i),
            e.add(c);
            const h = A({
                type: "other door"
            });
            h.rotation.y = -Math.PI / 2,
            h.position.set(500 + u, 0, i - 15),
            e.add(h),
            t.push(h);
            const p = A({
                type: "code",
                tunnel: !0
            });
            p.rotation.y = -Math.PI / 2,
            p.position.set(500 + u, 0, i + 15),
            e.add(p),
            t.push(p)
        }
        ),
        [-280, -250, 250, 280].forEach((i,n)=>{
            const r = A({
                type: "code"
            }, 0 === n ? _ : M);
            r.rotation.y = Math.PI / 2,
            r.position.set(-500, 0, i),
            e.add(r),
            t.push(r)
        }
        );
        const p = L({
            type: "no code"
        }, null);
        p.position.set(-485, 0, -500),
        e.add(p),
        t.push(p);
        const d = L({
            type: "no code"
        }, null);
        d.rotation.y = Math.PI,
        d.position.set(-485, 0, 500),
        e.add(d),
        t.push(d);
        const f = L({
            type: "no exit"
        }, null);
        f.rotation.y = Math.PI / 2,
        f.position.set(-500, 0, 470),
        e.add(f),
        t.push(f);
        const m = L({
            type: "no exit"
        }, null);
        return m.rotation.y = Math.PI / 2,
        m.position.set(-500, 0, -470),
        e.add(m),
        t.push(m),
        {
            darkRoom: e,
            doors: t
        }
    }()
      , {lightRoom: h, entranceDoors: l} = function() {
        const t = Math.atan(20 / 300)
          , e = Math.hypot(20, 300)
          , i = new THREE.Group
          , n = new THREE.Mesh(new THREE.PlaneBufferGeometry(700,e),S);
        n.rotation.x = Math.PI / 2 - t,
        n.position.set(0, 110, -350),
        i.add(n);
        const r = new THREE.Mesh(new THREE.PlaneBufferGeometry(700,e),S);
        r.rotation.x = Math.PI / 2 + t,
        r.position.set(0, 110, -50),
        i.add(r);
        const a = new THREE.Mesh(new THREE.PlaneBufferGeometry(700,100),S);
        a.rotation.y = Math.PI,
        a.position.set(0, 50, 100),
        i.add(a);
        const o = new THREE.Mesh(new THREE.PlaneBufferGeometry(600,120),S);
        o.rotation.y = Math.PI / 2,
        o.position.set(-350, 60, -200),
        i.add(o);
        const s = new THREE.Mesh(new THREE.PlaneBufferGeometry(600,70),S);
        s.rotation.y = -Math.PI / 2,
        s.position.set(350, 85, -200),
        i.add(s);
        const c = new THREE.Mesh(new THREE.PlaneBufferGeometry(30,50),S);
        c.rotation.y = -Math.PI / 2,
        c.position.set(350, 25, -485),
        i.add(c);
        const h = new THREE.Mesh(new THREE.PlaneBufferGeometry(380,50),S);
        h.rotation.y = -Math.PI / 2,
        h.position.set(350, 25, -200),
        i.add(h);
        const l = new THREE.Mesh(new THREE.PlaneBufferGeometry(30,50),S);
        l.rotation.y = -Math.PI / 2,
        l.position.set(350, 25, 85),
        i.add(l);
        const u = Oe(16777215, 2236962, .9, .1);
        [-430, 30].forEach(t=>{
            const e = new THREE.Mesh(new THREE.PlaneBufferGeometry(150,50),u);
            e.position.set(425, 25, t - 40),
            i.add(e);
            const n = new THREE.Mesh(new THREE.PlaneBufferGeometry(150,50),u);
            n.rotation.y = Math.PI,
            n.position.set(425, 25, t + 40),
            i.add(n);
            const r = new THREE.Mesh(new THREE.PlaneBufferGeometry(150,80),u);
            r.rotation.x = Math.PI / 2,
            r.position.set(425, 50, t),
            i.add(r);
            const a = new THREE.Mesh(new THREE.PlaneBufferGeometry(80,50),u);
            a.rotation.y = -Math.PI / 2,
            a.position.set(500, 25, t),
            i.add(a);
            const o = T();
            o.rotation.y = -Math.PI / 2,
            o.position.set(349.9, 55, t),
            i.add(o);
            const s = A();
            s.rotation.y = -Math.PI / 2,
            s.position.set(500, 0, t - 15),
            i.add(s);
            const c = A();
            c.rotation.y = -Math.PI / 2,
            c.position.set(500, 0, t + 15),
            i.add(c)
        }
        ),
        Ae.load("./models/gym-light-on.json", t=>{
            t.scale.multiplyScalar(3);
            for (let e = -300; e <= 300; e += 100)
                for (let n = 50; n <= 250; n += 100) {
                    const r = t.clone();
                    r.position.set(e, 100 + 20 * (1 - n / 300), -200 + n),
                    i.add(r)
                }
        }
        ),
        Ae.load("./models/gym-light-off.json", t=>{
            t.scale.multiplyScalar(3);
            for (let e = -300; e <= 300; e += 100)
                for (let n = 50; n <= 250; n += 100) {
                    const r = t.clone();
                    r.position.set(e, 100 + 20 * (1 - n / 300), -200 - n),
                    i.add(r)
                }
        }
        );
        const p = [-130, -100, 100, 130].map((t,e)=>{
            const n = A({
                type: "code"
            }, 0 === e ? _ : M);
            return n.rotation.y = Math.PI / 2,
            n.position.set(-350, 0, -200 + t),
            i.add(n),
            n
        }
        )
          , d = L(null, null);
        d.position.set(-335, 0, -500),
        i.add(d);
        const f = L(null, null);
        f.rotation.y = Math.PI,
        f.position.set(-335, 0, 100),
        i.add(f);
        const m = L(null, null);
        m.rotation.y = Math.PI / 2,
        m.position.set(-350, 0, 70),
        i.add(m);
        const g = L(null, null);
        return g.rotation.y = Math.PI / 2,
        g.position.set(-350, 0, -470),
        i.add(g),
        {
            lightRoom: i,
            entranceDoors: p
        }
    }();
    t.add(h);
    for (let e = -10; e <= 10; e++)
        for (let i = 0; i < 6; i++) {
            const n = w(e * (g + y), x + i * (v + y));
            t.add(n),
            P.push(n)
        }
    const u = new Map
      , p = .1 + ut;
    Ae.load("./models/candle.json", n=>{
        n.scale.multiplyScalar(.5);
        const r = [[-15, -490], [-20, -490], [-25, -490]].map(([e,r])=>{
            const a = n.clone();
            a.radius = p + 2;
            const o = a.getObjectByName("flame")
              , s = new THREE.Group;
            return s.add(a),
            s.position.set(e, 0, r),
            i.push([e - p, e + p, r - p, r + p, a]),
            t.add(s),
            u.set(a, s),
            o
        }
        );
        e.push(t=>{
            r[0].intensity = .01 * Math.sin(t / 243 + 1) + .1,
            r[1].intensity = .01 * Math.sin(t / 305 + 2) + .1,
            r[2].intensity = .01 * Math.sin(t / 288 + 3) + .1
        }
        )
    }
    );
    const d = 1.5 + ut;
    Ae.load("./models/better-lamp.json", e=>{
        e.radius = d + 2;
        const [n,r] = [15, -490]
          , a = new THREE.Group;
        a.add(e),
        a.position.set(n, 0, r),
        i.push([n - d, n + d, r - d, r + d, e]),
        t.add(a),
        u.set(e, a),
        window.lampy = e
    }
    );
    const f = new THREE.PositionalAudio(Me);
    Le.load("sounds/sohum.mp3", t=>{
        f.setBuffer(t),
        f.setRefDistance(5)
    }
    ),
    Ae.load("./models/cassette-player.json", e=>{
        e.position.set(5, 0, -495),
        e.scale.multiplyScalar(3),
        t.add(e),
        e.add(f),
        i.push([.5 - ut, 9.5 + ut, -496.5 - ut, -493.5 + ut])
    }
    );
    const m = new THREE.Mesh(new THREE.PlaneBufferGeometry(28,24),new THREE.MeshBasicMaterial({
        emissive: 16777215
    }));
    return m.position.set(0, 12, .1),
    {
        swap() {
            t.remove(o ? s : h),
            r && t.remove(o ? r : n),
            o = !o,
            t.add(o ? s : h),
            r && t.add(o ? r : n)
        },
        isDark: ()=>o,
        darkPhongFloor: r,
        doors: c,
        entranceDoors: l,
        cassette: f,
        lights: u,
        outsideLight: m
    }
}(De, ze, Be)
  , {studentMap: We, instructor: Xe, instructorVoice: qe, setFaces: Ye, addStudents: Je} = function(t, e) {
    it = Pe("./textures/face-awake.png"),
    nt = Pe("./textures/face-sleeping.png"),
    rt = Pe("./textures/face-creepy.png");
    const n = U(8082754, 984837, 2.5);
    n.face.map = it,
    t.add(n.person),
    n.delay = 0,
    n.person.rotation.y = Math.PI / 2,
    K(n, !1, Y),
    $(n);
    const r = new THREE.SpotLight(10027008,.5);
    r.penumbra = 1,
    r.position.set(0, 0, -1.25),
    n.head.add(r),
    r.target.position.set(0, -10, -10),
    n.head.add(r.target);
    const a = new THREE.PositionalAudio(Me);
    a.setRefDistance(5),
    n.head.add(a),
    e.push(t=>{
        if (!n.moving)
            return;
        const e = t - n.walkOffsetTime;
        if ("watch" === n.moving) {
            const t = (e / 200 + 150) % 600;
            n.person.position.x = t > 300 ? 450 - t : t - 150,
            n.person.rotation.y = t > 300 ? Math.PI / 2 : -Math.PI / 2,
            n.limbs[2].limb.rotation.x = Math.PI + .3 * Math.sin(e / 200) + .1,
            n.limbs[2].forearm.rotation.x = .3 * Math.sin(e / 200 - 2.5) - .3,
            n.limbs[3].limb.rotation.x = Math.PI - .3 * Math.sin(e / 200) + .1,
            n.limbs[3].forearm.rotation.x = -.3 - .3 * Math.sin(e / 200 - 2.5),
            n.head.rotation.y = Math.sin(e / 800) * Math.PI * .2 + Math.PI / 4 * (t > 300 ? 1 : -1)
        } else
            n.limbs[2].limb.rotation.x = Math.PI + .6 * Math.sin(e / 100) + .1,
            n.limbs[2].forearm.rotation.x = .6 * Math.sin(e / 100 - 2.1) - .6,
            n.limbs[3].limb.rotation.x = Math.PI - .6 * Math.sin(e / 100) + .1,
            n.limbs[3].forearm.rotation.x = .6 * -Math.sin(e / 100 - 2.1) - .6
    }
    );
    const o = {}
      , s = []
      , c = "true" === i.get("box-students")
      , h = c ? (t,e)=>{
        const i = new THREE.Mesh(new THREE.BoxBufferGeometry(5,6,4.5),Oe(G(), 0, .9, .5))
          , n = new THREE.MeshBasicMaterial({
            map: it,
            transparent: !0
        })
          , r = new THREE.Mesh(new THREE.PlaneBufferGeometry(4,4),n);
        return r.position.set(0, 0, -2.25),
        r.rotation.y = Math.PI,
        i.add(r),
        i.position.set(t, 3, e - .5),
        {
            face: n,
            person: i
        }
    }
    : (t,e)=>{
        const i = U(G(), V(), 2 * Math.random() + .5);
        return i.face.map = it,
        i.person.position.set(t, -5, e),
        i.delay = 200 * Math.random(),
        k(i.limbs[2]),
        k(i.limbs[3]),
        K(i, !1, q),
        $(i),
        i
    }
    ;
    for (let t = -10; t <= 10; t++) {
        const e = Math.random() < .5 ? 4 : 3;
        for (let i = 0 === t ? 1 : 0; i < e; i++)
            s.push(h(t * (g + y), x + i * (v + y) + (t % 2 == 0 ? -B : B))),
            o[`${t},${i}`] = !0
    }
    if (!c) {
        let t = null;
        e.push(()=>{
            const e = Date.now();
            let i;
            be ? (i = be.type,
            t || (t = be.type)) : t && (i = "rest",
            t = null),
            s.forEach(t=>{
                switch (i) {
                case "expansion-ready":
                    "expansion" !== t.mode && (K(t, !0, X),
                    t.mode = "expansion");
                    break;
                case "expansion":
                    "up" === be.mode ? tt(t, e - be.start) : et(t, e - be.start);
                    break;
                case "power-down":
                    e - be.start > t.delay && "power-down" !== t.mode && (t.mode = "power-down",
                    K(t, !0, Z));
                    break;
                case "power-up":
                    e - be.start > t.delay && "power-up" !== t.mode && (t.mode = "power-up",
                    K(t, !0, Q));
                    break;
                case "rest":
                    K(t, !0, q)
                }
                $(t)
            }
            )
        }
        )
    }
    return {
        studentMap: o,
        students: s,
        instructor: n,
        instructorVoice: a,
        setFaces(t) {
            s.forEach(({face: e})=>{
                e.map = t
            }
            )
        },
        addStudents() {
            s.forEach(({person: e})=>{
                t.add(e)
            }
            )
        }
    }
}(De, ze)
  , Ze = {
    phoneOut: !1,
    pose: "rest",
    canDie: !1,
    jumpVel: null
};
function Qe(t) {
    document.body.classList.remove("indicate-" + Ze.pose),
    document.body.classList.add("indicate-" + t),
    Ze.pose = t
}
const Ke = Ai(Ze.lungSize, 1 - It, It - 1);
function $e(t) {
    Ze.canBreathe !== t && (Ze.canBreathe = t,
    t ? (Ze.oxygen = Ct,
    Ze.lungSize = 0,
    Ke.set(Ze.lungSize),
    Ze.respireVel = 0,
    Ze.wasExhaling = !1,
    qi(Ze.oxygen / Ct, Ze.lungSize / It),
    document.body.classList.remove("hide-lungs")) : document.body.classList.add("hide-lungs"))
}
const ti = function() {
    const t = U(G(), V(), 2 * Math.random() + .5);
    return k(t.limbs[2]),
    k(t.limbs[3]),
    t.head.visible = !1,
    t.face.map = it,
    K(t, !1, q),
    $(t),
    t
}();
ti.person.position.set(he.position.x, -5, x);
const ei = function() {
    const t = new THREE.Group
      , e = new THREE.Mesh(new THREE.BoxBufferGeometry(.7,.1,1.3),Oe(3421497, 0, .9, .8));
    t.add(e);
    const i = new THREE.Mesh(new THREE.BoxBufferGeometry(.6,.01,1.2),Oe(0, 16777215, .9, .8));
    i.position.y = .1,
    t.add(i);
    const n = document.createElement("canvas");
    n.width = 128,
    n.height = 256;
    const r = new THREE.CanvasTexture(n);
    r.magFilter = THREE.NearestFilter,
    r.minFilter = THREE.NearestFilter;
    const a = new THREE.Mesh(new THREE.PlaneBufferGeometry(.6,1.2),new THREE.MeshBasicMaterial({
        map: r,
        transparent: !0
    }));
    return a.rotation.x = -Math.PI / 2,
    a.position.y = .11,
    t.add(a),
    {
        phone: t,
        canvas: n,
        content: a,
        update() {
            r.needsUpdate = !0
        }
    }
}()
  , ii = new THREE.Group;
function ni(t) {
    Ze.phoneOut !== t && (Ze.phoneOut = t,
    t ? ("sitting" === Ki ? ii.add(ei.phone) : Mi.add(ei.phone),
    K(ti, !0, J),
    Qe("phone"),
    Ze.phoneOutSince = Date.now()) : (ei.phone.parent === ii ? ii.remove(ei.phone) : Mi.remove(ei.phone),
    K(ti, !0, q),
    Qe("rest")))
}
ii.position.set(.051712800199567255, 2.5974805742832814, .4137824638055463),
ii.rotation.set(1.97030219, 1.10130276, .432667122),
ti.limbs[0].forearm.add(ii);
const ri = ei.canvas.getContext("2d");
let ai, oi, si;
ri.fillStyle = "#BE1E2D",
ri.fillRect(0, 0, 128, 30),
ri.font = "15px monospace",
ri.fillStyle = "white",
ri.fillText("Gunn admin MSG", 5, 25),
ri.strokeStyle = "black";
const ci = document.createElement("canvas");
ci.width = 256,
ci.height = 128;
const hi = ci.getContext("2d");
hi.textAlign = "center",
hi.textBaseline = "top";
const li = new THREE.CanvasTexture(ci);
li.magFilter = THREE.NearestFilter,
li.minFilter = THREE.NearestFilter;
const ui = new THREE.Mesh(new THREE.PlaneBufferGeometry(28,14),new THREE.MeshBasicMaterial({
    map: li,
    transparent: !0
}));
ui.position.set(0, 7, 1.5);
let pi, di, fi = null, mi = null;
function gi(t=!1) {
    switch (hi.clearRect(0, 0, 256, 128),
    fi.metadata.type) {
    case "code":
        if (t && pi.length >= Bt) {
            if (pi === ai) {
                if (!si || fi.wrong) {
                    fi.metadata.tunnel && (si = !0),
                    fi.wrong = !0,
                    hi.fillStyle = "#ff0000",
                    hi.font = "20px sans-serif",
                    hi.fillText("Try another door", 128, 5);
                    const t = new THREE.Audio(Me);
                    t.setBuffer(Ce.wrong),
                    t.play();
                    break
                }
                {
                    kt.escapes++,
                    Vi(),
                    Ut.winMode = "escape",
                    Zt(),
                    hi.fillStyle = "#00ff00",
                    mi = setTimeout(()=>{
                        pi = "",
                        di = !0,
                        mi = null,
                        fi.add(je),
                        tn.push({
                            type: "open-doors",
                            start: Date.now(),
                            doors: fi,
                            duration: 1e3
                        }),
                        fi.remove(ui),
                        fi = null
                    }
                    , 1e3);
                    const t = new THREE.Audio(Me);
                    t.setBuffer(Ce.correct),
                    t.play()
                }
            } else {
                hi.fillStyle = "#ff0000";
                const t = new THREE.Audio(Me);
                t.setBuffer(Ce.wrong),
                t.play()
            }
            mi = setTimeout(()=>{
                pi = "",
                di = !0,
                mi = null,
                gi()
            }
            , 500)
        } else
            hi.fillStyle = "#00ffff";
        hi.font = "20px sans-serif",
        hi.fillText("Press 0–9 to enter keycode:", 128, 5),
        hi.font = "30px sans-serif",
        hi.fillText(pi, 128, 30),
        !t && pi.length >= Bt && (di = !1,
        mi = setTimeout(()=>{
            gi(!0)
        }
        , 500),
        Ut && Ut.codeEntries++);
        break;
    case "no code":
        hi.fillStyle = "#ffff00",
        hi.font = "20px sans-serif",
        hi.fillText("The code won't work", 128, 5),
        hi.fillText("on this door", 128, 35);
        break;
    case "other door":
        hi.fillStyle = "#ffff00",
        hi.font = "20px sans-serif",
        hi.fillText("Use the other door", 128, 5);
        break;
    case "no exit":
        hi.fillStyle = "#ffff00",
        hi.font = "30px sans-serif",
        hi.fillText("Not an exit", 128, 5)
    }
    li.needsUpdate = !0
}
const vi = Pe("./textures/yesnt-logo.png");
vi.magFilter = THREE.NearestFilter,
vi.minFilter = THREE.NearestFilter;
const yi = new THREE.Mesh(new THREE.PlaneBufferGeometry(160,80),new THREE.MeshBasicMaterial({
    map: vi,
    transparent: !0
}));
yi.position.set(0, 50, -499.9);
const xi = new THREE.WebGLRenderer;
let bi;
if (xi.setSize(window.innerWidth, window.innerHeight),
ee) {
    const t = new THREE.RenderPass(De,he)
      , e = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth,window.innerHeight),1.5,.4,.85);
    e.threshold = 0,
    e.strength = .5,
    e.radius = 0,
    (bi = new THREE.EffectComposer(xi)).setSize(window.innerWidth, window.innerHeight),
    bi.addPass(t),
    bi.addPass(e)
}
const wi = new THREE.Group;
wi.rotation.order = "YXZ";
const Mi = new THREE.Group;
Mi.rotation.set(Math.PI / 2, 0, 0),
Mi.scale.multiplyScalar(.5);
const _i = new THREE.Group;
function Si() {
    const t = he.rotation.clone();
    he.rotation.set(0, 0, 0),
    he.updateMatrixWorld();
    const e = new THREE.Raycaster;
    e.setFromCamera(new THREE.Vector2(-1,-1), he),
    Mi.position.copy(he.worldToLocal(new THREE.Ray(e.ray.at(1, new THREE.Vector3),e.ray.direction.multiply(new THREE.Vector3(-1,-1,1))).at(.2, new THREE.Vector3))),
    e.setFromCamera(new THREE.Vector2(1,-1), he),
    _i.position.copy(he.worldToLocal(e.ray.at(1, new THREE.Vector3))),
    he.rotation.copy(t)
}
let Ti;
_i.scale.multiplyScalar(.1),
wi.add(Mi),
wi.add(_i),
De.add(wi),
Si(),
window.addEventListener("resize", ()=>{
    document.body.style.display = "none";
    const t = window.innerWidth
      , e = window.innerHeight;
    he.aspect = t / e,
    he.updateProjectionMatrix(),
    xi.setSize(t, e),
    ee && bi.setSize(t, e),
    Si(),
    document.body.style.display = null
}
);
const Ei = new Promise(t=>Ti = t);
function Ai(t, e, i) {
    let n = t;
    return {
        change: r=>(n += r) > i && r > 0 ? t = i + 1 - 1 / (1 + n - i) : n < e && r < 0 ? t = e - 1 + 1 / (1 - n + e) : (n = (t += r) > i ? i + 1 / (1 - t + i) - 1 : t < e ? e + 1 - 1 / (1 + t - e) : t,
        t),
        set: e=>n = t = e
    }
}
document.addEventListener("click", t=>{
    t.target.closest(".clickable") || (document.body.requestPointerLock(),
    document.body.classList.add("hide-options")),
    Ti()
}
);
const Li = Math.PI / 2
  , Pi = Ai(he.rotation.y, -Li, Li);
function Ci(t, e) {
    "chase" === Ki ? he.rotation.y -= t : "sitting" === Ki && (he.rotation.y = Pi.change(-t)),
    "caught" !== Ki && (he.rotation.x -= e,
    he.rotation.x > Math.PI / 2 ? he.rotation.x = Math.PI / 2 : he.rotation.x < -Math.PI / 2 && (he.rotation.x = -Math.PI / 2))
}
document.addEventListener("mousemove", t=>{
    document.pointerLockElement && Ci(t.movementX / o.sensitivity, t.movementY / o.sensitivity)
}
);
const Ii = {};
let Ri, Oi, Di, zi;
function Bi(t, e=!1) {
    zi.has(t) && !e || (clearTimeout(Di),
    Ri.classList.remove("hidden"),
    e ? (zi = new Set([t]),
    Oi = 0) : (zi.add(t),
    Oi = zi.size - 1),
    ki())
}
function Ni(t) {
    (!0 === t || zi.delete(t)) && (clearTimeout(Di),
    !0 !== t && zi.size ? (Oi %= zi.size,
    ki()) : (Ri.classList.add("hidden"),
    !0 === t && (zi = new Set)))
}
function ki() {
    switch ([...zi][Oi]) {
    case "breathe":
        Ri.textContent = `Press ${o.keyNames[$i.inhale.dataset.keyCode].toUpperCase()} and ${o.keyNames[$i.exhale.dataset.keyCode].toUpperCase()} to inhale and exhale.`;
        break;
    case "skip-intro":
        Ri.textContent = `Press ${o.keyNames[$i["skip-intro"].dataset.keyCode].toUpperCase()} to skip the intro.`;
        break;
    case "phone":
        Ri.textContent = `Press ${o.keyNames[$i.phone.dataset.keyCode].toUpperCase()} to take out your phone.`;
        break;
    case "get-up":
        Ri.textContent = `Press ${o.keyNames[$i["get-up"].dataset.keyCode].toUpperCase()} to get up and move.`;
        break;
    case "expansion":
        Ri.textContent = `Hold ${o.keyNames[$i["exp-up"].dataset.keyCode].toUpperCase()} and ${o.keyNames[$i["exp-down"].dataset.keyCode].toUpperCase()} to raise and lower your arms for expansion breath.`;
        break;
    case "power":
        Ri.textContent = `Press ${o.keyNames[$i["power-up"].dataset.keyCode].toUpperCase()} and ${o.keyNames[$i["power-down"].dataset.keyCode].toUpperCase()} to raise and lower your arms for power breath.`;
        break;
    case "move":
        Ri.textContent = "Press " + o.keyNames[$i.forth.dataset.keyCode].toUpperCase() + ", " + o.keyNames[$i.left.dataset.keyCode].toUpperCase() + ", " + o.keyNames[$i.back.dataset.keyCode].toUpperCase() + ", and " + o.keyNames[$i.right.dataset.keyCode].toUpperCase() + " to move around.";
        break;
    case "pick-up":
        Ri.textContent = `Press ${o.keyNames[$i["pick-up"].dataset.keyCode].toUpperCase()} to pick up the light.`;
        break;
    case "type":
        Ri.textContent = "Type the keycode using the 0–9 keys."
    }
    zi.size > 1 && (Oi = (Oi + 1) % zi.size,
    Di = setTimeout(ki, Nt))
}
const Ui = {
    phone() {
        if ("sitting" === Ki || "chase" === Ki)
            return Ze.canDie ? void ni(!Ze.phoneOut) : (Zi.textContent = "You should take out your phone when it's dark so they won't notice.",
            void tn.push({
                type: "flash-hint",
                start: Date.now(),
                duration: 5e3
            }))
    },
    reset() {
        Ze.canDie && (Ze.phoneOut && ni(!1),
        "rest" !== Ze.pose && (K(ti, !0, q),
        Qe("rest")))
    },
    "get-up"() {
        if ("sitting" !== Ki)
            return;
        if (!Ze.canDie)
            return Zi.textContent = "You should get up when it's dark so they won't notice.",
            void tn.push({
                type: "flash-hint",
                start: Date.now(),
                duration: 5e3
            });
        Ki = "chase",
        wi.rotation.set(-Math.PI / 4, 0, 0),
        Ze.phoneOut && Mi.add(ei.phone),
        De.remove(ti.person);
        for (let t = tn.length - 1; t >= 0; t--)
            "intense-om" === tn[t].type && tn.splice(t, 1);
        tn.push({
            type: "get-up",
            start: Date.now(),
            duration: 200
        }),
        Xe.moving = "chase",
        Xe.head.rotation.y = 0,
        Xe.limbs[0].limb.rotation.x = Xe.limbs[1].limb.rotation.x = 1.4 * Math.PI,
        Xe.limbs[0].forearm.rotation.x = Xe.limbs[1].forearm.rotation.x = .1 * Math.PI,
        fe && fe("getting up"),
        document.body.classList.add("can-move"),
        at(["phone"]),
        Bi("phone", !0),
        Bi("breathe"),
        Bi("move"),
        document.body.classList.add("hide-pose");
        const t = new THREE.Audio(Me);
        t.setBuffer(Ce.creak),
        t.setVolume(.05),
        t.play()
    },
    "skip-intro"() {
        an && an()
    },
    "del-code-digit"() {
        if (fi && di) {
            pi = pi.slice(0, -1),
            gi();
            const t = new THREE.Audio(Me);
            t.setBuffer(Ce.keypress),
            t.play()
        }
    },
    "power-down"() {
        "sitting" === Ki && (Ut && "power" === Ze.pose && Ze.up && Ut.powerBreaths++,
        Ze.phoneOut && ni(!1),
        Qe("power"),
        document.body.classList.remove("indicate-power-up"),
        document.body.classList.add("indicate-power-down"),
        Ze.up = !1,
        K(ti, !0, Z))
    },
    "power-up"() {
        "sitting" === Ki && (Ze.phoneOut && ni(!1),
        Qe("power"),
        document.body.classList.remove("indicate-power-down"),
        document.body.classList.add("indicate-power-up"),
        Ze.up = !0,
        K(ti, !0, Q))
    },
    "pick-up"() {
        _i.children.length && (Zi.textContent = "You feel too attached to the light to let it go.",
        tn.push({
            type: "flash-hint",
            start: Date.now(),
            duration: 5e3
        }))
    },
    trip() {
        "chase" === Ki && (Vi(),
        Ze.jumpVel = 5)
    }
};
document.addEventListener("pointerlockchange", ()=>{
    document.pointerLockElement || document.body.classList.remove("hide-options")
}
),
document.addEventListener("keydown", t=>{
    const e = o.controls[t.keyCode];
    if (document.pointerLockElement)
        e && (Ii[e] = !0,
        Ui[e] && Ui[e]()),
        t.preventDefault();
    else if (document.activeElement && document.activeElement.classList.contains("key-input")) {
        const i = document.activeElement;
        e ? i.classList.contains("duplicate-key") || (i.classList.add("duplicate-key"),
        setTimeout(()=>{
            i.classList.remove("duplicate-key")
        }
        , 200)) : (delete o.controls[i.dataset.keyCode],
        o.controls[t.keyCode] = i.dataset.fn,
        i.textContent = o.keyNames[t.keyCode] = " " === t.key ? "Space" : t.key,
        o.controls.default = !1,
        i.blur(),
        s()),
        t.preventDefault()
    }
}
),
document.addEventListener("keyup", t=>{
    const e = o.controls[t.keyCode];
    document.pointerLockElement && (e && (Ii[e] = !1),
    t.preventDefault())
}
);
for (let t = 0; t < 10; t++)
    o.controls[t + 48] = t + "",
    Ui[t] = (()=>{
        if (fi && di) {
            pi += t,
            gi();
            const e = new THREE.Audio(Me);
            e.setBuffer(Ce.keypress),
            e.play()
        }
    }
    );
function Fi(t) {
    return --t * t * t + 1
}
function Gi(t) {
    return t * t * t
}
function Vi() {
    Xe.moving = !1,
    $e(!1),
    Ki = "caught",
    document.body.classList.remove("can-move"),
    at([]),
    Ni(!0),
    fe && fe("caught"),
    Ze.canDie = !1,
    Ut.accuracy = 1 - Ut.fails / Ut.checks,
    Ut.duration = Date.now() - Ut.startTime,
    function(t=null) {
        t && (kt.attempts++,
        kt.runDistance += t.runDistance,
        kt.breaths += t.breaths,
        kt.powerBreaths += t.powerBreaths,
        kt.expansionBreaths += t.expansionBreaths,
        kt.time += t.duration,
        kt.checks += t.checks,
        kt.fails += t.fails,
        kt.codeEntries += t.codeEntries,
        Qt()),
        n || localStorage.setItem("[yesnt] stats", JSON.stringify(kt))
    }(Ut)
}
function ji() {
    Vi();
    const t = Xe.head.getWorldPosition(new THREE.Vector3);
    he.lookAt(t),
    Xe.head.lookAt(he.position),
    Xe.head.rotation.y += Math.PI,
    document.body.style.backgroundColor = "red",
    tn.push({
        type: "intensify",
        start: Date.now(),
        duration: 2e3,
        zoomIntensity: he.position.distanceTo(t) / 20,
        anchorY: he.position.y
    });
    const e = new THREE.Audio(Me);
    e.setBuffer(Ce.caught),
    e.play()
}
let Hi, Wi;
function Xi(t, e=2) {
    Hi.textContent = t,
    Hi.parentNode.style.transitionDelay = e + "s",
    Hi.parentNode.style.maxWidth = null,
    Hi.parentNode.classList.add("hide-death-note"),
    Hi.parentNode.style.maxWidth = Hi.parentNode.scrollWidth + "px",
    Hi.parentNode.classList.remove("hide-death-note")
}
function qi(t, e) {
    Wi.style.setProperty("--blood", `hsl(0, ${100 - 25 * t}%, ${50 * t}%)`),
    Wi.style.setProperty("--size", 20 * e + 50 + "px"),
    Wi.style.setProperty("--icon-size", 5 * e + 30 + "px")
}
const Yi = ["Don't forget to breathe!", "Need breath", "Respiration required", "Your cells desire oxygen!", "Breathe!"];
function Ji() {
    const t = document.createElement("div");
    t.classList.add("reminder-to-breathe");
    const e = document.createElement("span");
    e.textContent = Yi[Math.floor(Math.random() * Yi.length)],
    e.addEventListener("animationend", ()=>{
        document.body.removeChild(t)
    }
    , {
        once: !0
    }),
    t.appendChild(e),
    document.body.appendChild(t)
}
let Zi, Qi, Ki;
const $i = {}
  , tn = []
  , en = new THREE.Raycaster;
function nn() {
    const t = Date.now()
      , e = t - Qi;
    for (let e = 0; e < tn.length; e++) {
        const i = tn[e]
          , n = (t - i.start) / i.duration;
        if (n > 1) {
            switch (i.type) {
            case "start":
                xi.domElement.style.opacity = null,
                he.zoom = 1,
                he.updateProjectionMatrix();
                break;
            case "intensify":
                he.filmOffset = 0,
                he.updateProjectionMatrix(),
                fe || (de(),
                xe = we()),
                document.body.style.backgroundColor = null;
                break;
            case "intense-om":
                he.filmOffset = 0,
                he.updateProjectionMatrix();
                break;
            case "get-up":
                he.position.y = ht;
                break;
            case "flash-hint":
                Zi.style.opacity = 0;
                break;
            case "show-expansion":
            case "show-power":
                K(Xe, !0, Y),
                i.onDone();
                break;
            case "black-out":
                xi.domElement.style.opacity = null,
                he.zoom = 1,
                he.updateProjectionMatrix(),
                i.restart ? fe || (de(),
                xe = we()) : ($e(!0),
                tn.push({
                    type: "start",
                    start: t,
                    duration: 1e3
                }));
                break;
            case "hide-cant-jump":
                document.body.classList.add("hide-cant-jump"),
                de(),
                xe = we();
                break;
            case "open-doors":
                document.body.style.backgroundColor = "white",
                tn.push({
                    type: "into-the-light",
                    start: t,
                    doors: i.doors,
                    initialPlayerX: he.position.x,
                    initialPlayerZ: he.position.z,
                    finalPlayerX: i.doors.position.x,
                    finalPlayerZ: i.doors.position.z,
                    duration: 2e3
                });
                break;
            case "into-the-light":
                i.doors.remove(je),
                i.doors.left.rotation.y = 0,
                i.doors.right.rotation.y = Math.PI,
                document.body.classList.remove("hide-end"),
                document.body.classList.add("escaped"),
                xi.domElement.style.opacity = null,
                document.body.style.backgroundColor = null,
                document.exitPointerLock();
                break;
            case "camera-pan":
                break;
            case "instructor-start-walking":
                Xe.moving = "watch",
                Xe.walkOffsetTime = t,
                i.ended = !0;
                break;
            case "run-to-cassette":
                Xe.person.position.copy(i.dest),
                Xe.person.rotation.y = 0,
                Xe.head.rotation.x = -.2,
                he.lookAt(Xe.person.position.clone().setY(11)),
                i.done()
            }
            tn.splice(e--, 1)
        } else
            switch (i.type) {
            case "start":
                {
                    const t = Fi(n);
                    xi.domElement.style.opacity = t,
                    he.zoom = 2 - t,
                    he.updateProjectionMatrix();
                    break
                }
            case "intensify":
                {
                    const t = Gi(n);
                    he.filmOffset = (Math.random() - .5) * t * 3,
                    he.position.y = i.anchorY + (Math.random() - .5) * t * 3,
                    he.zoom = n > .7 ? i.zoomIntensity + 1 : Gi(n / .7) * i.zoomIntensity + 1,
                    he.updateProjectionMatrix(),
                    xi.domElement.style.opacity = 1 - .5 * t;
                    break
                }
            case "intense-om":
                {
                    const t = 1 - Fi(n);
                    he.filmOffset = (Math.random() - .5) * t * 3,
                    he.position.y = i.anchorY + (Math.random() - .5) * t * 3,
                    he.updateProjectionMatrix();
                    break
                }
            case "get-up":
                he.position.y = Fi(n) * (ht - ct) + ct;
                break;
            case "flash-hint":
                Zi.style.opacity = Fi(1 - n);
                break;
            case "show-expansion":
                n < .5 ? tt(Xe, 18e3 * n) : et(Xe, 18e3 * (n - .5));
                break;
            case "show-power":
                n < .25 ? 1 !== i.step && (K(Xe, !0, Z),
                i.step = 1) : n < .5 ? 2 !== i.step && (K(Xe, !0, Q),
                i.step = 2) : n < .75 ? 3 !== i.step && (K(Xe, !0, Z),
                i.step = 3) : 4 !== i.step && (K(Xe, !0, Q),
                i.step = 4);
                break;
            case "black-out":
                {
                    const t = Fi(n);
                    xi.domElement.style.opacity = .5 - t / 2,
                    he.zoom = 1 / (1 + 3 * t),
                    he.updateProjectionMatrix();
                    break
                }
            case "open-doors":
                {
                    const t = Fi(n);
                    i.doors.left.rotation.y = -Math.PI / 2 * t,
                    i.doors.right.rotation.y = Math.PI + Math.PI / 2 * t;
                    break
                }
            case "into-the-light":
                {
                    const t = Gi(n);
                    he.position.x = t * (i.finalPlayerX - i.initialPlayerX) + i.initialPlayerX,
                    he.position.z = t * (i.finalPlayerZ - i.initialPlayerZ) + i.initialPlayerZ,
                    xi.domElement.style.opacity = 1 - t;
                    break
                }
            case "camera-pan":
                {
                    const e = (t - i.start) / i.actualDuration;
                    he.position.x = i.from.x + (i.to.x - i.from.x) * e,
                    he.position.y = i.from.y + (i.to.y - i.from.y) * e,
                    he.position.z = i.from.z + (i.to.z - i.from.z) * e,
                    he.rotation.z = i.roll * (1 - 2 * e);
                    break
                }
            case "start-screen-pan":
                {
                    let e = Fi((t - i.start) / i.actualDuration);
                    e > 1 && (he.position.y = 30 * Math.random() + 10,
                    i.startAngle = Math.random() * Math.PI,
                    i.deltaAngle = Math.random() * Math.PI - i.startAngle,
                    i.actualDuration = 3e3 * Math.abs(i.deltaAngle) + 1e3,
                    i.startRadius = 100 * Math.random() + 10,
                    i.deltaRadius = 100 * Math.random() + 10 - i.startRadius,
                    i.start = t,
                    e = 0);
                    const n = i.startAngle + e * i.deltaAngle
                      , r = i.startRadius + e * i.deltaRadius;
                    he.position.x = Math.cos(n) * r,
                    he.position.z = Xe.person.position.z + Math.sin(n) * r,
                    he.lookAt(i.lookTarget),
                    Xe.head.rotation.y = .5 * Math.sin(t / 1e3),
                    Xe.person.position.y = 1.5 * (Math.cos(t / 200) - 1),
                    Xe.limbs[2].limb.rotation.x = Math.PI + .5 * (1 - Math.cos(t / 200)),
                    Xe.limbs[2].forearm.rotation.x = Math.cos(t / 200) - 1,
                    Xe.limbs[3].limb.rotation.x = Math.PI + .5 * (1 - Math.cos(t / 200)),
                    Xe.limbs[3].forearm.rotation.x = Math.cos(t / 200) - 1;
                    break
                }
            case "instructor-start-walking":
                {
                    const t = Fi(n);
                    Xe.person.rotation.y = Math.PI + t * Math.PI / 2,
                    Xe.head.rotation.y = -t * Math.PI / 4;
                    break
                }
            case "run-to-cassette":
                if (Xe.person.position.x = n * (i.dest.x - i.startPos.x) + i.startPos.x,
                Xe.person.position.z = n * (i.dest.z - i.startPos.z) + i.startPos.z,
                Xe.person.rotation.y = Math.atan2(i.startPos.x - i.dest.x, i.startPos.z - i.dest.z),
                Xe.head.rotation.x = -.2 * n,
                he.lookAt(Xe.person.position.clone().setY(11)),
                n < .5) {
                    const t = Fi(2 * n);
                    he.rotation.x = i.initCamRot.x + t * (he.rotation.x - i.initCamRot.x),
                    he.rotation.y = i.initCamRot.y + t * (he.rotation.y - i.initCamRot.y)
                }
            }
    }
    let i = 0;
    if ("chase" === Ki) {
        const t = Math.sin(he.rotation.y)
          , n = Math.cos(he.rotation.y)
          , r = new THREE.Vector3;
        st && (r.x = st.x * n + st.y * t,
        r.z = -st.x * t + st.y * n),
        Ii.forth && (r.x -= t,
        r.z -= n),
        Ii.back && (r.x += t,
        r.z += n),
        Ii.left && (r.x -= n,
        r.z += t),
        Ii.right && (r.x += n,
        r.z -= t),
        r.lengthSq() > 1 && r.normalize(),
        i = r.length(),
        r.multiplyScalar(lt * e);
        const a = Math.round(he.position.x / (g + y))
          , o = Math.round((he.position.z - x) / (v + y))
          , s = a * (g + y)
          , c = o * (v + y) + x
          , h = a % 2 == 0 ? -B : B
          , l = [...Be];
        We[`${a},${o}`] && l.push([s - gt, s + gt, c - yt + h, c + vt + h]);
        const u = he.position.clone();
        if (he.position.x += r.x,
        he.position.x < ft && (he.position.x = ft),
        he.position.x > mt && (he.position.z >= $t.left[0] && he.position.z <= $t.left[1] || he.position.z >= $t.right[0] && he.position.z <= $t.right[1] ? he.position.x > te && (he.position.x = te) : he.position.x = mt),
        l.forEach(([t,e,i,n,a])=>{
            a && a.parent !== Ve.get(a) || he.position.z > i && he.position.z < n && he.position.x > t && he.position.x < e && (r.x > 0 ? he.position.x = t : he.position.x = e)
        }
        ),
        he.position.z += r.z,
        he.position.z < pt && (he.position.z = pt),
        he.position.z > dt && (he.position.z = dt),
        he.position.x > mt && (he.position.z < 0 ? (he.position.z < $t.left[0] && (he.position.z = $t.left[0]),
        he.position.z > $t.left[1] && (he.position.z = $t.left[1])) : (he.position.z < $t.right[0] && (he.position.z = $t.right[0]),
        he.position.z > $t.right[1] && (he.position.z = $t.right[1]))),
        l.forEach(([t,e,i,n,a])=>{
            a && a.parent !== Ve.get(a) || he.position.x > t && he.position.x < e && he.position.z > i && he.position.z < n && (r.z > 0 ? he.position.z = i : he.position.z = n)
        }
        ),
        Ut && (Ut.runDistance += Math.hypot(he.position.x - u.x, he.position.z - u.z)),
        0 === _i.children.length) {
            const t = he.position.clone().setY(0);
            let e;
            for (const i of Ve.keys())
                if (t.distanceToSquared(i.parent.position) <= i.radius * i.radius) {
                    e = i;
                    break
                }
            e ? Ii["pick-up"] ? _i.add(e) : Ze.showedPickupHint || (at(["phone", "pick-up"]),
            Bi("pick-up"),
            Ze.showedPickupHint = !0) : Ze.showedPickupHint && (at(["phone"]),
            Ni("pick-up"),
            Ze.showedPickupHint = !1)
        } else
            Ze.showedPickupHint && (at(["phone"]),
            Ni("pick-up"),
            Ze.showedPickupHint = !1);
        en.setFromCamera(new THREE.Vector2, he);
        const p = en.intersectObjects(Fe, !0)[0];
        if (p && p.distance < 40) {
            let t = p.object;
            for (; t && !t.isDoors; )
                t = t.parent;
            if (!t)
                return;
            fi !== t && (mi && clearTimeout(mi),
            fi = t,
            t.add(ui),
            "code" === fi.metadata.type ? (pi = "",
            di = !0) : di = !1,
            gi())
        } else
            fi && (mi && clearTimeout(mi),
            fi.remove(ui),
            fi = null);
        wi.position.copy(he.position);
        const d = 1 - (2 / 3) ** (e / 15);
        wi.rotation.x += (he.rotation.x - wi.rotation.x) * d,
        wi.rotation.y += (he.rotation.y - wi.rotation.y) * d;
        const f = Math.atan2(Xe.person.position.x - he.position.x, Xe.person.position.z - he.position.z);
        Xe.person.rotation.y = f,
        ie && (Xe.person.position.x -= Math.sin(f) * xt * e,
        Xe.person.position.z -= Math.cos(f) * xt * e),
        he.position.distanceToSquared(Xe.person.position) < 144 && (Xi("outrun the instructor"),
        ji())
    } else if ("sitting" === Ki) {
        const t = Xe.head.getWorldDirection(new THREE.Vector3).setY(0)
          , i = Xe.person.position.clone().sub(he.position).setY(0);
        (Ii["exp-down"] || Ii["exp-up"]) && ("expansion" !== Ze.pose && (Ze.phoneOut && ni(!1),
        K(ti, !0, X),
        Qe("expansion"),
        Ze.position = 0),
        Ii["exp-down"] && (Ze.position -= bt * e,
        Ze.needsDown && Ze.position < .2 && (Ze.needsDown = !1,
        Ut && Ut.expansionBreaths++)),
        Ii["exp-up"] && (Ze.position += bt * e,
        !Ze.needsDown && Ze.position > .8 && (Ze.needsDown = !0)),
        Ze.position < 0 ? Ze.position = 0 : Ze.position > 1 && (Ze.position = 1),
        ti.limbs[0].limb.idealRot.z = Ze.position * (Math.PI - .2) + .1,
        ti.limbs[1].limb.idealRot.z = -Ze.position * (Math.PI - .2) - .1,
        document.body.style.setProperty("--expansion", 180 * Ze.position - 90 + "deg"));
        const n = function() {
            const t = Date.now();
            if (Ze.phoneOut)
                return t - Ze.phoneOutSince > Et ? "hide your phone" : "tolerable";
            if (be) {
                const e = t - be.start;
                switch (be.type) {
                case "expansion":
                    {
                        const t = be.first && e < wt;
                        if ("expansion" !== Ze.pose)
                            return t ? "tolerable" : "be ready for expansion breath";
                        {
                            const i = Math.max(Math.min(e / 6e3, 1), 0)
                              , n = Math.abs(("up" === be.mode ? i : 1 - i) - Ze.position);
                            if (n > .2)
                                return !t && e > Mt && n > .5 ? "up" === be.mode ? "raise your arms at the right time" : "lower your arms at the right time" : "tolerable"
                        }
                        break
                    }
                case "power-down":
                    {
                        const t = e < _t;
                        if ("power" !== Ze.pose)
                            return t ? "tolerable" : "be ready for power breath";
                        if (Ze.up)
                            return !t && e > St && e < 800 - Tt ? "raise your arms at the right time" : "tolerable";
                        break
                    }
                case "power-up":
                    {
                        const t = e < _t;
                        if ("power" !== Ze.pose)
                            return t ? "tolerable" : "be ready for power breath";
                        if (!Ze.up)
                            return !t && e > St && e < 800 - Tt ? "lower your arms at the right time" : "tolerable";
                        break
                    }
                }
            } else if ("rest" !== Ze.pose)
                return "tolerable";
            return !1
        }();
        Ut && (Ut.checks++,
        n && Ut.fails++),
        (ne ? t.angleTo(i) < .2 * Math.PI : re) && n && "tolerable" !== n && (Xi(n),
        ji())
    } else
        null !== Ze.jumpVel && (Ze.jumpVel -= .5 * e / 60,
        he.position.y += Ze.jumpVel * e / 60,
        wi.position.y += (he.position.y - wi.position.y) * (1 - .1 ** (e / 15)),
        he.position.y < 1 && (Xi("land a jump"),
        document.body.classList.remove("hide-cant-jump"),
        tn.push({
            type: "hide-cant-jump",
            start: t,
            duration: 2e3
        }),
        Ze.jumpVel = null));
    if (Ze.canBreathe) {
        const n = Ze.oxygen < Dt;
        ae && (Ze.oxygen -= Rt * e,
        Ze.oxygen -= Ot * e * i),
        Ze.respireVel *= .8,
        Ii.inhale ? (Ze.wasExhaling && !Ii.exhale && (Ze.wasExhaling = !1,
        Ut && Ut.breaths++),
        Ii._inhaleWasDown || (Ze.respireVel += Pt,
        Ii._inhaleWasDown = !0),
        Ze.respireVel += Lt * e) : Ii._inhaleWasDown = !1,
        Ii.exhale ? (Ze.wasExhaling || Ii.inhale || (Ze.wasExhaling = !0),
        Ii._exhaleWasDown || (Ze.respireVel -= Pt,
        Ii._exhaleWasDown = !0),
        Ze.respireVel -= Lt * e) : Ii._exhaleWasDown = !1;
        const r = Ze.lungSize;
        if (Ze.lungSize = Ke.change(Ze.respireVel * e),
        Ze.respireVel > 0 && (Ze.oxygen += At * (Ze.lungSize - r),
        Ze.oxygen > Ct && (Ze.oxygen = Ct)),
        qi(Ze.oxygen / Ct, Ze.lungSize / It),
        Ze.oxygen < zt)
            Ze.canAsphyxiate ? (Xi("breathe", 1),
            Vi()) : $e(!1),
            tn.push({
                type: "black-out",
                start: t,
                duration: 1e3,
                restart: Ze.canAsphyxiate
            });
        else if (Ze.oxygen < Dt) {
            const e = (Ze.oxygen - zt) / (Dt - zt);
            xi.domElement.style.opacity = e / 2 + .5,
            Ze.lastLowOxygen ? t - Ze.lastLowOxygen > 3e3 * e * e + 50 && (Ji(),
            Ze.lastLowOxygen = t) : (Ni("breathe"),
            Bi("breathe"),
            Ji(),
            Ze.lastLowOxygen = t)
        } else
            n && (xi.domElement.style.opacity = null,
            Ze.lastLowOxygen = null)
    }
    Ue && Ue.position.set(he.position.x, 0, he.position.z),
    ze.forEach(i=>i(t, e)),
    $(Xe),
    $(ti),
    ee ? bi.render() : xi.render(De, he),
    window.requestAnimationFrame(nn),
    Qi = t
}
const rn = ["intro", "introStraw", "introExpansion1", "introExpansion2", "introExpansion3", "introExpansion4", "introPower1", "introPower2", "introOm", "introSohum1", "introSohum2", "introSohum3", "introSohum4", "introStagger", "introThreat1", "introThreat2"];
let an = null;
document.addEventListener("DOMContentLoaded", ()=>{
    Zi = document.getElementById("hint"),
    Te = document.getElementById("progress-bar"),
    Wi = document.getElementById("lung-indicator"),
    Ri = document.getElementById("key-hint"),
    Hi = document.getElementById("death-reason"),
    Ft = document.getElementById("stattable"),
    Gt = document.getElementById("total-stattable"),
    Vt = document.getElementById("username"),
    jt = document.getElementById("url"),
    Ht = document.getElementById("problem"),
    Wt = document.getElementById("submit-score"),
    Xt = document.getElementById("leaderboard"),
    Qt(),
    window.location.search.length > 1 && (document.body.classList.remove("hide-dev"),
    Ht.classList.remove("hidden"),
    Ht.textContent = "You cannot submit scores in development mode. (currently you can because i want you test my game thancc)"),
    Vt.addEventListener("keypress", t=>{
        qt.test(t.key) && t.preventDefault()
    }
    ),
    Wt.addEventListener("click", ()=>{
        let t = "";
        if (3 !== Vt.value.length && (t += "Name not three characters long.\n"),
        qt.test(Vt.value) && (t += "Name has non-alphanumerical characters.\n"),
        jt.value && !Yt.test(jt.value) && (t += "Weird URL.\n"),
        t)
            Ht.classList.remove("hidden"),
            Ht.textContent = t;
        else {
            Wt.disabled = !0;
            const t = Ut.winMode
              , e = "escape" === t ? "escaped" : "complete" === t ? "completed" : "abridged";
            fetch("https://test-9d9aa.firebaseapp.com/yesntScores?leaderboard=" + e, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json; charset=utf-8"
                },
                body: JSON.stringify({
                    name: Vt.value.toUpperCase(),
                    url: jt.value,
                    duration: Ut.duration,
                    breaths: Ut.breaths,
                    time: Date.now(),
                    ..."escape" === t ? {
                        distance: Ut.runDistance,
                        codeEntries: Ut.codeEntries
                    } : {
                        powers: Ut.powerBreaths,
                        expands: Ut.expansionBreaths,
                        accuracy: Ut.accuracy
                    },
                    msg: "This is too easy to hack oof"
                })
            }).then(t=>t.ok ? t.text() : t.text().then(t=>Promise.reject(t))).then(i=>{
                const n = localStorage.getItem("[yesnt] submitted");
                localStorage.setItem("[yesnt] submitted", n ? n + " " + i : i),
                fetch("https://test-9d9aa.firebaseapp.com/yesntScores?leaderboard=" + e).then(t=>t.ok ? t.json() : t.text().then(t=>Promise.reject(t))).then(e=>{
                    "ok" === Kt("escape" === t ? e.sort((t,e)=>t.duration - e.duration) : e.sort((t,e)=>e.accuracy - t.accuracy), [["index", "#", "Position"], ["name", "NAM", "Name/URL"], ["duration", "DUR", "Length of gameplay"], ["breaths", "BTH", "Times breathed"], ..."escape" === t ? [["distance", "DIS", "Distance run"], ["codeEntries", "TRY", "Code entries tried"]] : [["powers", "POW", "Power breaths performed"], ["expands", "XPD", "Expansion breaths performed"], ["accuracy", "ACC", "Percent accuracy"]]], i) ? Ht.classList.add("hidden") : (Ht.classList.remove("hidden"),
                    Ht.textContent = "Could not find the score you just submitted. Oof!")
                }
                ).catch(t=>{
                    Ht.classList.remove("hidden"),
                    Ht.textContent = "There was a problem fetching the leaderboard:\n" + t
                }
                )
            }
            ).catch(t=>{
                Ht.classList.remove("hidden"),
                Ht.textContent = "There was a problem submitting the score:\n" + t,
                Wt.disabled = !1
            }
            )
        }
    }
    );
    const t = document.getElementById("fov")
      , e = document.getElementById("fov-val");
    e.textContent = t.value = o.fov,
    t.addEventListener("input", ()=>{
        e.textContent = he.fov = o.fov = +t.value,
        he.updateProjectionMatrix(),
        s()
    }
    );
    const n = document.getElementById("sensitivity");
    n.value = Math.log10(o.sensitivity),
    n.addEventListener("input", ()=>{
        o.sensitivity = Math.pow(10, +n.value),
        s()
    }
    );
    const r = document.getElementById("touch-sensitivity");
    r.value = Math.log10(o.touchSensitivity),
    r.addEventListener("input", ()=>{
        o.touchSensitivity = Math.pow(10, +r.value),
        s()
    }
    );
    const l = {};
    function d() {
        if (an)
            return an();
        Vi(),
        document.body.classList.add("hide-end"),
        tn.forEach(t=>{
            t.duration = 0
        }
        ),
        Promise.resolve(xe).then(()=>{
            de(),
            xe = we()
        }
        )
    }
    Object.keys(o.controls).forEach(t=>l[o.controls[t]] = t),
    Array.from(document.getElementsByClassName("key-input"), t=>{
        t.dataset.keyCode = l[t.dataset.fn],
        t.textContent = o.keyNames[l[t.dataset.fn]],
        $i[t.dataset.fn] = t
    }
    ),
    document.getElementById("reset-settings").addEventListener("click", ()=>{
        o = JSON.parse(JSON.stringify(a)),
        e.textContent = t.value = he.fov = o.fov,
        he.updateProjectionMatrix(),
        n.value = Math.log10(o.sensitivity),
        r.value = Math.log10(o.touchSensitivity);
        const i = {};
        Object.keys(o.controls).forEach(t=>i[o.controls[t]] = t),
        Array.from(document.getElementsByClassName("key-input"), t=>{
            t.dataset.keyCode = i[t.dataset.fn],
            t.textContent = o.keyNames[i[t.dataset.fn]]
        }
        ),
        s()
    }
    ),
    document.getElementById("restart").addEventListener("click", d),
    document.getElementById("play-again").addEventListener("click", d),
    document.body.appendChild(xi.domElement),
    function() {
        document.getElementById("touch-ui");
        const t = document.getElementById("touch-circle")
          , e = document.getElementById("breathe-interaction")
          , i = {};
        for (const t of document.querySelectorAll("[data-sim-key]"))
            i[t.dataset.simKey] = t;
        at = ((t=null)=>{
            t && t.includes("arms") && t.push("exp-up", "exp-down", "power-up", "power-down", "reset");
            for (const [e,n] of Object.entries(i))
                !t || t.includes(e) ? n.classList.add("available") : n.classList.remove("available")
        }
        );
        let n = null
          , r = null
          , a = null
          , s = null;
        function c(e) {
            (st = new THREE.Vector2((e.clientX - r.centreX) / 40,(e.clientY - r.centreY) / 40)).lengthSq() > 1 && st.normalize(),
            t.style.setProperty("--x", 40 * st.x + "px"),
            t.style.setProperty("--y", 40 * st.y + "px")
        }
        document.addEventListener("touchstart", i=>{
            if (!i.target.closest(".clickable")) {
                ot || (ot = !0,
                document.body.classList.add("using-touch"),
                document.addEventListener("touchend", Ti, {
                    once: !0
                })),
                document.body.classList.contains("hide-options") || document.body.classList.add("hide-options"),
                document.body.classList.add("hide-options");
                for (const o of i.changedTouches)
                    if (o.target.classList.contains("touch-target"))
                        if (o.target !== t || r)
                            if (o.target === e) {
                                e.classList.add("breathing");
                                const t = e.getBoundingClientRect();
                                o.clientY - t.top < t.height / 2 ? (Ii.inhale = !0,
                                Ii.exhale = !1,
                                e.classList.add("inhaling"),
                                e.classList.remove("exhaling")) : (Ii.inhale = !1,
                                Ii.exhale = !0,
                                e.classList.remove("inhaling"),
                                e.classList.add("exhaling")),
                                a = {
                                    identifier: o.identifier,
                                    rect: t
                                }
                            } else if (o.target.dataset.simKey) {
                                o.target.classList.add("pressed");
                                const t = o.target.dataset.simKey;
                                Ii[t] = !0,
                                Ui[t] && Ui[t]()
                            } else
                                o.target.classList.contains("options-btn") && (o.target.classList.add("pressed"),
                                s = o.identifier);
                        else {
                            const e = t.getBoundingClientRect();
                            r = {
                                identifier: o.identifier,
                                centreX: e.left + e.width / 2,
                                centreY: e.top + e.height / 2
                            },
                            t.classList.add("moving"),
                            c(o)
                        }
                    else
                        n || (n = {
                            identifier: o.identifier,
                            lastX: o.clientX,
                            lastY: o.clientY
                        });
                i.preventDefault()
            }
        }
        , {
            passive: !1
        }),
        document.addEventListener("touchmove", t=>{
            if (!t.target.closest(".clickable")) {
                for (const i of t.changedTouches)
                    n && n.identifier === i.identifier ? (Ci((i.clientX - n.lastX) / o.touchSensitivity, (i.clientY - n.lastY) / o.touchSensitivity),
                    n.lastX = i.clientX,
                    n.lastY = i.clientY) : r && r.identifier === i.identifier ? c(i) : a && a.identifier === i.identifier && (i.clientY - a.rect.top < a.rect.height / 2 ? (Ii.inhale = !0,
                    Ii.exhale = !1,
                    e.classList.add("inhaling"),
                    e.classList.remove("exhaling")) : (Ii.inhale = !1,
                    Ii.exhale = !0,
                    e.classList.remove("inhaling"),
                    e.classList.add("exhaling")));
                t.preventDefault()
            }
        }
        , {
            passive: !1
        }),
        document.addEventListener("touchend", i=>{
            if (!i.target.closest(".clickable")) {
                for (const o of i.changedTouches)
                    n && n.identifier === o.identifier ? n = null : r && r.identifier === o.identifier ? (st = null,
                    r = null,
                    t.classList.remove("moving")) : a && a.identifier === o.identifier ? (Ii.inhale = !1,
                    Ii.exhale = !1,
                    e.classList.remove("breathing"),
                    e.classList.remove("inhaling"),
                    e.classList.remove("exhaling"),
                    a = null) : o.target.dataset.simKey ? (o.target.classList.remove("pressed"),
                    Ii[o.target.dataset.simKey] = !1) : s === o.identifier && (o.target.classList.remove("pressed"),
                    document.body.classList.remove("hide-options"),
                    s = null);
                i.preventDefault()
            }
        }
        , {
            passive: !1
        })
    }(),
    Qi = Date.now();
    let g = null;
    he.position.set(0, 5, -350),
    he.rotation.x = -.1,
    De.add(yi),
    de(!0),
    Xe.head.parent.updateMatrixWorld(),
    tn.push(g = {
        type: "start-screen-pan",
        start: Date.now(),
        duration: 1 / 0,
        actualDuration: 3e3,
        startAngle: Math.PI / 2,
        deltaAngle: 0,
        startRadius: 500,
        deltaRadius: -480,
        lookTarget: Xe.head.getWorldPosition(new THREE.Vector3)
    }),
    nn(),
    Promise.all([Se.then(()=>{
        Te.classList.add("hide-bar")
    }
    ), (p = document.getElementById("subtitles"),
    Promise.all([Ei.then(()=>"suspended" === Me.context.state && Me.context.resume()), ...u ? Object.values(c).map(t=>{
        if (t[1])
            return new Promise((e,i)=>{
                Le.load(t[1], i=>{
                    t[1] = i,
                    e()
                }
                , null, i)
            }
            )
    }
    ) : [], h && f]))]).then(async()=>{
        De.remove(yi),
        g.duration = 0,
        Xe.person.position.y = 0,
        Xe.limbs[2].limb.rotation.x = Math.PI,
        Xe.limbs[2].forearm.rotation.x = 0,
        Xe.limbs[3].limb.rotation.x = Math.PI,
        Xe.limbs[3].forearm.rotation.x = 0,
        document.body.classList.add("hide-note"),
        Je(),
        de();
        let t = !1;
        an = (()=>{
            r(),
            t = !0,
            g && (g.duration = 0)
        }
        ),
        document.body.classList.add("hide-pose"),
        ti.head.visible = !0,
        Xe.person.rotation.y = -Math.PI / 2,
        Xe.person.position.x = 20,
        (fi = He[1]).add(ui),
        pi = "",
        gi(),
        ni(!0),
        Ki = "caught";
        const e = new THREE.Audio(Me);
        let {speak: n, interrupt: r} = m(e);
        tn.push(g = {
            type: "camera-pan",
            start: Date.now(),
            duration: 1 / 0,
            actualDuration: 4e3,
            setTrack(t, e, i) {
                g.start = Date.now(),
                t = new THREE.Vector3(...t),
                e = new THREE.Vector3(...e),
                g.from = t,
                g.to = e,
                g.roll = i,
                he.position.copy(t),
                he.lookAt(e),
                he.rotation.z = i
            }
        }),
        g.setTrack([-150, 30, -350], [-15, 15, -440], -.2),
        document.body.classList.remove("can-move"),
        at(["skip-intro"]),
        Bi("skip-intro"),
        t || await n("intro1"),
        g.setTrack([5, 10, -447], [1, 5, -452], .1),
        Bi("phone"),
        t || await n("intro2"),
        g.setTrack([-310, 15, -300], [-330, 12, -300], -.05),
        Bi("type"),
        t || await n("intro3"),
        g.duration = 0,
        ti.head.visible = !1,
        Xe.person.position.x = 0,
        Xe.person.rotation.y = Math.PI,
        document.body.classList.remove("hide-pose"),
        de(),
        $e(!0),
        Ze.canAsphyxiate = !1,
        Ki = "sitting",
        at(["skip-intro", "arms"]),
        Bi("skip-intro"),
        Bi("breathe"),
        ({speak: n, interrupt: r} = m(qe)),
        t && r();
        for (const e of rn) {
            if (t)
                break;
            "introExpansion1" === e ? (Bi("expansion"),
            await Promise.all([n("introExpansion1"), new Promise(t=>{
                K(Xe, !0, X),
                tn.push(g = {
                    type: "show-expansion",
                    start: Date.now(),
                    duration: 5e3,
                    onDone: t
                })
            }
            )]),
            Ni("expansion"),
            g = null) : "introPower1" === e ? (Bi("power"),
            await Promise.all([n("introPower1"), new Promise(t=>{
                tn.push(g = {
                    type: "show-power",
                    start: Date.now(),
                    duration: 2e3,
                    onDone: t
                })
            }
            )]),
            Ni("power"),
            g = null) : await n(e)
        }
        at([]),
        Ni("skip-intro"),
        an = null,
        "true" !== i.get("stay-intro") && (Ze.canAsphyxiate = !0,
        xe = we())
    }
    )
}
);

        </script>
    </body>
</html>
